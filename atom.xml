<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>无良</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-12-01T10:59:42.895Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>三山</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>编程语言闲谈</title>
    <link href="http://yoursite.com/2018/11/21/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E9%97%B2%E8%B0%88/"/>
    <id>http://yoursite.com/2018/11/21/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E9%97%B2%E8%B0%88/</id>
    <published>2018-11-20T16:00:00.000Z</published>
    <updated>2019-12-01T10:59:42.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编程语言闲聊"><a href="#编程语言闲聊" class="headerlink" title="编程语言闲聊"></a>编程语言闲聊</h1><blockquote><p>本篇blog只是有感而谈 不全面 不充分</p></blockquote><a id="more"></a><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><blockquote><p>以下函数式编程 简称FP</p></blockquote><h4 id="初等印象"><a href="#初等印象" class="headerlink" title="初等印象"></a>初等印象</h4><ul><li>函数是一等公民</li><li>没有副作用</li><li>不修改状态</li><li>引用透明</li></ul><p>首先函数是一等公民 什么意思 其实这句话很容易在各个地方看到,但是可能也很难理解到所谓一等公民的意义，在初始的感觉就是不用写类，可以直接写函数。后来又能理解一点函数是一等公民就是跟其他对象都一样，可以当做函数传递，也可以赋值。这其实是涉及到整个FP编程核心的一个概念，为什么要这么设计，在下文会有说明</p><p>没有副作用，不修改状态，引用透明都是因为一个东西的存在的取消实现的，这个叫中间状态。这里我就懒得说明了 贴一段写的不错的</p><blockquote><p>在函数式编程中，一个变量一旦被赋值，是不可改变的。没有可变的变量，意味着没有状态。而中间状态是导致软件难以管理的一个重要原因，尤其在并发状态下，稍有不慎，中间状态的存在很容易导致问题。没有中间状态，也就能避免这类问题。无中间状态，更抽象地说是没有副作用。说的是一个函数只管接受一些入参，进行计算后吐出结果，除此以外不会对软件造成任何其他影响，把这个叫做没有副作用。因为没有中间状态，因此一个函数的输出只取决于输入，只要输入是一致的，那么输出必然是一致的。这个又叫做引用透明。这些不同的名词差不多都在讲一个意思。</p></blockquote><p>于是这可能就是大家对FP的初等印象了。至于什么写的快，可读性强。易于并发这些特点的原因就涉及到FP中核心的设计理念了，不过上面的这些说明大概可以讲清为什么FP易于并发了</p><p>下面就开始讲语言设计本身了</p><hr><p><strong>高阶函数</strong></p><p>什么是高阶函数呢，能够接受一个或多个函数作为入参又或者返回参数是函数的这么一种函数，在java的stream中每个中间函数都是这样的格式，类似于map,filter,reduce等等</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt; def sumInts(a: Int, b: Int) = sum(id, a, b)</span><br><span class="line">&gt; &gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>高阶函数提供了一种函数级别上的<strong>依赖注入（或反转控制）</strong>机制</p><p>在上面的例子里，sum函数的逻辑依赖于注入进来的函数的逻辑。很多GoF设计模式都可以用高阶函数来实现</p><p>如Visitor，Strategy，Decorator等。比如Visitor模式就可以用集合类的map()或foreach()高阶函数来替代。</p><p>函数式语言通常提供非常强大的<strong>集合类（Collection）</strong>，提供很多高阶函数，因此使用非常方便</p><p><strong>柯里化</strong></p><p>什么是柯里化 其实在Stack Overflow上有很好的<a href="https://stackoverflow.com/questions/36314/what-is-currying" target="_blank" rel="noopener">说明</a></p><p>大概就是将一个函数多个参数转换为一个参数的过程，不然函数是很难进行类似stream方式流动的</p><p><strong>闭包</strong></p><p>闭包就是在函数中引用了自由变量的函数。这个引用的自由变量将会与这个函数一直存在，即使离开了这个环境。</p><blockquote><p>js应该同学应该比较熟悉，闭包在js中可以简单的理解为函数套函数，外面的函数作用域消亡了，但是内部引用外部函数作用域的值还保留。这就出现了闭包</p></blockquote><p><strong>惰性求值</strong></p><p>这种就是按需取值，在我们使用cache的时候也有这种思想，尽量减少服务器的压力</p><p>这样就可以通过避免不必要的求值提升性能</p><h4 id="深入到思想"><a href="#深入到思想" class="headerlink" title="深入到思想"></a>深入到思想</h4><p>函数式编程的目的是什么呢？</p><p><strong>模块化</strong></p><blockquote><p>我们需要透过表象看到更深的抽象层次，例如结构化编程和非结构化编程的区别，从表面上看比较大的一个区别是结构化编程没了“goto”语句。但更深层次是结构化编程使得模块化成为可能。像goto语句这样的能力存在，虽然会带来一定的便利，但是它会打破模块之间的界限，让模块化变得不容易。而模块化有诸多好处，首先模块内部是更小的单一的逻辑，更容易编程；其次模块化有利于复用；最后模块化使得每个模块也更加易于测试。模块化是软件成功的关键所在，模块化的本质是对问题进行分解，针对细粒度的子问题编程解决，然后把一个个小的解决方案整合起来，解决完整的问题。这里就需要一个机制，可以将一个个小模块整合起来。函数式编程有利于小模块的整合，有利于模块化编程。</p></blockquote><p>这里就涉及到了一个上文中提到的特性了 叫延迟求值 ，延迟求值与函数式的目标模块化的关系是有关系的</p><p>在一个数据量很大的场景中，在大部分语言都是及早求值的情况下，我们很难一下load如此巨大的数据到内存中，按照函数式编程缓求值的想法，我们可以先执行到第一个高级函数，如filer()，根据filter()的需要，再readFile去读相关的内容，用多少，读多少，对内存没有压力，并且很好的实现了两个模块的分离.如果走的是传统的及早求值，我们可能就是得先readFile和filter写在一个函数里，边写边读，但是这样就无法进行模块化了</p><p>为什么说函数式的可读性更强，因为函数式编程与传统的命令式编程的不同，传统的命令式编程是在对机器语言上面的抽象，而函数式编程则是对数学语言的抽象。而数学语言更加接近人的语言。更可读。所以我们平时说，函数式描述的怎么做，而命令式描述的如何做，这是关键的原因</p><blockquote><p>这里的数学语言其实是范畴论，但是这个其实如果追到这里就很容易偏离了方向，范畴论已经很难与实际的代码能够牵连在一起了，本身就是数学上的概念了，其中涉及到的物件与态射的关系本身就很难理解，更不用说关键的函子的变化与细分，会很容易的让人陷入数学的深坑中</p><p>我个人是推荐看点轻松愉快的科普文章，如一些听起来不错的有逼格的名词 如Y combinator 图灵停机问题，不完备性定律等 这里有篇很不错的科普<a href="http://mindhacks.cn/2006/10/15/cantor-godel-turing-an-eternal-golden-diagonal/" target="_blank" rel="noopener">文章</a></p></blockquote><h1 id="聊聊一些语言"><a href="#聊聊一些语言" class="headerlink" title="聊聊一些语言"></a>聊聊一些语言</h1><h2 id="typescript"><a href="#typescript" class="headerlink" title="typescript"></a>typescript</h2><blockquote><p>拯救弱类型的js超集</p></blockquote><p>由于我写前端的机会不多 还是在学习angular2的时候入门了ts,只能泛泛的谈一下Typescript这门语言</p><p>以下Typescript简称为ts</p><p>首先最重要的就是类型系统，在Ts中对类型的进步是比较大的 不仅引用了传统的java中的显示说明类型的方式 还有联合类型这种语言特性界的新宠。</p><p>当然在Ts中对es6中新引入的OO概念进行了扩展，引入了新式的interface，这与传统在java中interface不一样，在ts中的接口是一个非常灵活的概念，除了可用于对类的行为进行抽象外，也可以对外的形象进行描述。</p><p>比如 如下这种写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &apos;Tom&apos;,</span><br><span class="line">    age: 25,</span><br><span class="line">    gender: &apos;male&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最重要的当然还是类型系统这里，很欣慰的见到了泛型这个东西，虽然它的泛型实现还是相对简单的 并没有到达java1.5更新中的<code>? super extend</code>这种相对复杂的OO概念。但是也是一个非常好的开始，不知道现在社区是否已经支持到了这个级别,我们还可以看到在c语言中涉及到类似于结构体的一种写法 类型别名</p><p>同样的还有联合类型这种语言界新宠</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt; let myFavoriteNumber: string | number;</span><br><span class="line">&gt; &gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>在关键的一些的错误的时候，typescript的编辑期静态检查也可以通过类型推论做到类型检查。在编译期报错。</p><p>如下就会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let myFavoriteNumber = &apos;seven&apos;;</span><br><span class="line">myFavoriteNumber = 7;</span><br></pre></td></tr></table></figure><p>总之我是非常推荐前端同学学习这门语言的，对类型的补充是对js本身强大的增强。随着现在数据的状态在前端部分的扭转的剧增，逻辑也会随着而复杂，一些js的本身的弱类型特性已经支持的很困难了。ts可以说的上是一门非常优秀的选择</p><p>劣势：</p><p>拥有一定的学习成本</p><p>如果是前端人员可能要学习一些OO的概念</p><p>不够JS灵活</p><h2 id="kotlin"><a href="#kotlin" class="headerlink" title="kotlin"></a>kotlin</h2><blockquote><p>工程上的裱糊匠</p></blockquote><p>这是一门真正的工程语言</p><blockquote><p><a href="https://kotlinlang.org/docs/reference/server-overview.html" target="_blank" rel="noopener">文档</a></p><p><a href="https://www.kotlincn.net/docs/reference/server-overview.html" target="_blank" rel="noopener">kotlin中文社区的文档</a></p><p><a href="https://github.com/Kotlin/kotlin-koans" target="_blank" rel="noopener">Kotlin-koans练习题</a></p></blockquote><p>对kotlin语言的误解在哪里</p><p>很容易陷入对kotlin的误解中，因为kotlin在客户端领域目前是十分的流行，列如安卓，或者idea本身都是由kotlin写的。但这并不是说kotlin在服务端领域就不够优秀，反而这些年也是逐渐的上升的趋势</p><p>我们在讨论这种语言的时候，都会在考虑一个问题，就是对我们的帮助的程度问题，如果说是一门与我们工作相邻的近亲语言的话，那对我们的帮助肯定是相对远亲的语言一般来说是要大的，kotlin就是这么一门与java血缘关系非常近的语言。</p><p>首先就是java与kotlin本身就是无缝调用的，那这么一个情况下，kotlin就是可以使用java原本的库。也就很少存在库不够的情况了</p><p>第二个优势就是idea本身，对kotlin的支持也是非常到位的，由于kotlin本身就是由jetbrains开发的。所以在各种方面的支持都很到位，如空的安全监测这些特性</p><p>另外一方面为了让java人员能够快速转到kotlin中，idea提供了java到kotlin的自动convert工具，当然这个东西充满了缺点，</p><blockquote><p>这其实也是图灵停机问题的一种表达吧</p></blockquote><p>当然它还有很多新的优秀的特性，正如开头所言，这是门工程的裱糊匠语言，它充满了对工程的思考，不像scala这种还带了一点学术味道的语言，更不像haskell这种纯FP，基本很难工程的语言。它对很多语言中语言特性都有采纳，例如我之前在c++中才看到过的操作符重载，string-template，一些类型推断，跟typescript的很像的智能参数，减少java中重载这种代码的出现。同样的作为一门相对FP的语言，它的集合库也是比较强大的。在原本java的基础上也是有这自己的集合扩展，如flod，partition这些。也加入了延迟求值这个FP的标配</p><p>当然也有自己独特的对工程的理解，如很出名的空安全，类似java中一个注解lombok的data-class，java10才支持的var以及一个final的val类型表达，这也是类型推断的一种新的技术思考引用。</p><p>由于新特性太多，一一说明实在过累。只能这样大概说下这些用的很舒服的地方，还有一些细节的地方，如lambda表达式的写法改进，在lambda中的特殊占位符lt</p><p>可以说这是一门充满了惊喜了语言，如果一个人对代码本身感兴趣，我觉得这门语言的学习是十分值得的。</p><p><strong>劣势</strong></p><p>拥有一定学习成本</p><p>对于业务的支撑不够明显</p><p>在java调用kotlin存在一定的坑</p><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><blockquote><p>一门哲学的语言</p><p>人生苦短 我用python</p></blockquote><p>对于python这门语言我就随意的吐槽了，毕竟是一门很简单的语言。</p><p>推荐一本我入门的书，&lt;简明python&gt;，可以很快的入门。</p><p>这是一门朴素的语言，它不像c++这样各种魔幻的范式，它干净，整洁。专注目的。有一种实现的方式就不会实现第二种。</p><p>有一首这门语言的设计<a href="https://www.python.org/dev/peps/pep-0020/" target="_blank" rel="noopener">哲学之诗</a></p><p>它同样的也是无类型的，也是函数式的</p><p><strong>下面说一点这门语言用舒服的地方</strong></p><hr><p>无须声明类型 没有分号，lambda的写法很快捷，舒服。</p><p>字符串模板函数不错，我见过的其他语言的string_template都比java强</p><p>集合库简单好用</p><p>不是纯OO 不用写类直接写function</p><p>文档写法也很快 pip支持也比maven快捷</p><p>内置函数简单 比如IO来说 不用像java关心字节流 字符流 buffer包装 一个open函数直接OS层面类似Shell操作就可以</p><p>linux原生支持 拉出来就运行 可以代替shell了</p><p><strong>也有很多劣势的地方</strong></p><hr><p>空格对齐</p><p>不写类还得按照顺序调用function</p><p>太简单都会忘记了条件表达式后面得跟冒号</p><p>python2与python3的断崖升级 python2不能直接在python3环境运行</p><p>注意编码</p><p><strong>缺点：</strong></p><p>过于弱类型 后期的维护问题</p><p>语言本身的哲学过于沉迷于逻辑并不复杂的开发困难</p><p>对于语言本身的限制的放开</p><p>对于性能的漠不关心</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;编程语言闲聊&quot;&gt;&lt;a href=&quot;#编程语言闲聊&quot; class=&quot;headerlink&quot; title=&quot;编程语言闲聊&quot;&gt;&lt;/a&gt;编程语言闲聊&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本篇blog只是有感而谈 不全面 不充分&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>重构 改善既有代码设计读书笔记</title>
    <link href="http://yoursite.com/2018/10/03/%E9%87%8D%E6%9E%84%20%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/10/03/%E9%87%8D%E6%9E%84%20%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2018-10-02T16:00:00.000Z</published>
    <updated>2019-12-01T10:59:36.404Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前要"><a href="#前要" class="headerlink" title="前要"></a>前要</h2><p>重构是什么？ 这是我阅读这本书的初衷</p><a id="more"></a><p>在我感觉中 我们的系统总在迭代需求 写不下去就换个新系统，而重构貌似接近于重写与日常需求迭代中的一个中庸之道。或许可以帮助我们寻找一些新的工作范式</p><p>首先是重构的定义：</p><blockquote><p>对软件内部结构的一种调整。目的是在不改变软件可观察行为的前提下，提高其可见性。降低修改成本</p></blockquote><p>这是名词上的定义，</p><blockquote><p>使用一系列重构手法 在不改变软件可观察行为的前提下，调整其结构</p></blockquote><p>这是动词上的解释</p><p>这样听起来 重构就很像整理代码 它提供了一种更加高效可控的代码整理技术 ，也知道了如何使用才能将错误减少到最少。</p><p>我们重构的目的是使软件更容易被理解和修改。但必须对软件可观察的外部行为只造成很小变化，或不造成变化。这样与之对应的就是性能优化,因为性能优化很可能使得代码难以理解</p><p>在两个定义中都强调了这么一点</p><blockquote><p>重构不会改变软件可观察的行为</p></blockquote><p>也就是说 重构后的软件功能一如既往，任何用户，不论是程序员还是最终的客户，都不会感觉到有东西发生了更改</p><h3 id="为什么需要重构"><a href="#为什么需要重构" class="headerlink" title="为什么需要重构"></a>为什么需要重构</h3><p>一个项目，如果一味的添加功能，只为短期利益，设计会逐渐的腐败崩坏，逐渐的偏离了设计之初的结构。这个时候程序员就很难通过阅读代码了解原本的逻辑。</p><p>而重构就非常像整理代码。所做的事情就是让原本的事情归位。代码结构的腐败是一个流失性的，越难看懂，就越难保护原本的设计，于是腐败的越来越快，经常的重构可以维持自己代码的结构形态。</p><hr><p>在本书中列了很多重构的优点，这里大概说一下，</p><p>首先是可读性，重构后的代码可读性会变强，使得原本的代码更容易被理解，可读性非常重要，代码的后续读者对代码的运行的速度很可能没有那么的关心，但是他肯定对开发的速度非常的关心。</p><p>在大部分时候，我们写代码的时候，都不会考虑到第二个人，所以应该改变一下开发节奏，对代码做适当的修改，会使代码更好的被理解，</p><p>另外一方面 ，可以利用重构来理解不熟悉的代码，这个貌似有点玄学，我们拿到代码，为了理解用途，得反复的试，重构也可以做到这一点。尤其当这段代码没有人知道到底是个什么的时候。</p><p>第二点 可以帮你找到bug，这个感觉更玄学了，其实这是可读性增强了之后必然的一个优势。当你已经利用重构熟悉了代码，并且结构已经很好的时候，这个bug肯定是无所遁形的</p><p>其实无论优点，都可以归类为一个，重构可以帮助我们更快的开发，这个与直觉相反，多花了时间，怎么反而更快。因为良好的设计才是维持软件开发速度的根本。不然随着时间系统的腐败。一个新的功能迭代将会使得你非常疲惫。</p><h3 id="何时重构"><a href="#何时重构" class="headerlink" title="何时重构"></a>何时重构</h3><p>重构需要保持纯净。由本书两个帽子来比例，平时做的是添加新功能，那另外时间做的一件事情就是重构。添加新功能时不应该修改原有的代码，只管添加功能，通过测试。而重构时就不能添加新功能，只管改进程序结构。这个时候不需要什么测试，只在绝对必要的时候（比如接口变化）才会去修改测试。</p><p>其实在我们平时开发，就经常做这么一件事，首先写功能，后来就发现，把结构改变一下，整体的代码可读性以及维护会好很多，于是就用了重构的帽子，做了会工作。结构调整好了之后，又继续写，又发现这个结构不行了。于是又换了个帽子。继续优化结构。整体的进度是在一个渐进的过程。</p><p>再说几个重构的时机，一个是修复bug时重构，这个大家做的一般比较少，但是并不是没有必要，如果你不能一眼看出bug，显然是代码不够清晰，这就是重构的信号。</p><p>更多的时候是在代码review的时候进行重构。代码review是一种很好的东西，可以有助于传播知识，有经验的开发者可以利用这个时候把自己的经验传给相对欠缺的人，并且帮助不熟悉的人理解软件的更多细节。并且这个过程中，也可以让人提出更多有效的建议。</p><p>这得插一句 涉及极限编程中一个形式-‘结对编程’，把代码review发挥到极致，可以说边review边开发。完美了阐释了极限编程的这个名字语义。</p><blockquote><p>间接层与重构</p><p>计算机科学是这样一门科学，它相信所有问题都可以通过增加一个间接层来解决</p><p>– Dennis DeBruler</p><p>间接层的价值非常大，搞得很多人都以为重构就是extract</p><p>但是这是一把双刃剑，把一个东西分为两份，就需要管理更多一份，如果对象委托一个对象，然后后者再委托给一个对象，代码就难以阅读。</p><p>间接层的好处非常多</p><ol><li>允许逻辑共享</li><li>分开解释意图与实现</li><li>隔离变化</li><li>封装逻辑</li></ol><p>关于间接层的价值 我推荐大家阅读代码大全第7章&lt;高质量的子程序&gt;</p></blockquote><h3 id="何时不该重构"><a href="#何时不该重构" class="headerlink" title="何时不该重构"></a>何时不该重构</h3><p>我不是原教旨主义者，那么相信这个东西。很多时候你都不应该去重构，代码实在太混乱，重构它不如重写，重构反而会让你消耗更多的时间，这个决定做出来很困难，而且估计也没什么准则来帮助我们。只能说有那么个信号</p><p>现有代码不能正常运作，然后尝试去测试一下，发现全都是bug，根本不可能稳定下来。这个时候，不要考虑重构，放弃掉它</p><p>还有一个时候，项目已经到交付了，也要避免重构。</p><p>这本书有一个很好的例子，写代码就像借债，很多公司需要借债来帮助自己有效的运转，但是借债就有利息，过于复杂的代码造成的维护和扩展的成本就是利息，公司可以承担一定的利息，但是如果利息太高了就会被压垮。把债务管理好很重要，开发人员应该随时随地通过重构来偿还一部分的利息</p><blockquote><p>这里插点想法，我发现很多人非常喜欢做非常严格的预先设计，用UML图或者更古老的CRC卡片，然后得到一个可被接受的解决方案，但是这个压力太大了，这意味着一个情况，如果将来对原始设计做任何修改，代价都将非常的高昂</p><p>如果你选择重构，问题的重点就可以转变了，你仍然需要做预先设计，但是不一定需要那么的正确，此刻你只需要得到一个足够合理的方案，问题的理解是随着你的进度而不断的加深的，你可能会察觉到最佳方案与你当初设想的有点差别，但是你有重构，不成问题，它会使得成本不再高昂</p><p>这就是一种思想的转变，软件设计可以简化了很多，不然，写一个需求，得考虑到很多后续的变化，让你心惊胆战。一方面你想建立一个足够灵活，足够牢靠的解决方案，承担所有变化，问题也在这里，这么一个灵活的系统，成本太高了，它肯定会比一个简单的系统要复杂很多，最终也会相对难以维护，虽然说的确是更加的灵活了，但是你知道，变化是可能存在系统各部分的，如果所有变化的地方都建立灵活性。复杂度非常的高，同时，这其中一些肯定用不上这么好的灵活性。但是你无法预测</p><p>有了重构，就有另外一条道了，当然仍然需要考虑到潜在的变化，但是你不必逐一实现它，应该问问自己，我写的这段代码，变化重构的难度大吗，如果很简单，就这样吧</p></blockquote><h3 id="代码的坏味道"><a href="#代码的坏味道" class="headerlink" title="代码的坏味道"></a>代码的坏味道</h3><blockquote><p>以下开始抄书 具体了解的话还是得看书，我这里大概说下</p></blockquote><ol><li><p>重复代码</p><p>这点应该没什么异议，逻辑的重复很可能造成维护的困难，同一份逻辑在两个地方存在，这本身就是一个问题，虽然它看起来很平稳的运行。</p></li><li><p>过长的函数</p><p>这点在老项目中非常的常见，间接层的全部魅力都是在小函数中，一个方法或者说函数的代码长度一直是一个非常悠久的争议话题，到底多少才算长，</p></li></ol><blockquote><p>有兴趣的同学可以阅读代码大全第7章 这里拥有一些不同机构的报告，一个函数内行数对于代码可读性的影响</p></blockquote><p>这里的话 基本手法大部分都是使用extract Method 这个手法，有个技巧让你来判断这个函数是否需要extract，就是看有没有注释，如果有，你或许可以考虑尝试抽离为一个新的方法 。</p><ol><li>过大的类</li></ol><p>如果一个类做了太多事情，一非常容易出现重复，二一起开发很容易冲突，三容易变的混乱。</p><p>这个时候可以利用类似一些Extract Class的手法，可以先考虑Extract Interface，然后再抽类</p><ol><li>过长的参数列</li></ol><p>一个函数如果它的参数非常的长，完全可以包成一个对象，再传递给它，这也免息对象编程的魅力，如果采用的充血模型开发，你或者可以考虑用实例对象来取代这个参数</p><ol><li><p>发散式变化</p><p>如果某个类经常因为不同的原因在不同的方向变化，比如一个类既可以修改数据库相关，也可以修改支付相关，那么这个类最好还是分成两个对象比较合适</p></li></ol><p>针对某一个外界的变化导致的修改，都应该发生在同一个类中，而这个新类所有的内容都应该反应这个变化。为此，你可以找到某个特定原因造成的所有变化，然后用Extract Method提炼到一个新类中</p><p>6.霞弹式修改</p><p>这与上面的发散式变化非常的相像，但是他们恰恰相反，如果你遇到一个变化，需要改好多个不同的类的小修改，需要修改的代码散布四周。很难找，也很容易忘。这个时候就是将所有需要修改的地方放到一个类中。没有就创造一个。</p><p>7.依恋情节</p><p>依恋情节这么一个情况，它的气味是这样的，对某个类的兴趣要高于对自己的类的兴趣。听起来有点充血模型的感觉。比如一个车辆相关的类，但是它内部实现更关心的是运单相关的东西。那么这个类的函数应该被迁移掉，搬移到合适的地方去。</p><p>8.数据泥团</p><p>数据项会非常容易的成群结队在一起，非常容易见到，不同的函数相同的参数，不同的类相同的字段，这些东西其实可以拥有一个专属这个泥团的对象</p><p>9.基本类型偏执</p><p>这种东西就属于小对象，比如只有两三个int属性这种，专门给小任务用，但是其实这个小对象很有价值的，比如money类，这里面就两个属性币种以及数值，比如range类，一个起始值一个结束值，其实都是有价值的</p><p>10.switch语句</p><p>switch语句在面向对象编程中其实也是属于少用的一个东西，本质上说，switch的问题在于重复，经常容易发现switch语句散步在不同的地方。如果添加一个case，就得找到所有switch的地方去再添加一些。面向对象的多态可以很好的解决这个问题</p><p>11.夸夸其谈的未来性</p><p>这个东西就很有意思，也非常令人反感的一个东西。当一个人跟你说‘’我们以后总有一天会做这个事情的“然后搞了各种东西来处理这个没有的情况。这个代码的味道就很脏，很难闻。如果你确定它的确是函数都会被用到，那么可以，值得做，不然的话，还是删掉的好</p><p>12.狎昵关系</p><p>两个类联系太过紧密，甚至连private都想分享的时候，要不拆开，要不在一起。</p><p>13.中间人</p><p>中间人本来是好的，但是当你过度的运用委托，它就不好了。如果一个类，没有那么的必要，还是删掉这个层比较好。过多的层会造成很大的困扰的，不过这个问题比较少，多写代码的事情总是没人想干</p><p>14.过多的注释</p><p>注释好像很无辜，它不是很棒的吗，注释是这么一回事，一般过多的注释，都是代码写的太烂了，这是一种可以帮我们找到其他所有坏味道的一个好东西。</p><p>15.令人迷惑的暂时字段</p><p>很多时候，一个变量，只是为了一些特定的情况设的，但是这样的代价就是搞得代码不好被理解，你通常都认为这个对象所有时候都是需要这个字段的。这个东西没有被使用，而你又去猜，会让你非常的暴躁</p><p>给这个孤儿变量造个家，所有相关代码都放过去。</p><p>16.冗赘类</p><p>这得说一点，其实每个类它都是值钱的，它有身价的，以后会有人维护的，工作需要花钱的。它如果没有价值了，删了它。</p><p>17.平行的继承体系</p><p>继承的这么一个情况，属于霰弹式修改的特殊场景，如果你想增一个子类，而另外一个类也得增一个子类。你发现继承体系的类前缀与另外一个继承体系的类前缀完全相同，就是这么一种情况的坏味道</p><p>一般做法是 一个继承体系的实例引用另外一个继承体系的实例，然后再运用一些移动方法，字段的手法，就可以解决这个问题</p><p>18.过度耦合的消息链</p><p>一个对象到另外一个对象，然后后者再跳过去请求。只能这么说，导航结构很紧密。但是如果你把这个关系暴露到外面了。一旦对象间的关系发生任何修改，就会影响到客户端，然后也得修改</p><p>还是要将这个关系给它隐藏掉，或者最好还是找到消息链最后来看干什么，能不能抽出来，再推进去，不那么长。这种情况现在开发比较少见了</p><p>19.异曲同工的类</p><p>如果两个类做的事情非常的像，但是有不同的名字。移动一下的内部实现的方法的位置，或许你可以考虑下抽离出一个共有的父类。</p><p>20.不完美的类库</p><p>有的时候提供出来的类库不是那么的贴切我们的使用，这个时候我们也没法改他们的代码，只能在外面做点工作，比如封装一下</p><p>21.被拒绝的馈赠</p><p>这个也属于继承体系的一个问题，有的时候我们不想要父类的一些东西，只需要父类的一些东西，这个时候把继承改为委托会更好，或者可以尝试纯净父类的东西，将相关不需要的给它push down到子类</p><p>22.原始的数据类</p><p>这个估计见不到了，就是说这个类有一些字段，类似我们系统的中DO层，但是它没有get set这种基本的封装，直接访问，应该给它Encapsulate掉 不能这么直接</p><h2 id="重构的一些不错的手法"><a href="#重构的一些不错的手法" class="headerlink" title="重构的一些不错的手法"></a>重构的一些不错的手法</h2><blockquote><p>这里只是抽各个章节的手法的一些粗略说明 对现在开发工作有用程度比较大的一些手法，一些有用层次低一点，但不能说没有用的我就不介绍了，最好还是看书</p></blockquote><h3 id="第六章-重新组织函数"><a href="#第六章-重新组织函数" class="headerlink" title="第六章 重新组织函数"></a>第六章 重新组织函数</h3><h4 id="Extract-Method-提炼函数"><a href="#Extract-Method-提炼函数" class="headerlink" title="Extract Method 提炼函数"></a>Extract Method 提炼函数</h4><p>这个不用多说，大家最常用的</p><p>将一些代码放到一个独立函数中，并让函数名称解释它的用途。</p><h4 id="Inline-Method-内联函数"><a href="#Inline-Method-内联函数" class="headerlink" title="Inline Method 内联函数"></a>Inline Method 内联函数</h4><p>这与上面是一样的，相反的一个手法，将函数内联进去，因为这段函数本体与名称同样的清晰易懂</p><h4 id="Replace-Temp-with-Query-以查询取代临时变量"><a href="#Replace-Temp-with-Query-以查询取代临时变量" class="headerlink" title="Replace Temp with Query 以查询取代临时变量"></a>Replace Temp with Query 以查询取代临时变量</h4><p>在平时的业务代码开发中，比如说，有一段临时变量保存表达式的运算结果。我们就可以把这个表达式提炼到一个独立函数中，感觉像extract Method的变种。然后引用点给它替换到这个新函数上，这样，这个临时变量就被干掉了，而且通用了</p><h4 id="Intorduce-Explaining-Variable-引入解释性变量"><a href="#Intorduce-Explaining-Variable-引入解释性变量" class="headerlink" title="Intorduce Explaining Variable 引入解释性变量"></a>Intorduce Explaining Variable 引入解释性变量</h4><p>有一个很复杂的表达式，把结果给一个临时变量，用着个变量名来解释这个表达式的用途，比如我们经常用的Is前缀的字段。比如IsPay，IsNotify等等</p><h4 id="Split-Temporary-Variable-分解临时变量"><a href="#Split-Temporary-Variable-分解临时变量" class="headerlink" title="Split Temporary Variable 分解临时变量"></a>Split Temporary Variable 分解临时变量</h4><p>比如这一回事，一个临时变量，它的名字太泛化了，外部的函数又有足够多的东西，就很容易导致这个临时变量被赋值多次，这个时候就会导致混乱。应该分解这个变量，针对每次赋值的创造一个自己的临时变量。当然，说的并不是for循环的i变量，也不是fork-join中用来收集结果的result变量</p><h4 id="Remove-Assignments-to-Parameters-移除对参数的赋值"><a href="#Remove-Assignments-to-Parameters-移除对参数的赋值" class="headerlink" title="Remove Assignments to Parameters (移除对参数的赋值)"></a>Remove Assignments to Parameters (移除对参数的赋值)</h4><p>代码对参数进行赋值 这种问题在我们代码中还是比较常见的，这种问题最大的毛病在于降低了清晰度，应该换成一个临时变量来做这个事情，因为入参本身就是自带一个语义，就是只读的语义，如果违法了这个约定的话，代码就会不清晰</p><h4 id="Replace-Method-with-Method-Object-以函数对象取代函数"><a href="#Replace-Method-with-Method-Object-以函数对象取代函数" class="headerlink" title="Replace Method with Method Object 以函数对象取代函数"></a>Replace Method with Method Object 以函数对象取代函数</h4><p>这个是因为有很多局部变量的情况下，无法extract method的情况下的一个手法。</p><p>将这个函数放进一个单独对象中，如此一来局部变量就成了对象中的字段，然后你可以在同一个对象中将这个大型函数分解为多个小型函数</p><h3 id="第七章-在对象之间搬移特性"><a href="#第七章-在对象之间搬移特性" class="headerlink" title="第七章 在对象之间搬移特性"></a>第七章 在对象之间搬移特性</h3><p>这个章节呢 是在对象之间搬移特性,, 决定把什么职责放到哪里是非常重要的一件事，但是又因为类常常出问题，然后臃肿不堪，这个时候就需要这个章节的手法了</p><p>首先</p><h4 id="Move-Method-搬移函数"><a href="#Move-Method-搬移函数" class="headerlink" title="Move Method 搬移函数"></a>Move Method 搬移函数</h4><p>这个是基本操作，一个类的函数与另外一个类交流更多，就应该被被移过去</p><h4 id="Move-Field-搬移字段"><a href="#Move-Field-搬移字段" class="headerlink" title="Move Field 搬移字段"></a>Move Field 搬移字段</h4><p>同上，不过是字段的维度，</p><h4 id="Extract-Class-提炼类"><a href="#Extract-Class-提炼类" class="headerlink" title="Extract Class 提炼类"></a>Extract Class 提炼类</h4><p>一个类做的事情比较多，太多了，就应该提炼出来其他的类。</p><p>建立一个新类，将相关的字段和函数从旧类迁移到新类中</p><h4 id="Inline-Class-内联类"><a href="#Inline-Class-内联类" class="headerlink" title="Inline Class 内联类"></a>Inline Class 内联类</h4><p>这个用的也比较少，更多的时候我们都是在少写代码的道路一往无前</p><p>一个类做的事情太少了，将这个类的所有特性搬移到另一个类中，然后移出原类</p><h4 id="Hide-Delegate-隐藏委托关系"><a href="#Hide-Delegate-隐藏委托关系" class="headerlink" title="Hide Delegate 隐藏委托关系"></a>Hide Delegate 隐藏委托关系</h4><p>客户通过一个委托类调用另外一个对象，这个一下子可能无法立即理解，有些东西我们不是暴露这个关系的，比如说我们一线开发与具体的业务方，这个我们应该不能直接联系到。我们需要一个产品经理来做这么一层，隐藏掉这个委托关系</p><h4 id="Remove-Middle-Man-移除中间人"><a href="#Remove-Middle-Man-移除中间人" class="headerlink" title="Remove Middle Man 移除中间人"></a>Remove Middle Man 移除中间人</h4><p>这是与上面相反的一个手法，过犹不及。做了太多的简单委托，不如直接调用过去</p><h3 id="第八章-重新组织数据"><a href="#第八章-重新组织数据" class="headerlink" title="第八章 重新组织数据"></a>第八章 重新组织数据</h3><h4 id="Encapsulate-Field-自封装字段"><a href="#Encapsulate-Field-自封装字段" class="headerlink" title="Encapsulate Field 自封装字段"></a>Encapsulate Field 自封装字段</h4><p>就是比如public的字段给它封装为pojo，现在都是lombok这种东西直接简单一个注解解决，真是个好东西。</p><h4 id="Replace-Data-Value-with-Object-以对象取代数据"><a href="#Replace-Data-Value-with-Object-以对象取代数据" class="headerlink" title="Replace Data Value with Object 以对象取代数据"></a>Replace Data Value with Object 以对象取代数据</h4><p>有那么种数据，必须得跟其他数据在一起使用才有意义。这么种数据就封装成一个对象</p><h4 id="Change-value-to-Reference-将值对象改为引用对象"><a href="#Change-value-to-Reference-将值对象改为引用对象" class="headerlink" title="Change value to Reference 将值对象改为引用对象"></a>Change value to Reference 将值对象改为引用对象</h4><p>这个名字可能有点混肴，其实意思大概是说 从一个类衍生出许多彼此相等的实例，希望将它们替换为同一个对象</p><p>比如这么一个多对多情况下希望变成一个一对多的列子，一个账单是有着对应的客户的，但是不能一个账单对应一个客户，是一个客户对应一批账单</p><h4 id="Change-Reference-to-Value-将引用对象改为值对象"><a href="#Change-Reference-to-Value-将引用对象改为值对象" class="headerlink" title="Change Reference to Value 将引用对象改为值对象"></a>Change Reference to Value 将引用对象改为值对象</h4><p>这就是上面的回头路，其实所有重构手法都是要这样，重要的不是一往无前的决然，是想停就停的随意。一个人如果重构可以随时停掉，而不会有什么影响，那我觉得这个人的单论重构的水平已经是很优秀了</p><p>回到话题，为什么我们要重构回来，因为引用可能使得我们的关系变的错综复杂。而如果用原本的方式，这样的代码反而清晰明了</p><h4 id="Replace-Array-with-Object-以对象取代数组"><a href="#Replace-Array-with-Object-以对象取代数组" class="headerlink" title="Replace Array with Object 以对象取代数组"></a>Replace Array with Object 以对象取代数组</h4><p>这种重构手法是面临一种非常丑陋的情况的，比如我们在一些项目中，会看到用JSON来表示对象，对外进行承诺的。这种写法非常的丑陋。应该用对象替换掉它，在本书中，由于本书已经年代久远，Json可能还未出现。这里是用数组作列子的，不过意思都是相同的，因为人是很难记住这种信息的，说第一位是名字，第二位是年龄。必须得用字段名称以及相关的类名来描述它，这样的话，无须写注释，也无须死记</p><h4 id="Replace-Magic-Number-with-Symbolic-Constant-以常量取代魔法数"><a href="#Replace-Magic-Number-with-Symbolic-Constant-以常量取代魔法数" class="headerlink" title="Replace Magic Number with Symbolic Constant 以常量取代魔法数"></a>Replace Magic Number with Symbolic Constant 以常量取代魔法数</h4><p>魔法数这个东西历史悠久啊，这种数字就是拥有特殊意义，但是又不能明确表示出来。这个时候，把它变成一个常量会好点。其实这个魔法数还有很多可能，比如是个类型码，可以考虑搞成枚举，或者说用类取代掉。</p><h4 id="Encapsulate-Collection-封装集合"><a href="#Encapsulate-Collection-封装集合" class="headerlink" title="Encapsulate Collection 封装集合"></a>Encapsulate Collection 封装集合</h4><p>对集合的把控其实也蛮重要，不过现在代码中大家都会下意识的习惯，并不会直接的去做一些很丑陋的写法，这也有赖于工程界的进步。这个手法的意思是说，一个函数原本是返回了一个集合，但是这个集合是属于这个类本身的，</p><blockquote><p>这个写法比较少，我们现在都是Spring这种容器管理或者各种外部的持久化工具。</p></blockquote><p>在这个情况下，应该只返回一个只读的副本出去，而不是直接提供出去，添加与删除的操作，需要在这个类本身单独做出两个方法处理。</p><h4 id="Replace-Subclass-with-Fields-以字段取代子类"><a href="#Replace-Subclass-with-Fields-以字段取代子类" class="headerlink" title="Replace Subclass with Fields 以字段取代子类"></a>Replace Subclass with Fields 以字段取代子类</h4><p>这么一个情况是子类的差距太小了，只是一个字段上，这么一个情况就可以取消这些子类了，往上浮。</p><h3 id="第九章-简化条件表达式"><a href="#第九章-简化条件表达式" class="headerlink" title="第九章 简化条件表达式"></a>第九章 简化条件表达式</h3><h4 id="Decompose-Conditional-分解条件表达式"><a href="#Decompose-Conditional-分解条件表达式" class="headerlink" title="Decompose Conditional 分解条件表达式"></a>Decompose Conditional 分解条件表达式</h4><p>当有一个复杂的条件语句，可以从if then elase 三个段落分别提炼出独立函数，然后函数名替换过去。这也这一章节可以说最重要的一个手法，虽然看起来很简单，但是有时候小改动就是能造成很好的效果</p><h4 id="Consolidate-Conditional-Expression-合并条件表达式"><a href="#Consolidate-Conditional-Expression-合并条件表达式" class="headerlink" title="Consolidate Conditional Expression 合并条件表达式"></a>Consolidate Conditional Expression 合并条件表达式</h4><p>有一系列的条件，都得到相同的结果。</p><p>将这些条件合并为一个，并这个抽出来作为一个独立函数</p><h4 id="Consolidate-Duplicate-Conditional-Fragments-合并重复的代码片段"><a href="#Consolidate-Duplicate-Conditional-Fragments-合并重复的代码片段" class="headerlink" title="Consolidate Duplicate Conditional Fragments 合并重复的代码片段"></a>Consolidate Duplicate Conditional Fragments 合并重复的代码片段</h4><p>这个是在每个条件分支上面都有这么一个函数，这样的话不如拿到外面来，减少这个重复代码</p><h4 id="Remove-Control-Flag-移出控制标记"><a href="#Remove-Control-Flag-移出控制标记" class="headerlink" title="Remove Control Flag 移出控制标记"></a>Remove Control Flag 移出控制标记</h4><p>在传统的语言中，控制标记是比较常见的一种做法，用来判断条件检查停止的一个控制标记。但是既然又了break以及continue，以及现在java都可以支持break或者continue跳到指定的循环处。其实不需要这种写法了，这些写法可读性有点低。</p><h4 id="Replace-Nested-Conditional-with-Guard-Clauses-以卫语句取代嵌套条件表达式"><a href="#Replace-Nested-Conditional-with-Guard-Clauses-以卫语句取代嵌套条件表达式" class="headerlink" title="Replace Nested Conditional with Guard Clauses 以卫语句取代嵌套条件表达式"></a>Replace Nested Conditional with Guard Clauses 以卫语句取代嵌套条件表达式</h4><p>条件逻辑过于复杂的时候很难看到正常的执行路线。这个时候就得用卫语句来表现所有的特殊情况。大家可能对这里卫语句这个名词了解的少点。</p><blockquote><p><strong>卫语句就是把复杂的条件表达式拆分成多个条件表达式，比如一个很复杂的表达式，嵌套了好几层的if - then-else语句，转换为多个if语句，实现它的逻辑，这多条的if语句就是卫语句.</strong></p></blockquote><h4 id="Replace-Conditional-with-Polymorphism-以多态取代条件表达式"><a href="#Replace-Conditional-with-Polymorphism-以多态取代条件表达式" class="headerlink" title="Replace Conditional with Polymorphism 以多态取代条件表达式"></a>Replace Conditional with Polymorphism 以多态取代条件表达式</h4><p>手上有个条件表达式，根据对象的类型不同选择不同的行为。这就是经典的多态取代switch表达式的手法了。其实在面向对象的编程语言中,不像结构性编程语言，switch用的那么频繁，就是因为有多态这个神器。</p><p>做法大概就是将switch的每个分支放到子类的函数里，然后将原始的函数搞成抽象方法</p><p>当然在使用这个手法的前提，就是有一个继承体系。</p><h4 id="Introduce-Null-Object-引入Null对象"><a href="#Introduce-Null-Object-引入Null对象" class="headerlink" title="Introduce Null Object 引入Null对象"></a>Introduce Null Object 引入Null对象</h4><p>这种手法有的人也把它叫做空对象设计模式，这是一种多态的好处，多态不用去管具体是什么类型，只管调用就好，其他的机制帮你搞定。所以说空对象就是为了这么一个情况的，它也可以正确的显示自己。这么做的话有个注意点，就是需要加入一个方法，isNull。或者说用一个nullable接口也不错，这样就可以删除掉那些判断是否null的地方了</p><h3 id="第十章-简化函数调用"><a href="#第十章-简化函数调用" class="headerlink" title="第十章 简化函数调用"></a>第十章 简化函数调用</h3><h4 id="Rename-Method-函数改名"><a href="#Rename-Method-函数改名" class="headerlink" title="Rename Method 函数改名"></a>Rename Method 函数改名</h4><p>非常推荐将复杂的处理过程拆解为小函数，但是如果做的不好，这就会使得费尽周折都理不清这些小函数的具体用途。避免这个问题的关键就在于起一个好名字。这个名字能准确的表达它的用途</p><p>起一个好名字并不容易，它需要丰富的经验。一个编程的高手，起名水平也非常的重要。有关这里我也要推荐代码大全这本书 第十一章变量名的力量</p><h4 id="Add-Parameter-添加参数"><a href="#Add-Parameter-添加参数" class="headerlink" title="Add Parameter 添加参数"></a>Add Parameter 添加参数</h4><p>过长的参数列本身就是不好的味道，因为程序员很难处理这么长的参数，这个时候我们可以用一个对象来替代这些参数。</p><h4 id="Remove-Parameter-移出参数"><a href="#Remove-Parameter-移出参数" class="headerlink" title="Remove Parameter 移出参数"></a>Remove Parameter 移出参数</h4><p>很多时候多余的参数就是恶魔，而且以后可能还会用上它。不过一般这个情况下，你都可以通过多态来解决掉参数的传递问题。</p><h4 id="Separate-Query-from-Modifier-将查询函数与修改函数分离"><a href="#Separate-Query-from-Modifier-将查询函数与修改函数分离" class="headerlink" title="Separate Query from Modifier 将查询函数与修改函数分离"></a>Separate Query from Modifier 将查询函数与修改函数分离</h4><p>某些对象返回对象状态值，又修改对象状态。建立两个不同的函数，其中一个负责查询，另一个负责修改</p><p>这是一种非常好的想法，明确出两种状态 一个是有副作用 一个是无副作用的。</p><p>如果你遇到这种方法，就应该拆成这么个模样</p><h4 id="Parameterize-Method-令函数携带参数"><a href="#Parameterize-Method-令函数携带参数" class="headerlink" title="Parameterize Method 令函数携带参数"></a>Parameterize Method 令函数携带参数</h4><p>若干函数做了类似的工作，但在函数本体却包含了不同的值。</p><p>这种情况下就是因为一些小小不同的参数有一些不同。但是可以将这些各自分离的函数统一起来，通过参数来处理这些变化，用来简化问题。这样可以防止重复代码，提高灵活性</p><h4 id="Replace-Parameter-with-Explicit-Methods-以明确函数取代参数"><a href="#Replace-Parameter-with-Explicit-Methods-以明确函数取代参数" class="headerlink" title="Replace Parameter with Explicit Methods 以明确函数取代参数"></a>Replace Parameter with Explicit Methods 以明确函数取代参数</h4><p>有一个函数，其中完全取决于函数值而采取不同行为</p><p>针对该参数的每一个可能，建立一个独立函数。</p><p>这跟上面的完全相反。这种适合给一个清晰的接口下。值得进行这项重构。</p><h4 id="Preserve-Whole-Object-保持对象完整"><a href="#Preserve-Whole-Object-保持对象完整" class="headerlink" title="Preserve Whole Object 保持对象完整"></a>Preserve Whole Object 保持对象完整</h4><p>从某个对象中取出若干值，作为某一次函数调用时的参数。</p><p>改为传递整个对象</p><p>为什么要这样做呢，有的时候变化就是这样，这次传一点点，后面很可能需要这个对象的其他参数，这个时候如果很难进行扩展，如涉及到其他的服务应用的情况下，就很困难。所以这个情况下传递整个对象比较合适，这还可以使得对象可读性更高。不过事情总是有两面性，有的时候这种手法会使得依赖结构恶化，那就不应该使用这个手法。</p><h4 id="Replace-Parameter-with-Methods-以函数取代参数"><a href="#Replace-Parameter-with-Methods-以函数取代参数" class="headerlink" title="Replace Parameter with Methods 以函数取代参数"></a>Replace Parameter with Methods 以函数取代参数</h4><p>对象调用某个函数，并将所得结果作为参数，传递给另一个函数，而接受该参数的函数本身也能调用前一个函数</p><p>让函数接受者去除该项参数，并直接调用前一个函数</p><h4 id="Introduce-Parameter-Object-引入参数对象"><a href="#Introduce-Parameter-Object-引入参数对象" class="headerlink" title="Introduce Parameter Object 引入参数对象"></a>Introduce Parameter Object 引入参数对象</h4><p>有一些参数总是不知不觉的就在一个方法变多了，这个时候就需要用一个对象替换这个了。</p><h4 id="Remove-Setting-Method-移出设置函数"><a href="#Remove-Setting-Method-移出设置函数" class="headerlink" title="Remove Setting Method 移出设置函数"></a>Remove Setting Method 移出设置函数</h4><p>类的某个字段应该在对象创建时被设置，然后不再改变</p><p>这个指有些对象是不需要设置的，但是给出了一个set函数。这就不行了，过度的自由，就会被滥用。</p><h4 id="Hide-Method-隐藏函数"><a href="#Hide-Method-隐藏函数" class="headerlink" title="Hide Method 隐藏函数"></a>Hide Method 隐藏函数</h4><p>有一个函数，从来没人用过，可以注释掉，也可以直接private掉</p><h4 id="Replace-Constructor-with-Factory-Method-以工厂函数取代构造函数"><a href="#Replace-Constructor-with-Factory-Method-以工厂函数取代构造函数" class="headerlink" title="Replace Constructor with Factory Method 以工厂函数取代构造函数"></a>Replace Constructor with Factory Method 以工厂函数取代构造函数</h4><p>希望在创建对象时不仅仅是做简单的建构动作，</p><p>将构造函数替换为工厂函数</p><p>比如在需要根据类型码派生子类的时候</p><h4 id="Replace-Error-Code-With-Exception-以异常替换为错误码"><a href="#Replace-Error-Code-With-Exception-以异常替换为错误码" class="headerlink" title="Replace Error Code With Exception 以异常替换为错误码"></a>Replace Error Code With Exception 以异常替换为错误码</h4><p>某个函数返回一个特点的代码，用以表示某种错误情况</p><p>改用异常</p><p>这跟上面我们说的有副作用和无副作用异曲同工。一种是错误码，一种是异常，这两种代表的其实是两个意思，一个是普通程序，一个是错误处理。代码的可理解性是一个非常重要的目标，相信我，这是比代码的复用是更高的目标要求。</p><h4 id="Replace-Exception-with-Test-以测试取代异常"><a href="#Replace-Exception-with-Test-以测试取代异常" class="headerlink" title="Replace Exception with Test 以测试取代异常"></a>Replace Exception with Test 以测试取代异常</h4><p>异常不应该被滥用，这种情况本身就应该在测试阶段被拦截掉，而不应该抛出来一个异常。</p><p>修改这个调用者，在之前的条件判断的地方就拦截这个可能出现的错误。而不是让异常成为条件检查的替代品</p><h3 id="第十一章-处理概括关系"><a href="#第十一章-处理概括关系" class="headerlink" title="第十一章 处理概括关系"></a>第十一章 处理概括关系</h3><p>这章有许多手法都是在处理类的概括关系 英文原文是generalization 即继承关系，这部分的手法我就不介绍了，因为在现状的开发环境中，各种工具推行的基本都是贫血模型的开发方式，在项目中更多的是通过包或者说名字来进行区分这个类的作用，而不是充血的完整的对象语义。对继承的情况使用的非常的少。当然也还是有很多值得学习的地方，限于篇幅所限，在此就不做过多介绍。只介绍几个比较常用的手法</p><h4 id="Extract-Interface-提炼接口"><a href="#Extract-Interface-提炼接口" class="headerlink" title="Extract Interface 提炼接口"></a>Extract Interface 提炼接口</h4><p>在两个类有部分接口相同的情况或者两个类的接口有部分相同</p><p>将相同的子集提炼到一个独立接口中</p><h4 id="Form-TemPlate-Method-塑造模板函数"><a href="#Form-TemPlate-Method-塑造模板函数" class="headerlink" title="Form TemPlate Method 塑造模板函数"></a>Form TemPlate Method 塑造模板函数</h4><p>你有一些子类 其中相应的某些函数以相同顺序执行类似的操作，但各个操作的细节上有所不同</p><p>将这些操作分别放进独立函数中，并保持它们都有的签名，于是原函数也就变得相同了，然后将原函数上移至超类</p><p>这其实也是在继承关系的一个手法，但是这个手法还是有意义的，这看起来很像一个模板方法模式。但其实又有所不同，不过这跟设计原则并不冲突，从另一个角度上说，这就是一个LSP原则，OCP原则，DIP原则都有些关系的好手法</p><h4 id="Replace-Inheritance-With-Delegation-以委托替代继承"><a href="#Replace-Inheritance-With-Delegation-以委托替代继承" class="headerlink" title="Replace Inheritance With Delegation 以委托替代继承"></a>Replace Inheritance With Delegation 以委托替代继承</h4><p>某个子类只能使用超类接口中的一部分，或是根本不需要继承而来的数据</p><p>在子类中新建一个类以保持超类，调整子类，令它改为委托，现在的话就是IOC容器，一个依赖注入。然后去除掉两者之间的继承关系</p><p>其实每次说到这个手法的时候，都会把JDK中的stack与Vector类拿来鞭尸一下，虽然说现在已经没人用着两个类了，这就属于滥用的一种典型案例啊。有兴趣的可以具体看下</p><h2 id="重构，复用与现实"><a href="#重构，复用与现实" class="headerlink" title="重构，复用与现实"></a>重构，复用与现实</h2><p>虽然重构很美好，但是更多的时候你并不想重构你的程序，为什么呢</p><p>1.你不知道如何重构</p><p>2.你知道这是个长远的好东西，但是何必现在付出这个努力，说不定真的腐败的时候，你早就离职跳槽了</p><p>3.代码重构是一个额外的耗时的功能，老板付钱的时候，只是想让你写新功能</p><p>4.重构会对现有代码进行更改，可能会对现有代码造成破坏</p><p>但是随之时间的流逝，错误会不断的传播，复制，程序变的臃肿。当初的设计变的腐败不堪，修改的成本逐步上升</p><p>你或许也很同意Fred Brooks说的一句话</p><blockquote><p>应对并处理变化，是软件开发的根本复杂性之一</p></blockquote><p>重构就好像运动，吃合适的食物。都知道，需要锻炼身体，吃合适的东西才会有好身体，有些人不注重这些事情，而且目前看起来也没什么影响。所以可以依赖各种其他的招数，说服自己。但其实如果一直都忽视这些好习惯，其实都只是在欺骗自己。</p><p>重构另一方面非常让人关心的一点就是安全问题。</p><p>但其实对很多程序员来说，这些问题其实没那么的严重，我们总是跟孩子说，”安全第一”，但是我们却一直向往着血气方刚的驾驶员，酷炫的打斗。这其实比较讽刺，不给出自由，想让人飞，不现实。</p><p>一般的重构的安全性是定义是什么呢，一般来说是不会造成任何破坏的重构就是安全的。重构其实就是在不改变程序行为的情况修改程序结构，所以重构后与重构前应该完全相同。</p><p>怎么进行安全的重构，这应该是我们关注的重点，其实也没什么诀窍。</p><p>1 相信你自己</p><p>2 相信编译器</p><p>3 相信你的测试组件</p><p>4 相信review的力量</p><p>但其实你是会犯错的，编译器在一些微妙的场景下，无法帮助你，测试用例也是有限的，review人员很可能由于忙于自己的本质工作，没有办法的彻底检查。</p><p>幸运的是，对于重构安全性的检查往往是轻而易举的，例如，建立一个超类，就分为几个步骤，每个步骤都是比较简单的，比如创建函数，搬移字段。只要你确定你每一步都是安全的，那么整个复杂的重构也是安全的</p><p>在前面提到的现实世界问题，不仅仅存在于重构中，它们广泛存于在软件的演化和复用中。</p><p>复用的问题，与重构的问题也是非常的相似。</p><p>1.技术人员可能不知道 该复用什么，或者如何复用</p><p>2.技术人员可能对于采用复用方法缺乏动力，除非它们能获取到短期利益</p><p>3.如果要成功适应复用方法，开销，学习曲线和探索成本都必须要考虑</p><p>4.采用复用方法不该引起项目混乱，项目可能有很大的压力。尽管面对遗留系统的束缚，仍应让现有资产或实现发挥作用。新的实现应该与现有系统协同工作，或至少向下兼容。</p><blockquote><p>这里有句话很不错</p><p>Geoffrey Moore把技术的发展接纳过程描述为一个曲线。前段包括先行者和早期接受者，中段急剧增加的是早期消费群体以及晚期消费群体，末端则是那些行动缓慢的人</p><p>如果一个技术或者思想想要获得成功，得到中段的人支持非常的重要，另一方面，许多先行者或早期接受者很有吸引力的想法，最后彻底失败，就是因为他们没能跨越鸿沟，让早期消费者与晚期消费者接纳他们。之所以有这样的鸿沟的原因在于，不同的人群有不同的消费动机。</p><p>前段的人 关注的是新技术，突破性的思想，范式的转移。早期以及晚期的消费群体主要关心的是成熟度，支持力度，以及这个产品在跟他们相似需求的其他人是否成功套用</p><p>研究人员往往是先行者，而软件主管或者一些软件开发者往往是早期或晚期消费者。如果你想让你的技术得人心，了解这一点差异非常重要。提倡一个新技术或者一种新的开发范式，得冒一些风险。得跟主管人员静心制定策略，与开发组协商，在研讨会与出版物向广大研究人员宣言这些技术的好处，在这个整个过程中。很重要的几件事：对员工进行培训，尽量获取到短期利益，减小开销。安全的引进新技术。这些知识，都是我从重构的研究中得来的</p><p>技术的传播是很困难，但不是做不到</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前要&quot;&gt;&lt;a href=&quot;#前要&quot; class=&quot;headerlink&quot; title=&quot;前要&quot;&gt;&lt;/a&gt;前要&lt;/h2&gt;&lt;p&gt;重构是什么？ 这是我阅读这本书的初衷&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="重构" scheme="http://yoursite.com/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>成为Java GC专家 第二篇（译）</title>
    <link href="http://yoursite.com/2017/11/04/%E6%88%90%E4%B8%BAJava%20GC%E4%B8%93%E5%AE%B6%20%E7%AC%AC%E4%BA%8C%E7%AF%87%EF%BC%88%E8%AF%91%EF%BC%89/"/>
    <id>http://yoursite.com/2017/11/04/%E6%88%90%E4%B8%BAJava%20GC%E4%B8%93%E5%AE%B6%20%E7%AC%AC%E4%BA%8C%E7%AF%87%EF%BC%88%E8%AF%91%EF%BC%89/</id>
    <published>2017-11-03T16:00:00.000Z</published>
    <updated>2019-12-01T11:01:25.166Z</updated>
    
    <content type="html"><![CDATA[<h1 id="成为Java-GC专家-第二篇（译）"><a href="#成为Java-GC专家-第二篇（译）" class="headerlink" title="成为Java GC专家 第二篇（译）"></a>成为Java GC专家 第二篇（译）</h1><h1 id="如何监控Java垃圾回收（译）"><a href="#如何监控Java垃圾回收（译）" class="headerlink" title="如何监控Java垃圾回收（译）"></a>如何监控Java垃圾回收（译）</h1><blockquote><p>原文<a href="https://www.cubrid.org/blog/how-to-monitor-java-garbage-collection" target="_blank" rel="noopener">how-to-monitor-java-garbage-collection</a></p></blockquote><p>这是”成为Java GC专家”系列的第2篇，<br>在第一篇文章中了解Java GC我们学习了各种GC算法，关于Gc如何工作，年轻代和老年代是什么，在新的JDK7中，你应该知道5种GC类型，和这些GC类型对应的性能影响<br><a id="more"></a><br>在本文中，我将<strong>解释JVM如何实时运行GC</strong></p><h2 id="什么是GC监控"><a href="#什么是GC监控" class="headerlink" title="什么是GC监控"></a>什么是GC监控</h2><p><strong>垃圾回收监控</strong>是搞清楚JVM如何运行GC的过程，比如，我们可以发现：</p><ol><li>当一个年轻代的对象移动到老年代</li><li>或者是‘stop-the-world’的事件发生以及它的时长</li></ol><p>GC监控jvm是否高效的在运行GC，和检测GC调优是否有必要 基于以上信息，我们可以修改应用程序或者修改GC方法（GC调优）</p><h2 id="如何监控GC"><a href="#如何监控GC" class="headerlink" title="如何监控GC"></a>如何监控GC</h2><p>有不同的监听方法，但是唯一的区别就是如何显示GC操作信息，GC是由Jvm完成的，而GC监控工具是提取到了JVM提供的GC信息，所以无论你如何监控GC，都将获得相同的结果。因此 你不需要学会所有有关GC的方法，但是需要一点点时间来学习不同监控GC的方法 知道这些可以帮助你在不同的情况和环境中使用</p><p>在以下列出的JVM选项都是不能普遍使用的 ，换言之就是不一样的产品是不能使用一样的选项的，无论HVM商是什么（HVM是什么？）<br>，这是因为没有一个公开的公共的GC标准，在本文例子中我们使用 HotSpot VM（Oracle的JVM），由于NHN中使用的是Oracle（Sun）JVM，应用这些工具中的JVM选项并不困难，我们将在这里解释这些内容</p><p>首先，GC监控方法分为CUI和GUI俩种访问接口 ，一个比较典型的CUI GC监控名为“jstat”的单独CUI应用程序，或者在JVM运行时选择一个名为“verbosegc”</p><p>GUI GC监控使用单独一个GUI的程序，最重要使用三个“jconsole”，“jvisualvm”，“Visual GC”</p><p>让我们进一步了解每种方法</p><h2 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h2><p><strong>jstat</strong>是一个HotSpot的监控工具，HotSpot的其他监控工具分别为<strong>jps</strong>和<strong>jstatd</strong>，有时 你需要所有三种工具监控Java程序</p><p><strong>jstat</strong>不仅仅只提供GC信息，它还提供类加载器操作信息或即时编译器操作信息 在<strong>jstat</strong>提供的所有信息中，在本文中，我们将仅仅介绍其监视GC操作信息的功能</p><p><strong>jstat</strong>在$JDK_HOME/bin ，如果Java和javac没有在命令行中包含单独目录的条件下运行 那么jstat也是一样的</p><p>你可以尝试以下命令<br><a href="https://raw.githubusercontent.com/SanShanYouJiu/ImageRepository/master/JVM与GC相关/监控GC jstat.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/SanShanYouJiu/ImageRepository/master/JVM%E4%B8%8EGC%E7%9B%B8%E5%85%B3/%E7%9B%91%E6%8E%A7GC%20jstat.png" alt="此处输入图片的描述"></a></p><p>像在本例中，每个实际数据都在以下行进行输出</p><blockquote><p><strong>S0C S1C S0U S1U EC EU OC OU PC.</strong></p></blockquote><p><strong>vmid</strong>(虚拟机ID)，正如它的名字一样，这是一个虚拟机的ID，可以使用指定的vmid运行本地或者远程的java应用程序。这个vmid如果在本地机器上被称为<strong>lvmid（local vmid）</strong>,通常被称为PID，你可以使用<strong>ps</strong>命令来写PID或者使用windows任务管理，但是我们使用jps因为pid有时候会跟lvmid不匹配，jps代表java Ps,jps显示vmid和主要方法信息，就像ps显示PID和处理名称</p><p>使用JPS来找出想要监控的java应用程序的vmid，然后在jstat中使用参数，如果你单独使用jps， 当一个设备运行几个WAS实例时，只有引导信息会显示。我们建议使用<code>ps -ef | grep java</code>命令以及<code>jps</code>命令</p><p>Gc性能数据需要不断观察，因此当运行jstat时，需要尝试定期输出GC监控信息</p><p>比如运行 <code>jstat –gc &lt;vmid&gt; 1000</code>(或者1s）将会每隔一秒显示GC监控数据在控制台上.<code>jstat –gc &lt;vmid&gt; 1000 10</code>将每隔一秒显示GC数据显示10次</p><p>除了GC还有很多选项，其中GC的相关选项如下</p><table><thead><tr><th style="text-align:left">选项名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">gc</td><td style="text-align:left">它显示当前每个堆区的当前大小，和当前使用量（Ede,survivor,old,等等)，总共GC执行速，以及GC操作的累计时间</td></tr><tr><td style="text-align:left">gccapactiy</td><td style="text-align:left">它显示每个堆区域的最小大小（ms）和最大大小（mx），当前大小和每个区域执行的GC数量。（不显示GC操作的当前使用情况和累积时间。）</td></tr><tr><td style="text-align:left">gccause</td><td style="text-align:left">最近一次GC统计和原因</td></tr><tr><td style="text-align:left">gcnew</td><td style="text-align:left">显示新区域的GC性能数据。</td></tr><tr><td style="text-align:left">gcnewcapacity</td><td style="text-align:left">显示新区域的大小的统计。</td></tr><tr><td style="text-align:left">gcold</td><td style="text-align:left">显示旧区域的GC性能数据</td></tr><tr><td style="text-align:left">gcoldcapacity</td><td style="text-align:left">显示旧区域的大小统计。</td></tr><tr><td style="text-align:left">gcpermcapacity</td><td style="text-align:left">显示永久区域的统计数据。</td></tr><tr><td style="text-align:left">gcutil</td><td style="text-align:left">以百分比显示每个堆区的用法。还显示GC执行的总数和GC操作的累积时间。</td></tr></tbody></table><p>只要看频率，你可能按照这个<strong>-gcutil</strong>(或者-<strong>gccause</strong>)，<strong>-gc</strong>和<strong>-gccapacity</strong>顺序使用</p><ul><li><strong>-gcutil</strong>用于检查堆区域的使用情况，GC执行的数量以及GC操作的总累计时间，</li><li>而<strong>-gccapacity</strong>选项和其他选项用于检查分配的实际大小。<br>您可以使用<strong>-gc</strong>选项看到以下输出：<br><a href="https://raw.githubusercontent.com/SanShanYouJiu/ImageRepository/master/JVM与GC相关/jvm&amp;gc jstat-gc.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/SanShanYouJiu/ImageRepository/master/JVM%E4%B8%8EGC%E7%9B%B8%E5%85%B3/jvm&amp;gc%20jstat-gc.png" alt="此处输入图片的描述"></a></li></ul><p>显示不同的jstat选项显示不同类型的列，这些选项在下面列出，每列信息将在你使用右边的jstat选项之后显示</p><blockquote><p>这里太多不想抄了 关心的同学可以百度到中文版本 <a href="http://blog.csdn.net/zhaozheng7758/article/details/8623549" target="_blank" rel="noopener">Jstat命令详情其1</a>,<br><a href="http://blog.csdn.net/maosijunzi/article/details/46049117" target="_blank" rel="noopener">Jstat命令详情其2</a></p></blockquote><p>jstat的优势是只要可以使用控制台，就随时监控远程或者本地的Java应用程序的GC操作数据。在这些项目，使用-gcutil时输出以下结果<br>在GC调优时，需要注意<strong>YGC,YGCT,FGCT</strong>,和<strong>GCT</strong><br><a href="https://raw.githubusercontent.com/SanShanYouJiu/ImageRepository/master/JVM与GC相关/jstat-gcutil.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/SanShanYouJiu/ImageRepository/master/JVM%E4%B8%8EGC%E7%9B%B8%E5%85%B3/jstat-gcutil.png" alt="此处输入图片的描述"></a><br>这些选项是十分重要的，因为这些选项显示了你运行GC上花费了多少时间</p><p>在这个例子中 <strong>YGC</strong>是217，<strong>YGCT</strong>是0.928 算出算术平均值后，你可以看到每个年轻GC需要约4ms 像这种情况的 full gc的时间是33ms</p><p>但是计算平均值常常无法帮助我们分析GC问题，这是因为GC运行时间的严重偏差造成的，（比如一种情况，总共的运行时间为0.067秒 但是其中一个是1ms，另外一个GC运行时间为57ms），如果你是为了检测单独的GC时间而不是平均值， 你就需要<strong>-verbosegc</strong></p><h2 id="verbosegc"><a href="#verbosegc" class="headerlink" title="-verbosegc"></a>-verbosegc</h2><p><strong>-verbosegc</strong>是运行java应用程序的一个jvm选项，虽然不需要任何特别选项jstat就能监听jvm应用程序，而-verbosegc需要在开启时指定， 因此可以将其视为不必要的选项（因为可以使用jstat）</p><p>但是，在当gc发生时 使用-verbosegc易于理解的输出，会对粗略的GC信息检测非常有帮助</p><table><thead><tr><th style="text-align:left">–</th><th style="text-align:left">jstat</th><th style="text-align:left">-verbosegc</th></tr></thead><tbody><tr><td style="text-align:left">监测对象</td><td style="text-align:left">在可以登录终端的计算机上运行Java应用程序，或者使用jstatd可以连接到网络的远程Java应用程序</td><td style="text-align:left">只有当-verbogc被指定为JVM启动选项时</td></tr><tr><td style="text-align:left">输出信息</td><td style="text-align:left">堆状态（使用情况，最大大小，GC /时间等的次数）</td><td style="text-align:left">GC之前/之后的ew和旧区域的大小以及GC操作时间</td></tr><tr><td style="text-align:left">输出时间</td><td style="text-align:left">每个指定的时间</td><td style="text-align:left">每当GC发生</td></tr><tr><td style="text-align:left">何时有用</td><td style="text-align:left">试图观察堆区大小的变化</td><td style="text-align:left">试图看到单个GC的效果</td></tr></tbody></table><p>以下是可以与-verbosegc一起使用的其他选项</p><ul><li>-XX:+PrintGCDetails</li><li>-XX:+PrintGCTimeStamps</li><li>-XX:+PrintHeapAtGC</li><li>-XX:+PrintGCDateStamps (from JDK 6 update 4)</li></ul><p>如果只使用-verbosegc，则默认使用-XX:+PrintGCDetails.-verbosegc并不是只能使用一个选项 可以使用多个混用</p><p>当你使用-verbosegc，当minor GC发生时你可以看到以下格式的输出信息<br><a href="https://raw.githubusercontent.com/SanShanYouJiu/ImageRepository/master/JVM与GC相关/Verboscgc minor gc.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/SanShanYouJiu/ImageRepository/master/JVM%E4%B8%8EGC%E7%9B%B8%E5%85%B3/Verboscgc%20minor%20gc.png" alt="此处输入图片的描述"></a><br>Collector|用于Minor GC的Collector名<br>–|–<br>starting occupancy1|GC之前的年轻区域的大小<br>ending occupancy1|GC后的年轻区域的大小<br>pause time1|Java应用程序停止运行次要GC的时间<br>starting occupancy3|GC之前的堆区总大小<br>ending occupancy3 |GC后堆面积的总大小<br>pause time3|Java应用程序停止运行整个堆GC（包括主要GC）的时间</p><p>这是一个-verbosegc关于minor Gc的输出信息<br><a href="https://raw.githubusercontent.com/SanShanYouJiu/ImageRepository/master/JVM与GC相关/verboscgc minor gc output.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/SanShanYouJiu/ImageRepository/master/JVM%E4%B8%8EGC%E7%9B%B8%E5%85%B3/verboscgc%20minor%20gc%20output.png" alt="此处输入图片的描述"></a></p><p>这是Full GC发生后的输出结果示例。<br><a href="https://raw.githubusercontent.com/SanShanYouJiu/ImageRepository/master/JVM与GC相关/Verboscgc full gc  .png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/SanShanYouJiu/ImageRepository/master/JVM%E4%B8%8EGC%E7%9B%B8%E5%85%B3/Verboscgc%20full%20gc%20%20.png" alt="此处输入图片的描述"></a></p><p>如果是CMS collector ，那么也可以提供以下CMS信息</p><p>由于每次GC事件发生时-verbosegc都会输出日志，很容易看到GC运行引起的堆使用率的变化。</p><h2 id="Java-VisualVM-Visual-GC"><a href="#Java-VisualVM-Visual-GC" class="headerlink" title="(Java) VisualVM + Visual GC"></a>(Java) VisualVM + Visual GC</h2><p>Java Visual VM是由Oracle JDK提供的GUI分析/监视工具。<br><a href="https://www.cubrid.org/files/attach/images/1747/748/001/e387fd9fbccb654f3d8db696fb215403.png" target="_blank" rel="noopener"><img src="https://www.cubrid.org/files/attach/images/1747/748/001/e387fd9fbccb654f3d8db696fb215403.png" alt="此处输入图片的描述"></a><br>图1：VisualVM截图<br>你可以从网站上下载最新版，而不是用JDK自带的版本，为了方便起见，JDK自带的Visual vm被称为 Java VisualVM (jvisualvm)，而从网站上下载的版本被称为 Visual VM (visualvm). 俩者的功能并不完全相同，有一些细微的差别，就个人而言，我更喜欢Visual VM版本，可以从网站上下载。<br>在GC运行后，你可以从左侧的窗口选择你想监控的程序。你可以在那里找到“监控”标签。你可以从监控面板中获得关于GC的基本信息<br>虽然GC的基本状态可以从VisualVM中获得，但是你无法像<strong>jstat</strong>或者<strong>-verbosegc</strong>一样获得详细信息</p><p>如果你想要jstat提供的详细信息，那么推荐你安装Visual GC的插件</p><p>Visual GC可以通过工具菜单实时访问<br><a href="https://www.cubrid.org/files/attach/images/1747/748/001/28c621040950b1010adca98e19baad62.png" target="_blank" rel="noopener"><img src="https://www.cubrid.org/files/attach/images/1747/748/001/28c621040950b1010adca98e19baad62.png" alt="此处输入图片的描述"></a><br>图2：Viusal GC安装截图</p><p>通过使用Visual GC，您可以更直观地查看运行<strong>jstatd</strong>所提供的信息。</p><p><a href="https://www.cubrid.org/files/attach/images/1747/748/001/1b37381a6b243d19cc73843dd134b86e.png" target="_blank" rel="noopener"><img src="https://www.cubrid.org/files/attach/images/1747/748/001/1b37381a6b243d19cc73843dd134b86e.png" alt="此处输入图片的描述"></a><br>图3：Visual GC执行屏幕截图</p><h2 id="HPJMeter"><a href="#HPJMeter" class="headerlink" title="HPJMeter"></a>HPJMeter</h2><p>HPJMeter便于分析<strong>-verbosegc</strong>的结果，如果Visual GC被认为是jstat的GUI，那么HPJMeter就是verbosgc的GUI，GC只是HPJMeter功能中的其中之一，HPJMeter是HP开发的性能监控工具。它可以在HP-UX以及Linux和MS Windows中使用。</p><p>本来，分析<strong>-verbosegc</strong>日志图形化的是<strong>HPTUN</strong>,但是，在HPTun3.0时已经被集成到了HPJMeter中，你不需要单独下载</p><p>执行应用程序时，<strong>-verbosegc</strong>输出结果将被输出到一个单独的文件。</p><p>您可以使用HPJMeter打开输出的文件，通过直观的图形用户界面（GUI），可以更快，更轻松地进行GC性能数据分析。</p><h2 id="下一篇文章是讲什么的？"><a href="#下一篇文章是讲什么的？" class="headerlink" title="下一篇文章是讲什么的？"></a>下一篇文章是讲什么的？</h2><p>在本文中 我重点讲了如何监控GC,为GC调优的准备，根据我的经验 ，我建议使用<strong>jstat</strong>来监视GC操作，如果你执行GC需要太多时间，那么请尝试使用<strong>-verbosegc</strong>选项来分析GC,一般的GC调优过程是在基于-verbosegc分析之后进行的</p><p>在下一篇文章，我们将讲讲一些具体案例来看到调优GC的最佳选项</p><p><a href="http://oopjava.cn/tags/JVM-GC/" target="_blank" rel="noopener"># JVM&amp;&amp;GC</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;成为Java-GC专家-第二篇（译）&quot;&gt;&lt;a href=&quot;#成为Java-GC专家-第二篇（译）&quot; class=&quot;headerlink&quot; title=&quot;成为Java GC专家 第二篇（译）&quot;&gt;&lt;/a&gt;成为Java GC专家 第二篇（译）&lt;/h1&gt;&lt;h1 id=&quot;如何监控Java垃圾回收（译）&quot;&gt;&lt;a href=&quot;#如何监控Java垃圾回收（译）&quot; class=&quot;headerlink&quot; title=&quot;如何监控Java垃圾回收（译）&quot;&gt;&lt;/a&gt;如何监控Java垃圾回收（译）&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;原文&lt;a href=&quot;https://www.cubrid.org/blog/how-to-monitor-java-garbage-collection&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;how-to-monitor-java-garbage-collection&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是”成为Java GC专家”系列的第2篇，&lt;br&gt;在第一篇文章中了解Java GC我们学习了各种GC算法，关于Gc如何工作，年轻代和老年代是什么，在新的JDK7中，你应该知道5种GC类型，和这些GC类型对应的性能影响&lt;br&gt;
    
    </summary>
    
    
    
      <category term="JAVA" scheme="http://yoursite.com/tags/JAVA/"/>
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="JVM&amp;&amp;GC" scheme="http://yoursite.com/tags/JVM-GC/"/>
    
  </entry>
  
  <entry>
    <title>成为Java GC专家 第一篇（译）</title>
    <link href="http://yoursite.com/2017/10/31/%E6%88%90%E4%B8%BAJava%20GC%E4%B8%93%E5%AE%B6%20%E7%AC%AC%E4%B8%80%E7%AF%87%EF%BC%88%E8%AF%91%EF%BC%89/"/>
    <id>http://yoursite.com/2017/10/31/%E6%88%90%E4%B8%BAJava%20GC%E4%B8%93%E5%AE%B6%20%E7%AC%AC%E4%B8%80%E7%AF%87%EF%BC%88%E8%AF%91%EF%BC%89/</id>
    <published>2017-10-30T16:00:00.000Z</published>
    <updated>2019-12-01T10:54:42.202Z</updated>
    
    <content type="html"><![CDATA[<h1 id="了解Java-GC-（译）"><a href="#了解Java-GC-（译）" class="headerlink" title="了解Java GC （译）"></a>了解Java GC （译）</h1><blockquote><p>最近在了解Java Gc相关内容 看到一篇不错的入门文章 原文<a href="https://www.cubrid.org/blog/understanding-java-garbage-collection" target="_blank" rel="noopener">Understanding Java Garbage Collection</a><br>本文是“成为一个Java GC专家”系列的第一篇<br><a id="more"></a><br>想知道Java中GC的好处吗？<br>满足一个软件知识分子的好奇心是一个很好的原因 但是不仅如此 明白GC是如何工作的可以帮助您写出更好的Java程序</p></blockquote><p>这里的仅仅只是我个人的主观的想法 但是我觉得 一个精通GC的人往往是一个更好的Java程序员 如果您对GC的过程感兴趣 代表着您有开发某种规模应用程序的经验 如果您仔细考虑了如何选择正确的GC算法 这意味着你完全了解你开发的应用程序的功能 当然 这个条件不能适合所有好的开发者<br>但是 当我说懂GC是一个好的Java开发者的必要条件时 很少有人反对</p><p>这是“成为一个Java GC专家”系列的第一篇 这里我将介绍GC的大概内容 在下一篇 我讨论来自NHN的例子中的分析GC的状态与调优</p><p>有一个术语 需要在正式学习GC之前了解 这个就是“<strong>stop-the-world</strong>” 无论选择什么GC算法都会发生stop-the-world ，Stop-the-world 意味着JVM在执行GC时停止应用 当stop-the-world发生时 所有的线程除了GC的相关线程都将停止工作 当GC完成时 中断的任务会继续工作 GC的优化其实就是减少stop-the-world的时间</p><h2 id="分代GC收集"><a href="#分代GC收集" class="headerlink" title="分代GC收集"></a>分代GC收集</h2><p>Java中没有明确指定删除内存的程序代码 一些人使用设置相关对象为null 或者使用System.Gc()方法来明确删除内存 设置为null倒是并无太大所谓 但是使用System.Gc()方法将会大幅影响系统的性能，是不能这样做的（非常感动的是，我并没有在NHN中发现有开发者使用这种代码）</p><p>在Java中 开发者们不能在代码中显示的删除内存，是GC发现不必要（垃圾）的对象并且移出它们在内存的空间，GC是基于以下俩个假说创建的（应该叫推测或者先决条件更准确些 而不是假说）</p><ul><li><p>大多数对象很快的就会无法访问的</p></li><li><p>从老年代到年轻代的引用存在很少</p><p>这个假说被称为<strong>weak generational hypothesis</strong>（不知如何翻译） 所以为了保持这个假说的优势 在HotSpot VM中物理上的分为了俩个 <strong>年轻代</strong>与<strong>老年代</strong></p></li></ul><p><strong>年轻代</strong>：大多数新创建的线程都在这里 由于大多数创建的对象很快就变的无法访问 许多对象都是在年轻代中创建的 然后消失 当对象从这个区域消失时 我们就可以说“<strong>minor GC</strong>”发生了</p><p><strong>老年代</strong>：对象们无法变成无法访问并且存活的从年轻代中复制到这里 它通常比年轻代要大 而且随着大小的增加 年轻大的GC的发生也越来越不频繁 当这些对象在老年代中消失 ，我们就说它是“<strong>major GC”或者是（“Full GC”）</strong>发生了</p><p>让我们看看下面的图<br><a href="https://www.cubrid.org/files/attach/images/1744/745/001/e987ed3f4fbd454cef88e531f4aa18f4.png" target="_blank" rel="noopener"><img src="https://www.cubrid.org/files/attach/images/1744/745/001/e987ed3f4fbd454cef88e531f4aa18f4.png" alt="此处输入图片的描述"></a><br>图 1: GC 区域&amp;数据流<br><strong>常驻代</strong>在图表中被称为“<strong>method area</strong>” 它存储类或者内部的字符串 所以 这些对象绝对不是从老年代中存活下来到这里永久保存的 GC可能会发生在这里 这个地方发生GC也被视为Major GC</p><p>有人可能会想</p><blockquote><p><strong>如果一个老年代的对象需要引用一个年轻代的对象怎么办</strong></p></blockquote><p>在这种情况下 在老年代中有一个名为“<strong>card table</strong>”的东西的 这是一个512字节的块 如果有老年代对象引用年轻代对象 就会在这个表中记录 如果在年轻代发生GC 仅搜索card table来决定这次GC的内容 而不是去查找老年代中所有对象的引用 这个Card table是通过<strong>写屏障</strong>进行管理 这种写屏障是可以让minor GC的性能更好 虽然有一些消耗 但是总体GC的时间变少了<br><a href="https://www.cubrid.org/files/attach/images/1744/745/001/99b983892094b5c6d2fc3736e15da7d1.png" target="_blank" rel="noopener"><img src="https://www.cubrid.org/files/attach/images/1744/745/001/99b983892094b5c6d2fc3736e15da7d1.png" alt="此处输入图片的描述"></a><br>图 2: Card Table 结构</p><h2 id="年轻代中的组成"><a href="#年轻代中的组成" class="headerlink" title="年轻代中的组成"></a>年轻代中的组成</h2><p>要了解GC，我们了解一下年轻代的，这些对象都是第一次创建的对象 ， 年轻代分为三个部分</p><ul><li>一个<strong>Eden</strong>区</li><li>俩个<strong>Survivor</strong> 区</li></ul><p>总共有3个区域，其中俩个是Survivor区 每个空间的执行顺序如下：</p><ol><li>大多数新创建的对象都在Eden区</li><li>在Eden区的一次GC后 存活的对象会将移动到Survivor区</li><li>在Eden区Gc后，这些对象会堆积到Survivor区 并且其他幸存的对象也在这里</li><li>当Survivor区满了之后继续存活的对象会到另外一个Survivor区，然后，已满的Surivor的空间将会改变为没有数据的状态</li></ol><p>5.在这些步骤中幸存的对象已经重复了很多次 会将移动到老年代中</p><p>检查这些步骤可以发现 其中一个Survivor区必须保持为空 如果数据存在于俩个Survivor空间中 或者俩个空间都没有使用 这说明<strong>系统出现了一些错误</strong></p><p>数据通过minor GC处理堆积到老年代的过程如下图所示：<br><a href="https://www.cubrid.org/files/attach/images/1744/745/001/71ca8e88fb8329169399fc9b1cbd16fb.png" target="_blank" rel="noopener"><img src="https://www.cubrid.org/files/attach/images/1744/745/001/71ca8e88fb8329169399fc9b1cbd16fb.png" alt="此处输入图片的描述"></a><br>图 3: GC之前和GC之后</p><p>注意在 HotSpot VM中 有俩种技术来用于更好的内存分配 一种是“<strong>bump-the-pointer</strong>”另外一种是“<strong>TLABs(Thread-Local Allocation Buffers”</strong></p><p><strong>bump-the-pointer</strong>技术是跟踪分配给Eden的最后一个对象 这个对象将位于Eden的顶部 而且之后创建一个对象 它只会检查对象的大小是否适合Eden空间 如果是可以的话 它会将被放到Eden空间中 并且新对象会放到Eden中的顶部 因此 当创建新的对象时 只需要检查最后添加的对象 这样可以更快的进行对象的内存分配 但是 如果考虑在多线程的环境中就会有不同的情况 以线程安全的多线程方式保存对象到Eden空间中 将不可避免的发生锁定 并且性能将会因为锁定争用导致性能下降 在HotSpot VM中 <strong>TLABs</strong>是这种问题的解决方案 它允许不同的线程有自己共享的Eden空间中对应的一小部分 因为每个线程只能访问自己的TLAB 所以即是指针技术也允许没有锁定的内存分配</p><p>快速过了一下年轻代内存的概述 你没有必要一定记住上面俩个技术 你不会不知道他们 但是请你记住 首先创建的对象是在Eden空间中 而且 长时间存活的对象将会从Survivor区移动到老年代</p><h2 id="老年代的GC"><a href="#老年代的GC" class="headerlink" title="老年代的GC"></a>老年代的GC</h2><p>老年代中的数据一满的时候就会执行GC， 执行程序与GC的类型而变化，所以 如果你了解了更多不同的GC类型会更好的了解这个过程</p><ol><li>Serial GC</li><li>Parallel GC</li><li>Parallel Old GC (Parallel Compacting GC)</li><li>Concurrent Mark &amp; Sweep GC (or “CMS”)</li><li>Garbage First (G1) GC</li></ol><p>在这种中 <strong>serial GC是无法在服务器中操作使用的</strong> 当桌面电脑只有一个核心的cpu时就会使用这个GC类型 使用Serial GC会显著降低应用程序的性能</p><p>现在 让我们来看不同的GC类型</p><h3 id="Serial-GC-XX-UseSerialGC"><a href="#Serial-GC-XX-UseSerialGC" class="headerlink" title="Serial GC (-XX:+UseSerialGC)"></a>Serial GC (-XX:+UseSerialGC)</h3><p>年轻代的GC使用在前一段中有相关介绍 这个GC在老年代中使用的算法是“<strong>标记-清扫-紧凑</strong>”</p><ol><li>该算法第一步是标记老年代中的存活对象</li><li>然后 它去前面检测堆然后只留下幸存的对象（清扫）</li><li>在最后一步，它在前面的堆填充对象 使对象可以连续堆积在一起 并将堆分为俩个部分：一个有对象 一个没有对象（紧凑）</li></ol><p>这个Serial GC适合于小内存和Cpu核心数少的情况下</p><h3 id="Parallel-GC-XX-UseParallelGC"><a href="#Parallel-GC-XX-UseParallelGC" class="headerlink" title="Parallel GC (-XX:+UseParallelGC)"></a>Parallel GC (-XX:+UseParallelGC)</h3><p><a href="https://www.cubrid.org/files/attach/images/1744/745/001/38b852430ae0d66651468fc11520627b.png" target="_blank" rel="noopener"><img src="https://www.cubrid.org/files/attach/images/1744/745/001/38b852430ae0d66651468fc11520627b.png" alt="此处输入图片的描述"></a><br>图 4: Serial GC 和 Parallel GC的不同之处<br>在图片中 你可以很清晰的看出Serial 与Parallel的区别 Serial GC只使用一个线程来处理GC ，Parrllel是使用多个线程来处理GC 因此更快 这个GC需要充足的内存与很多的CPU核心 所以又被称为“<strong>throughput GC.</strong>”</p><h3 id="Parallel-Old-GC-XX-UseParallelOldGC"><a href="#Parallel-Old-GC-XX-UseParallelOldGC" class="headerlink" title="Parallel Old GC(-XX:+UseParallelOldGC)"></a>Parallel Old GC(-XX:+UseParallelOldGC)</h3><p>Parallel Old GC是自Jdk5中更新出现的 相比Parallel GC 唯一的区别就是Old GC的GC算法 它有三个步骤 ：标记-总结-压实 总结步骤会单独对之前通过GC操作幸存下来的对象进行分区 从而不同于其他标记-扫描-压实的扫描步骤 它要更复杂一点</p><h3 id="CMS-GC-XX-UseConcMarkSweepGC"><a href="#CMS-GC-XX-UseConcMarkSweepGC" class="headerlink" title="CMS GC (-XX:+UseConcMarkSweepGC)"></a>CMS GC (-XX:+UseConcMarkSweepGC)</h3><p><a href="https://www.cubrid.org/files/attach/images/1744/745/001/10ce40d924aebd3fc7a050dc7bcdba19.png" target="_blank" rel="noopener"><img src="https://www.cubrid.org/files/attach/images/1744/745/001/10ce40d924aebd3fc7a050dc7bcdba19.png" alt="此处输入图片的描述"></a><br>图 5: Serial GC &amp; CMS GC</p><p>从图中可以看出 这个并发 标记-清扫 GC是比我解释的其他GC类型要复杂的多<br>早期的初始化标记很简单 它搜索离类加载器中最近的对象的幸存对象 所以，它的暂停时间会非常的短 在并发标记步骤中，跟踪并检查刚刚确认幸存的对象的相关引用对象 这一步与其他类型的区别在于其他的线程与此同时也会进行处理 。在重新标记步骤中， 检查在并行标记步骤过程中引用的新添加或者停止的对象 最后，在并行清扫过程中 ，垃圾回收发生。垃圾回收器是在其他线程依然工作时进行的 由于GC是因为这种方式进行的 所以GC停止的时间非常的短 这个CMS GC也被称为低延时GC，它常常被用对延时有着至关重要的需要的应用中</p><p>虽然这种GC类型有着stop-the-world时间很少的优点 但是也有以下的缺点</p><ul><li>它比其他GC类型使用更多的CPU和内存</li><li>默认情况下不提供压缩操作</li></ul><p>你需要仔细检查来使用这种类型，另外 如果因为内存碎片太多需要执行压缩 ，那么stop-the-world的时间比其他任何GC类型都要长 你需要检查压缩任务的时间与发生频率</p><h3 id="G1-GC"><a href="#G1-GC" class="headerlink" title="G1 GC"></a>G1 GC</h3><p>最后，让我们来看G1 GC<br><a href="https://www.cubrid.org/files/attach/images/1744/745/001/e295a0637c82f92c23d5cca6e0599300.png" target="_blank" rel="noopener"><img src="https://www.cubrid.org/files/attach/images/1744/745/001/e295a0637c82f92c23d5cca6e0599300.png" alt="此处输入图片的描述"></a><br>图 6: G1 GC布局.</p><p>如果你想要了解G1 GC，请忘记所有有关年轻代与老年代的内容<br>如图所示， 将一个对象分配到一个网格中 然后执行一个GC，然后，当一个区域已满，这些对象分配到另外一个区域，然后执行GC<br>在这个GC类型中，无法找到数据从年轻代的三个空间移动到老年代的步骤（ The steps where the data moves from the three spaces of the young generation to the old generation cannot be found in this GC type. ？？）。这种类型是为了取代CMS GC，长期以来CMS GC引来了很多问题和投诉</p><p>G1 GC的最大优点是性能，它比我们讨论过的所有GC类型速度都要快，但是它在JDK6中，它被称为早期访问，只是用来测试，正式出现则是在JDK7中。在我个人看来，我们需要一个很长的测试（至少一年），NHN才能在实际服务中使用JDK7， 所以说你需要等一等，另外，在JDK6中我听说过几次JVM崩溃的情况 所以说请等待更加稳定的时候再用</p><p>在下一个问题中 我们将谈论GC调优，但是我想在此之前问一些事情，如果在应用中创建的所有对象大小和类型相同，我们公司使用的所有WAS选项都可以使用，但是因为WAS创建的对象大小和寿命因服务而异，随之设备种类也随之变化，换种说法，在某些服务中使用GC选项“A”，并不代表同样的选项对其他服务也会有一样好的效果，所以有必要通过不断的调整监控，为每个设备和每个选项都提供WAS实例，找到每个WAS线程的最佳值。这不是我的个人意见，这是来自JavaOne 2010 Oracle VM组工程师们的讨论</p><p>在本文的问题上，我们只大概的看了一下Java的GC，在下一个问题中，我将介绍如何<strong>监控Java GC状态并且如何调整GC</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;了解Java-GC-（译）&quot;&gt;&lt;a href=&quot;#了解Java-GC-（译）&quot; class=&quot;headerlink&quot; title=&quot;了解Java GC （译）&quot;&gt;&lt;/a&gt;了解Java GC （译）&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;最近在了解Java Gc相关内容 看到一篇不错的入门文章 原文&lt;a href=&quot;https://www.cubrid.org/blog/understanding-java-garbage-collection&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Understanding Java Garbage Collection&lt;/a&gt;&lt;br&gt;本文是“成为一个Java GC专家”系列的第一篇&lt;br&gt;
    
    </summary>
    
    
    
      <category term="JAVA" scheme="http://yoursite.com/tags/JAVA/"/>
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="JVM&amp;&amp;GC" scheme="http://yoursite.com/tags/JVM-GC/"/>
    
  </entry>
  
  <entry>
    <title>Java高并发程序设计读书笔记</title>
    <link href="http://yoursite.com/2017/10/09/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/10/09/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2017-10-08T16:00:00.000Z</published>
    <updated>2019-12-01T10:54:35.959Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-走入并行世界"><a href="#第一章-走入并行世界" class="headerlink" title="第一章 走入并行世界"></a>第一章 走入并行世界</h1><blockquote><p>介绍 没有什么需要记的</p></blockquote><h1 id="第二章-Java并发程序基础"><a href="#第二章-Java并发程序基础" class="headerlink" title="第二章 Java并发程序基础"></a>第二章 Java并发程序基础</h1><a id="more"></a><h2 id="2-1线程的六个基本状态"><a href="#2-1线程的六个基本状态" class="headerlink" title="2.1线程的六个基本状态"></a>2.1线程的六个基本状态</h2><p>NEW RUNNABLE BLOCKED,WAITING,TIMED_WAITING,TERMINATED</p><h2 id="2-2-线程基本操作"><a href="#2-2-线程基本操作" class="headerlink" title="2.2 线程基本操作"></a>2.2 线程基本操作</h2><h3 id="2-2-1-新建线程"><a href="#2-2-1-新建线程" class="headerlink" title="2.2.1 新建线程"></a>2.2.1 新建线程</h3><blockquote><p>一些简单的基本的耗字的就不写了</p></blockquote><p>这里主要是Thread与Runnable区别 以及Start开始线程方法 推荐使用Runnable接口进行编写并发代码 这也是最常见的方式</p><h3 id="2-2-2-终止线程"><a href="#2-2-2-终止线程" class="headerlink" title="2.2.2 终止线程"></a>2.2.2 终止线程</h3><p>stop方法(该方法会立即终止该线程)被废弃了 原因是太过暴力 可能导致数据不一致的问题<br>因为在stop方法会立即结束锁然后立即释放锁 而这些锁是用来维持对象的一致性的 如果写数据写到一半 并强行终止的话 那么对象就会被写坏 另外一个等待该锁的就会读到这个不一致的对象 悲剧就发生了</p><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter2/StopThreadUnsafe.java" target="_blank" rel="noopener">StopThreadUnsafe</a></p><p>那怎么改进呢才合适呢 其实只需要自己决定线程何时退出就可以了<br>增加一个stopMe的volatile字段 再自定义一个是否StopMe的方法</p><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter2/StopThreadSafe.java" target="_blank" rel="noopener">StopThreadSafe</a></p><h3 id="2-2-3-线程中断"><a href="#2-2-3-线程中断" class="headerlink" title="2.2.3 线程中断"></a>2.2.3 线程中断</h3><p>在java中 线程中断是一个重要的线程协作机制 中断就是让目标线程停止运行的意思 实际并非如此 严格的讲 线程中断并不会使线程退出 而是给线程发送一个通知 告知目标线程 有人希望你退出 至于目标线程接到通知如何处理 则完全由目标线程自己决定 如果中断后 无条件退出 就会遇到stop方法的老问题</p><p>与中断线程有关的三个方法</p><ol><li><p>interrupt() //中断线程</p></li><li><p>isInterrupted() //判断是否中断</p></li><li><p>interrupted() //判断是否被中断 并清除当前中断状态</p><p>中断方法乍看与上面的stop标记的手法非常相似 但是中断更为强力 比如 如果在循环体中 出现了类似wait()或者sleep()这样的操作 则只能用中断来识别了</p><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter2/InterruptTest.java" target="_blank" rel="noopener">InterruptTest</a></p><h3 id="2-2-4-等待与通知"><a href="#2-2-4-等待与通知" class="headerlink" title="2.2.4 等待与通知"></a>2.2.4 等待与通知</h3><p>wait方法与notify方法<br>notify是随机的唤醒一个线程 notifyAll会唤醒所有等待的线程</p><p>这俩个方法的关键在一个监听器 在使用wait方法前必须获得object对象的监听器 wait方法执行后 会释放这个监听器 这样做的目的是使得其他等待在object对象上的线程不至于因为第一个线程的休眠而全部无法正常执行 在第二个线程使用notify前也必须获得一个object的监听器 然后获得这个监听器后 notify就会尝试去唤醒一个等待线程 在线程被唤醒后 第一件事是尝试获得这个监听器 而不是执行后续代码 如果暂时无法获得 就等待这个监听器 获得了之后 才能真正的继续执行</p><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter2/SimpleWN.java" target="_blank" rel="noopener">SimpleWN</a></p></li></ol><h3 id="2-2-5-suspend与resume方法"><a href="#2-2-5-suspend与resume方法" class="headerlink" title="2.2.5 suspend与resume方法"></a>2.2.5 suspend与resume方法</h3><p>suspend与resume方法 现在已经是不推荐的操作了 不推荐使用的原因是suspend会导致线程暂停的同时 不会去释放任何锁资源 此时 其他任何线程想要访问被它暂用的锁时 都会被牵连 导致无法正常运行 直到对应的线程上进行了resume操作 被挂起的线程才能继续 从而其他所有阻塞在相关锁上的线程也可以继续执行 但是，如果resume操作意外的在suspend之前的执行了 那么挂起的线程很难有机会继续执行 并且 它占用的锁不会释放 因此可能会导致整个系统工作不正常 而且 对于被挂起的线程 从它的线程状态来看 居然还是Runnable 也会严重影响对系统当前状态的判断</p><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter2/BadSuspend.java" target="_blank" rel="noopener">BadSuspend</a></p><p>如果需要一个可靠的suspend函数的话 可以利用wait与notify方法<br>给出一个标记变量suspendMe 表示当前线程是否被挂起 同时增加了suspendMe和resumeMe俩个方法 分别用于挂起线程与继续执行线程</p><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter2/GoodSuspend.java" target="_blank" rel="noopener">GoodSuspend</a></p><h3 id="2-2-6-等待线程结束-join-与谦让-yield"><a href="#2-2-6-等待线程结束-join-与谦让-yield" class="headerlink" title="2.2.6 等待线程结束(join)与谦让(yield)"></a>2.2.6 等待线程结束(join)与谦让(yield)</h3><p>Join有俩个不同参数的方法</p><ul><li><p>一个是默认的无限等待 一直阻塞当前线程 直到目标线程执行完毕</p></li><li><p>第二个方法给出了一个最大等待时间 如果超过给定时间目标线程还在执行 当前线程也会因为“等不及了”，而继续往下执行</p><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter2/JoinMain.java" target="_blank" rel="noopener">JoinMain</a></p><p>有关Join 补充一点 join的本质是让调用线程wait在当前线程对象实例上<br>下面是JDK中join实现的核心代码片段</p><p>while(isAlive()){<br>wait(0);<br>}</p></li></ul><p>可以看到 它让调用线程在当前线程对象上进行等待 当线程执行完成后 被等待的线程也会在退出前调用notifyAll()通知所有的等待线程继续执行 因此 值得注意的一点是：不要在应用程序中 在Thread的对象实例上使用类似wait()或者notify()等方法 因为这很有可能会影响到系统API的 或者被系统API所影响</p><p>Thread.yield（）方法 它的定义如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static native void yield();</span><br></pre></td></tr></table></figure><p>这是一个静态方法 一旦执行 它会使当前线程让出CPU 但要注意 让出CPU并不表示当前线程不执行了 当前线程在让出CPU后 还会执行CPU资源的争夺 但是是否能够被再次分配到 就不一定了 因此 对Thread.yield调用就好像是在说：我已经完成了一些重要的工作 我应该是可以休息一下了 ，可以给其他线程一些工作机会了</p><p>如果你觉得一个线程不是那么重要 或者优先级非常低 而且又害怕它会占用太多的CPU资源 那么可以在适当的时候调用Thread.yield() 给予其他重要线程更多的工作机会</p><h2 id="2-3-volatile与Java内存模型-JMM"><a href="#2-3-volatile与Java内存模型-JMM" class="headerlink" title="2.3 volatile与Java内存模型(JMM)"></a>2.3 volatile与Java内存模型(JMM)</h2><p>volatile的语义是 易变的 不稳地的 这也正是使用volatile关键字的语义</p><p>当你使用volatile去声明一个变量时 就等于告诉了虚拟机 这个变量极有可能会被某些程序或者线程修改 为了确保这个变量被修改后 应用程序范围内的所有线程都能够“看到”这个改动，虚拟机就必须采用一些特殊的手段 保证这个变量的可见性等特点</p><p>volatile对保证操作的原子性是有非常大的帮助的 但是 需要注意的是,volatile并不能代替锁 ,它也无法保证一些复合操作的原子性</p><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter2/VolatileAtomicTest.java" target="_blank" rel="noopener">VolatileAtomicTest</a></p><p>volatile也可以保证数据的可见性和有序性</p><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter2/NoVisibility.java" target="_blank" rel="noopener">NoVisibility</a></p><h2 id="2-4分门别类的管理：线程组"><a href="#2-4分门别类的管理：线程组" class="headerlink" title="2.4分门别类的管理：线程组"></a>2.4分门别类的管理：线程组</h2><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter2/ThreadGroupName.java" target="_blank" rel="noopener">ThreadGroupName</a></p><h2 id="2-5-驻守后台：守护线程-Daemon"><a href="#2-5-驻守后台：守护线程-Daemon" class="headerlink" title="2.5 驻守后台：守护线程(Daemon)"></a>2.5 驻守后台：守护线程(Daemon)</h2><p>守护线程是一种特殊的线程 就和它的名字一样 它是系统的守护者 在后台默默地运行一些系统性的服务 比如垃圾回收线程 JIT线程就可以理解为守护线程 与之相对应的就是用户线程 用户线程可以认为是系统的工作线程 它会完成这个程序应该要完成的业务操作 如果用户线程全部结束了 这意味着这个程序实际上无事可做了 守护线程要守护的对象已经不存在 那么整个应用程序就自然应该结束 因此 当一个Java应用内 只有守护线程时 Java虚拟机就会自然退出</p><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter2/DaemonDemo.java" target="_blank" rel="noopener">DaemonDemo</a></p><p>守护线程必须在线程start()之前设置 否则会得到一个IllegalThreadStateException异常 然后程序和线程依然可以运行 只不过被当做了用户线程而已</p><h2 id="2-6-先干重要的事：线程优先级"><a href="#2-6-先干重要的事：线程优先级" class="headerlink" title="2.6 先干重要的事：线程优先级"></a>2.6 先干重要的事：线程优先级</h2><p>Java的线程可以有自己的优先级 优先级高的在竞争线程时会更有优势 更可能抢占资源 当然 这只是一个概率问题 运气不好 也抢不到 这个线程的优先级调度和底层操作系统有密切的关系 在各个平台上表现不一 并且这种优先级产生的后果也可能不容易预测 无法精准控制 因此 在要求严格的场合 还是需要自己在应用层解决线程调度问题</p><p>在Java中使用1-10表示线程优先级 一般可以使用内置的三个静态标量表示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final static int MIN_PRIORITY = 1;</span><br><span class="line"></span><br><span class="line">public final static int NORM_PRIORITY = 5;</span><br><span class="line"></span><br><span class="line">public final static int MAX_PRIORITY = 10;</span><br></pre></td></tr></table></figure><p>数字越高则优先级越大 但有效范围在1-10 高优先级的线程倾向于更快的完成</p><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter2/PriorityDemo.java" target="_blank" rel="noopener">PriorityDemo</a></p><h2 id="2-7-线程安全的概念与synchronized"><a href="#2-7-线程安全的概念与synchronized" class="headerlink" title="2.7 线程安全的概念与synchronized"></a>2.7 线程安全的概念与synchronized</h2><p>volatile不能真正保证线程安全 它只能确保一个线程修改了数据后 其他线程能够看到这个改动 但当俩个线程同时修改某一个数据时 却依然会产生冲突</p><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter2/AccountingVol.java" target="_blank" rel="noopener">AccountingVol</a></p><p>要从根本解决这个问题 我们就必须保证多个线程对i进行操作时完全同步 也就是说 当线程A在写入时 线程B不仅不能写 同时也不能读 因为在线程A写完之前 线程B读取的一定是一个过期数据 Java中 提供了一个重要的关键字synchronized来实现这个功能</p><p>关键字synchronized的作用是实现线程间的同步 它的工作是对同步的代码加锁 使得每一次 只有一个线程进入同步代码块 从而保证线程间的安全性</p><p>关键字synchronized的可以有多种用法 这里做一个简单的整理</p><ul><li>指定加锁对象：对给定对象加锁 进入同步代码前要获得给定对象的锁</li><li>直接作用域实例对象：相当与对当前实例加锁，进入同步代码钱要获得当前实例的锁</li><li>直接作用域静态方法：相当于对当前类加锁 进入同步代码前要获得当前类的锁</li></ul><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter2/AccountingSync.java" target="_blank" rel="noopener">AccountingSync</a></p><p>一种错误的加锁方式</p><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter2/AccountingSyncBad.java" target="_blank" rel="noopener">AccountingSyncBad</a></p><p>除了用于线程同步，确保线程安全外，synchronized还可以保证线程间可见性和有序性 从可见性的角度上讲 synchronized可以完全替代volatile的功能 只是使用上没有volatile方便 就有序性而言 由于synchronized限制的代码都是串行执行的所以不用担心有序性问题</p><h2 id="2-8-程序中的幽灵-隐蔽的错误"><a href="#2-8-程序中的幽灵-隐蔽的错误" class="headerlink" title="2.8 程序中的幽灵:隐蔽的错误"></a>2.8 程序中的幽灵:隐蔽的错误</h2><h3 id="2-8-1-无提示的错误案例"><a href="#2-8-1-无提示的错误案例" class="headerlink" title="2.8.1 无提示的错误案例"></a>2.8.1 无提示的错误案例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int v1=1073741827;</span><br><span class="line">int v2=1473741575;</span><br><span class="line">int ave=(v1+v2)/2;</span><br><span class="line">System.out.println(ave);</span><br></pre></td></tr></table></figure><p>这里就会出现一个错误 这个错误是因为int的溢出问题 这种问题就是无提示的错误案例 这种问题非常难找 不能得到异常与相关的错误日志</p><h3 id="2-8-2-并发下的ArrayList"><a href="#2-8-2-并发下的ArrayList" class="headerlink" title="2.8.2 并发下的ArrayList"></a>2.8.2 并发下的ArrayList</h3><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter2/ArrayListMultiThread.java" target="_blank" rel="noopener">ArrayListMultiThread</a></p><p>这里会出现三种结果</p><ol><li>正常结束 最终大小确实2000000</li><li>抛出一个越界异常 这是因为ArrayList在扩容过程中 内部的一致性被破坏，但没有锁的保护 另一个线程访问到了不一致的内部状态 导致出现了越界问题</li><li>出现了一个非常隐蔽的错误 出现了一个值 比如 1793758<br>这个是由于多线程访问冲突 使得保存容器大小的变量被多线程不正常的访问 同时俩个线程也同时对ArrayList的同一个位置进行赋值导致的 这种问题 很不幸 是没有错误提示的错误 而且 也不一定能复现</li></ol><h3 id="2-8-3-并发下诡异的HashMap"><a href="#2-8-3-并发下诡异的HashMap" class="headerlink" title="2.8.3 并发下诡异的HashMap"></a>2.8.3 并发下诡异的HashMap</h3><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter2/HashMapMultiThread.java" target="_blank" rel="noopener">HashMapMultiThread</a></p><p>这里在Jdk8之前的系统中会出现3个问题</p><ol><li>程序正常结束 结果也正常</li><li>程序正常结束 结果不正常</li><li>程序永远无法结束</li></ol><p>第3个问题在JDK8中被修复了 即使这样 贸然使用HashMap依然会导致内部数据不一致 最简单的解决方案是使用ConcurrentHashMap</p><h3 id="2-8-4-初学者常见问题：错误的加锁"><a href="#2-8-4-初学者常见问题：错误的加锁" class="headerlink" title="2.8.4 初学者常见问题：错误的加锁"></a>2.8.4 初学者常见问题：错误的加锁</h3><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter2/BadLockOnInteger.java" target="_blank" rel="noopener">BadLockOnInteger</a></p><p>这个问题其实就是加错了锁 内部的Integer对象是一个不变对象 每次赋值都是创造一个新的对象 所以换个锁对象就好</p><h1 id="第三章-JDK并发包"><a href="#第三章-JDK并发包" class="headerlink" title="第三章 JDK并发包"></a>第三章 JDK并发包</h1><blockquote><p>这章的难点在于解析并发包下并发容器的源码</p></blockquote><p>其中主要还是ConcurrentLinkedQueue类</p><h2 id="3-1-多线程的团队控制-同步控制"><a href="#3-1-多线程的团队控制-同步控制" class="headerlink" title="3.1 多线程的团队控制:同步控制"></a>3.1 多线程的团队控制:同步控制</h2><h3 id="3-1-1-synchronized的功能扩展-重入锁"><a href="#3-1-1-synchronized的功能扩展-重入锁" class="headerlink" title="3.1.1 synchronized的功能扩展 :重入锁"></a>3.1.1 synchronized的功能扩展 :重入锁</h3><p>重入锁完全替代synchronized关键字 在JDK 5.0早期的版本中 重入锁的性能远远好过synchronized 不过JDK6开始 JDK在synchronized做了大量的优化 使得俩者性能差距不大</p><p>重入锁简单的使用案例入戏</p><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/tree/master/Java高并发程序设计/javaHighConcurrentDesign/chapter3/ReenterLock.java" target="_blank" rel="noopener">ReenterLock</a></p><p>与synchronized相比 重入锁有着显示的操作过程 也是因为这样 重入锁对逻辑控制的灵活性要远远好于synchronized 但值得注意的是,在退出临界区时 必须记得释放锁 否则 其他线程就别想访问临界区了</p><p>为什么要重入锁 因为锁是可以重入 也就是反复进入的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">lock.lock();</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"></span><br><span class="line">try&#123;</span><br><span class="line"></span><br><span class="line">i++</span><br><span class="line"></span><br><span class="line">&#125;finally&#123;</span><br><span class="line"></span><br><span class="line">lock.unlock();</span><br><span class="line"></span><br><span class="line">lock.unlock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下 一个线程连续俩次获得同一把锁 是允许的 如果不允许这么操作的话 那么同一个线程在第二次获得锁时就会死锁 但是需要注意的是 如果同一个线程多次获得锁 那么在释放锁的时候 也必须释放相同次数 如果释放锁的次数多 那么会得到一个IllegalMonitorStateException异常 反之 如果锁释放的次数少了 那么相当于线程还持有这个锁 因此 其他线程也无法进入临界区</p><p>除了上面的灵活性外 重入锁还提供了一些高级功能 比如 重入锁就提供中断处理的能力</p><h4 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h4><p>对于synchronized来说 如果一个线程等待锁 那么结果只有俩种情况 要么继续执行 要么它就是保持等待</p><p>而使用重入锁 则提供了另外一种可能 那就是线程可以被中断 也就是在等待锁的过程中 程序可以根据需要取消对锁的请求。 有些时候 这么做是非常有必要的</p><p>中断正式提供了一套机制 如果一个线程正在等待锁 那么它依旧可以收到一个通知 被告知元素是否再等待 可以停止工作了 这种情况对处理死锁是有一定帮助的</p><p>下面的代码产生了一个死锁 但得益与锁中断 我们可以很轻易的解决这个死锁</p><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/tree/master/Java高并发程序设计/javaHighConcurrentDesign/chapter3/IntLock.java" target="_blank" rel="noopener">IntLock</a></p><p>在这个代码中 统一使用lockInterruptibly()方法</p><p>这是一个可以对中断进行响应的锁申请操作 即在等待锁的过程中 可以响应中断</p><h4 id="锁申请等待限时"><a href="#锁申请等待限时" class="headerlink" title="锁申请等待限时"></a>锁申请等待限时</h4><p>除了等待外部通知 要避免死锁还有另外一种方法 那就是限时等待 给定一个等待时间 让线程自动放弃 这对系统来说是有意义的 我们可以使用tryLock方法进行一次限时的等待</p><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/tree/master/Java高并发程序设计/javaHighConcurrentDesign/chapter3/TimeLock.java" target="_blank" rel="noopener">TimeLock</a></p><p>ReentrantLock.tryLock()方法也可以不带参数直接运行 在这种情况下 当前线程会尝试获得锁 如果锁并未被其他线程占用 则申请锁会成功 并立即返回true 如果锁被其他线程占用 则当前线程不会进行等待 而是立即返回false</p><p>这种模式不会引起线程等待 因此也不会产生死锁</p><p>相关代码请见<a href="https://github.com/SanShanYouJiu/CodeCollection/tree/master/Java高并发程序设计/javaHighConcurrentDesign/chapter3/TryLock.java" target="_blank" rel="noopener">TryLock</a></p><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>公平锁不会产生饥饿 只要你排队 最终还是可以得到资源的 如果我们使用synchronized关键字来实现锁控制 那么产生的锁就是非公平的 而重入锁允许我们队其公平性进行设置</p><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/tree/master/Java高并发程序设计/javaHighConcurrentDesign/chapter3/FairLock.java" target="_blank" rel="noopener">FairLock</a></p><p>公平锁看起来的确非常的优美 但是实现公平锁必然要求系统维护一个有序队列 因此公平锁的实现成本比较高 性能也相对非常低下 因此 默认情况下 锁是非公平的 如果没有特别的需求 也不需要使用公平锁 公平锁和非公平锁在线程调度上也是非常不一样的</p><p>就重入锁的实现来看 主要集中在Java层面 在重入锁的实现中 主要包含3个元素</p><ol><li>原子状态 原子状态使用CAS操作来存储当前所的状态 判断锁是否被别的线程持有</li><li>等待队列 所有没有请求到锁的线程 会进入等待队列进行等待 待有线程释放锁后 系统就能从等待对象唤醒一个线程 继续工作</li><li>阻塞原语pack()和unpack() 用来挂起和恢复线程 没有得到线程的锁会被挂起 有关pack()和unpack的详细介绍 也可以参考阻塞工具类 LockSupport</li></ol><h3 id="3-1-2-重入锁的好搭档-Condition条件"><a href="#3-1-2-重入锁的好搭档-Condition条件" class="headerlink" title="3.1.2 重入锁的好搭档:Condition条件"></a>3.1.2 重入锁的好搭档:Condition条件</h3><p>Condition是与重入锁相关联的 通过Lock接口(重入锁就实现了这一接口)的Condition newCondition()方法可以生成一个与当前重入锁绑定的Condition实例 利用Condition对象 我们就可以让线程在合适的时间等待 或者在某一个特定的时刻得到通知 继续执行</p><p>具体方法查文档‘、吧</p><p>例子如下</p><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter3/ReenterLockCondition.java" target="_blank" rel="noopener">ReenterLockCondition</a></p><p>与Object的wait()和notify()方法一样</p><p>在signal()方法被调用后 一般需要释放相关的锁 谦让给被唤醒的线程 让他可以继续执行 比如本例的31-33行 就释放了重入锁 如果省略了第33行 那么 虽然已经唤醒了线程t1 但是由于它无法重新获得锁 因而也就无法真正的继续执行</p><h3 id="3-1-3-允许多个线程同时访问：信号量"><a href="#3-1-3-允许多个线程同时访问：信号量" class="headerlink" title="3.1.3 允许多个线程同时访问：信号量"></a>3.1.3 允许多个线程同时访问：信号量</h3><p>信号量为多线程提供了更为强大的控制方法 广义上说 信号量是对锁的扩展 无论是内部锁synchronized还是重入锁ReentrantLock 一次都只允许一个线程访问一个资源 ，而信号量却可以指定多个线程 同时访问某一个资源 信号量主要提供以下构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Semaphore(int permist)</span><br><span class="line"></span><br><span class="line">public Semaphore(int permise,boolean fair)  //第二个参数可以指定是否公平</span><br></pre></td></tr></table></figure><p>在构建信号量对象时 必须要指定信号量的准入数 即同时能申请多少个许可 每当线程每次只申请一个许可时 这就相当于指定了同时有多少个线程可以访问某一个资源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void acquire()</span><br><span class="line"></span><br><span class="line">public void acquireUninterruptibly()</span><br><span class="line"></span><br><span class="line">public void  tryAcquire()</span><br><span class="line"></span><br><span class="line">public void  tryAcquire(long timeout,Timeout unit)</span><br><span class="line"></span><br><span class="line">public void  release()</span><br></pre></td></tr></table></figure><p>acquire()方法尝试获得一个准入的许可 若无法获得 则线程会等待 直到有线程释放一个许可 或者当前线程被中断 。acquireUninterruptibly()方法和acquire()方法类似 但是不响应中断 tryAcquire()会尝试获得一个许可 如果成功返回true 失败则是false 它不会进行等待 立即返回</p><p>release()用于线程访问资源结束后 释放一个许可 以使其他等待许可的线程可以选择资源返回</p><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter3/SemaphoreDemo.java" target="_blank" rel="noopener">SemaphoreDemo</a></p><h3 id="3-1-4-ReadWriteLock-读写锁"><a href="#3-1-4-ReadWriteLock-读写锁" class="headerlink" title="3.1.4 ReadWriteLock 读写锁"></a>3.1.4 ReadWriteLock 读写锁</h3><p>ReadWriteLock是JDK5提供的读写分离锁 读写分离锁可以有效的帮助减少锁竞争 以提升系统开销</p><p>如果使用重入锁或者内部锁 所有的读读与读写和写写之间都是要串行操作 由于读操作不会对数据完整性造成破坏 这种等待显然是不合理的 所以读写锁就有了发挥功能的余地</p><p>下表是对写锁的访问约束</p><p>| \ | 读 | 写|</p><p>|:— | :—-: |—:|</p><p>|读 | 非阻塞 | 阻塞|</p><p>| 写 | 阻塞 | 阻塞|</p><ul><li>读 -读不互斥 读读之间不阻塞</li><li>读-写互斥:读阻塞写，写也会阻塞读</li><li>写-写互斥：写写阻塞</li></ul><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter3/ReadWriteLockDemo.java" target="_blank" rel="noopener">ReadWriteLockDemo</a></p><h3 id="3-1-5-倒计时器：CountDownLatch"><a href="#3-1-5-倒计时器：CountDownLatch" class="headerlink" title="3.1.5 倒计时器：CountDownLatch"></a>3.1.5 倒计时器：CountDownLatch</h3><p>这个工具通常用来控制线程等待 它可以让某一个线程等到直到倒计时结束 再开始执行</p><p>CountDownLatch的构造函数接受一个整数作为参数 即当前这个计数器的计数个数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public CountDownLatch(int count)</span><br></pre></td></tr></table></figure><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter3/CountDownLatchDemo.java" target="_blank" rel="noopener">CountDownLatchDemo</a></p><h3 id="3-1-6-循环栅栏-CyclicBarrier"><a href="#3-1-6-循环栅栏-CyclicBarrier" class="headerlink" title="3.1.6 循环栅栏 :CyclicBarrier"></a>3.1.6 循环栅栏 :CyclicBarrier</h3><p>CyclicBarrier是另外一种多线程并发控制实用工具 和CountDownLatch非常类似 它也可以实现线程间的计数等待 但它的功能比CountDownLatch更加复杂且强大</p><p>CyclicBarrier可以理解为循环栅栏 栅栏是一种障碍物 前面的Cyclic意为循环 也就是说这个计数器可以反复使用 比如 假设我们将计数器设置为10 那么凑齐第一批10个线程后 计数器将归零 然后继续接着凑齐下一批的10个线程 这就是循环栅栏内在的含义</p><p>比CountDownLatch略微强大一些 CyclicBarrier可以接受一个参数作为barrierAction 所谓barrierAction就是当计数器一次计数完成后 系统会执行的动作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public CyclicBarrier(int parties,Runnable barrierAction)</span><br></pre></td></tr></table></figure><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter3/CyclicBarrierDemo.java" target="_blank" rel="noopener">CyclicBarrierDemo</a></p><p>这里会抛出俩个异常 一个是InterruptedException 也就是等待中断 线程被中断 这是一个非常通用的异常 第二个异常则是CyclicBarrier的BrokenBarrierException 一旦遇到这个异常 则表示当前的CyclicBarrier已经破损了 可能系统已经没有办法等待所有线程到期了 如果继续等待 可能就是徒劳无功</p><p>这个异常就可以避免其他9个线程进行永久的 无谓的等待</p><h3 id="3-1-7-线程阻塞工具类-LockSupport"><a href="#3-1-7-线程阻塞工具类-LockSupport" class="headerlink" title="3.1.7 线程阻塞工具类:LockSupport"></a>3.1.7 线程阻塞工具类:LockSupport</h3><p>LockSupport是一个非常方便实用的线程阻塞工具，它可以在线程内任意位置上线程让出线程阻塞，和Thread.suspend()相比 它弥补了由于resume()在前发生 导致线程无法继续执行的情况 和Object.wait()相比 它不需要先伙食某发对象的锁 也不会抛出InterruptedException异常</p><p>用LockSupport重写第二章提到的suspend()永久卡死线程的例子</p><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter3/LockSupportDemo.java" target="_blank" rel="noopener">LockSupportDemo</a></p><p>在简单的将原来的suspend()和resume()方法用park()和unpark()方法做了替换 当然也无法保证unpark()方法会发生在park()方法之前 但是 它自始至终都可以正常的结束 不会因为park()方法而导致线程永久性的挂起</p><p>这是因为LockSupport类使用类似信号量的机制。它为每一个线程准备了一个许可，如果许可可用 那么park()方法会立即返回 并且消费这个许可(也就是将许可变为不可用) 如果许可不可用 就会阻塞 而unpark()则会使得一个许可变为可用(但是和信号量不同的是，许可不能累加，你不能拥有超过一个许可 它拥有只有一个)</p><p>这个特点使得：即使unpark()操作发生在park()之前 它也可以使下一层的park()操作立即返回 这也就是上述代码可顺利结束的主要原因</p><p>同时 处于park()挂起状态的显存不会像suspend()那样还给出一个令人费解的Runnable的状态 它会非常明确地给出一个WAITING状态 甚至还会标注是park()引起的</p><p>这使得分析问题时变得格外方便 此外 如果你使用park(Object)函数 还可以为当前线程设置一个阻塞对象 这个阻塞对象会出现在线程Dump中 这样在分析问题时 就更加方便了</p><p>比如 如果我们将上述代码第21行的park()方法改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LockSupport.park(this);</span><br></pre></td></tr></table></figure><p>这样在线程dump中就可以看到类似</p><p>除了有定时阻塞的功能外 LockSupport.park()还能支持中断影响 但是和其他接受中断的函数很不一样,LockSupport.park()不会抛出InterruptedException异常 它只是会默默的返回 但是我们可以从Thread.interrupted()等方法获得中断标记</p><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter3/LockSupportIntDemo.java" target="_blank" rel="noopener">LockSupportIntDemo</a></p><h2 id="3-2-线程复用：线程池"><a href="#3-2-线程复用：线程池" class="headerlink" title="3.2 线程复用：线程池"></a>3.2 线程复用：线程池</h2><p>多线程的软件设计方法确实可以最大限度的发挥现代多核处理器的计算能力 提高生产系统的吞吐量和性能 但是 若不加控制和管理的随意使用线程 对系统的性能反而会产生不利影响</p><p>首先 虽然与进程相比，线程是一种轻量级的工具。但其创建和关闭依然需要花费时间 如果每一个小的任务都创建一个线程，很有可能出现创建和销毁线程所占用的时间大于该线程真实工作使所消耗时间的情况 反而会得不偿失</p><p>其次 线程本身也是要占用内存空间 大量的线程会强占宝贵的内存资源 如果处理不当 可能会导致Out of Memory异常 即便没有 大量的线程回收也给GC代理很大的压力 延长GC的停顿时间</p><p>因此 对线程的使用必须掌握一个度 在有限的范围内 增加线程的数量可以明显提高系统的吞吐量 但一旦超出了这个范围 大量的线程只会拖垮应用系统 因此 在生成环境中使用线程 必须对其加以控制和管理</p><h3 id="3-2-1-什么是线程池"><a href="#3-2-1-什么是线程池" class="headerlink" title="3.2.1 什么是线程池"></a>3.2.1 什么是线程池</h3><blockquote><p>想仔细了解的查百科吧</p></blockquote><p>对创建的线程进行复用</p><h3 id="3-2-2-不要重复发明轮子：JDK对线程池的支持"><a href="#3-2-2-不要重复发明轮子：JDK对线程池的支持" class="headerlink" title="3.2.2 不要重复发明轮子：JDK对线程池的支持"></a>3.2.2 不要重复发明轮子：JDK对线程池的支持</h3><p>为了更好的控制多线程 JDK提供了一套Executor框架 帮助开发人员有效地进行线程控制 其本质就是一个多线程</p><p><a href="http://images2015.cnblogs.com/blog/453361/201601/453361-20160125021323270-912734702.png" target="_blank" rel="noopener"><img src="http://images2015.cnblogs.com/blog/453361/201601/453361-20160125021323270-912734702.png" alt="此处输入图片的描述"></a></p><p>以上成员均在java.util.concurrent包中 是JDK并发包的核心类 其中ThreadPoolExecutor类表示一个线程池 Executors类则扮演着线程池工厂的角色 通过Executors可以取得一个拥有特定功能的线程池 从UML图中可知 ThreadPoolExecutor类实现了Executor接口 因此通过这个接口 任何Runnable的对象都可以被ThreadPoolExecutor线程池调度</p><ul><li><p>Executor 执行器接口，该接口定义执行Runnable任务的方式。</p></li><li><p>ExecutorService 该接口定义提供对Executor的服务。</p></li><li><p>ScheduledExecutorService 定时调度接口。</p></li><li><p>AbstractExecutorService 执行框架抽象类。</p></li><li><p>ThreadPoolExecutor JDK中线程池的具体实现。</p></li><li><p>Executors 线程池工厂类</p></li></ul><p>Executor框架提供了各种类型的线程池 主要有以下工厂方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads)</span><br><span class="line"></span><br><span class="line">public static ExecutorService newSingleThreadExecutor()</span><br><span class="line"></span><br><span class="line">public static ExecutorService newCachedThreadPool()</span><br><span class="line"></span><br><span class="line">public static ScheduledExecutorService newSingleThreadScheduleExecutor()</span><br><span class="line"></span><br><span class="line">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)</span><br></pre></td></tr></table></figure><p>以上工厂方法分别返回具有不同工作特性的线程池</p><ul><li>newFixedThreadPool()方法 该方法返回一个固定线程数量的线程池 该线程池中的线程数量始终不变 有新任务 若有空线程 就用 没有空线程 这个新任务就放到一个任务队列 等有线程空闲去处理任务队列的任务</li><li>newSingleThreadExecutor()方法：该方法返回一个只有一个线程的线程池 若多就放任务队列 一个个按顺序来</li><li>newCacheThreadPool()方法：该方法返回一个可根据实际情况调整线程数量的线程池 线程池的线程数量不确定 但若有空闲线程可以复用 则会优先使用可复用的线程 若所有线程均在工作 又有新的任务提交 则会创建新的线程处理任务 所有线程在当前任务执行完毕后 将返回线程池进行复用</li><li>newSingleThreadScheduledExecutor()方法：该方法返回一个ScheduledExecutorService对象 线程池大小为1 ScheduledExecutorService接口在ExecutorService接口之上扩展了在给定时间执行某任务的功能</li><li>newScheduledThreadPool()方法：该方法也返回一个ScheduledExecutorService对象 但该线程池也可以指定线程数量</li></ul><p><strong>固定大小的线程池</strong></p><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter3/ThreadPoolDemo.java" target="_blank" rel="noopener">ThreadPoolDemo</a></p><p><strong>计划任务</strong></p><p>另外一个值得注意的是newScheduledThreadPool()方法 它返回一个ScheduleExecutorService对象 可以根据时间需要对现场进行调度 它的一些主要方法如下</p><ul><li><p>public ScheduledFuture&lt;?&gt; schedule(Runnable command,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long delay, TimeUnit unit);</span><br></pre></td></tr></table></figure></li><li><p>public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">long initialDelay,</span><br><span class="line"></span><br><span class="line">long period,</span><br><span class="line"></span><br><span class="line">TimeUnit unit);</span><br></pre></td></tr></table></figure></li><li><p>public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">long initialDelay,</span><br><span class="line"></span><br><span class="line">long delay,</span><br><span class="line"></span><br><span class="line">TimeUnit unit);</span><br></pre></td></tr></table></figure></li></ul><p>与其他几个线程池不同 ScheduledExecutorService并不一定会立即安排执行任务 它其实是起到了计划任务的作用 它会在指定的时间 对任务进行调度</p><p>方法schedule()会在给定时间 对任务进行一次调度 方法scheduleAtFixedRate()和scheduleWithFixedDelay()会对任务进行周期性的调度 但是俩者有一点区别</p><p>对于FixedRate方式来说 任务调度的频率是一定的 它是以上一个次任务开始执行时间为起点 之后的period时间 调度下一次任务 而FixDelay则在上一个任务结束后 再经过delay时间进行任务调度 这样说可能会比较模糊</p><p>FixRate是隔多长时间周期执行是包括内部代码的运行时间 而FixDelay则是不包括内部代码的运行时间 而是隔多长时间运行一次</p><p>具体的话看官方文档吧 以及下面的例子</p><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter3/ScheduledExecutorServiceDemo.java" target="_blank" rel="noopener">ScheduledExecutorServiceDemo</a></p><p>这里有一个有意思的地方 如果任务的执行时间超过调度时间 会发生什么情况呢？比如 这里调度是每隔2秒 如果任务执行8秒 会出现什么情况呢 这种周期太短的情况 那么任务就会在上一个任务结束后 立即被调用 可以想象 如果用FixDelay就会变成10秒了</p><p>另外一个值得注意的问题 调度程序实际上并不保证任务会无限期的持续调用 如果任务本身抛出了异常 那么后续所有执行都会中断 因此 如果你想让你的任务持续稳定的执行 那么做好异常处理就非常重要了 否则 你很有可能观察到你的调度器无疾而终</p><blockquote><p>注意 如果任务遇到异常 那么后续的所有子任务都会停止调度 因此 必须保证异常被及时处理 为周期性任务的稳定调度提供条件</p></blockquote><h3 id="3-2-3-刨根究底：核心线程池的内部实现"><a href="#3-2-3-刨根究底：核心线程池的内部实现" class="headerlink" title="3.2.3 刨根究底：核心线程池的内部实现"></a>3.2.3 刨根究底：核心线程池的内部实现</h3><blockquote><p>这个太麻烦就不写多了 就写一些我认为关键的地方</p></blockquote><p>无论是newFixedThreadPool()方法 newSingleThreadExecutor()方法还是newCachedThreadPool()方法 虽然看起来创建的线程有着完全不同的功能特点 但其内部实现均使用了ThreadPoolExecutor实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line"></span><br><span class="line">                             int maximumPoolSize,</span><br><span class="line"></span><br><span class="line">                             long keepAliveTime,</span><br><span class="line"></span><br><span class="line">                             TimeUnit unit,</span><br><span class="line"></span><br><span class="line">                             BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line"></span><br><span class="line">                             ThreadFactory threadFactory,</span><br><span class="line"></span><br><span class="line">                             RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure><p>函数的参数含义如下</p><ul><li>corePoolSize：指定了线程池中的线程数量</li><li>maximumPoolSize：指定了线程池中的最大线程数量</li><li>keepAliveTime：当线程池数量超过corePoolSize时 多余的空闲线程的存活时间 即 超过corePoolSize的空闲线程 在多长时间内 会被销毁</li><li>unit：keepAliveTime的单位</li><li>workQueue:任务队列，被条件但尚未被执行的任务</li><li>threadFactory：线程工厂 用于创建线程 一般使用默认的即可</li><li>handler：拒绝策略 当任务太多来不及处理 如何拒绝服务</li></ul><p>上述参数中 只有workQueue和handler需要进行详细说明</p><p>参数workQueue是指提交单未执行的任务队列 它是一个BlockingQueue接口的对象 仅用于存放Runnable对象 根据功能介绍 在ThreadPoolExecutor的构造函数中可使用以下几种BlockingQueue</p><ul><li>直接提交的队列:SynchronousQueue</li><li>有界的任务队列：ArrayBlockingQueue</li><li>无界的任务队列：LinkedBlockingQueue</li><li>优先任务队列：PriorityBlockingQueue</li></ul><h3 id="3-2-4-超负载了怎么办：拒绝策略"><a href="#3-2-4-超负载了怎么办：拒绝策略" class="headerlink" title="3.2.4 超负载了怎么办：拒绝策略"></a>3.2.4 超负载了怎么办：拒绝策略</h3><ul><li>AbortPolicy策略：该策略会直接抛出异常 阻止系统正常工作</li><li>CallerRunsPolicy策略：只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能会急剧下降</li><li>DiscardOledestPolicy策略：该策略将丢弃最老的一个请求，也就是即将被执行了的一个任务 并尝试再次提交当前任务</li><li>DiscardPolicy策略：该策略默默地丢弃无法处理的任务，不予任何处理 如果允许任务丢失 我觉得这可能是最好的一种方案了吧</li></ul><p>以上内置的策略均实现了RejectedExecutionHandler接口 若以上策略仍无法满足实际应用需要，完全可以自己扩展RejectedExecutionHandler接口，RejectedExecutionHandler的定义如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void rejectedExecution(Runnable r, ThreadPoolExecutor executor);</span><br></pre></td></tr></table></figure><p>下面的代码简单的演示了自定义线程池和拒绝策略的使用</p><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter3/RejectThreadPoolDemo.java" target="_blank" rel="noopener">RejectThreadPoolDemo</a></p><h3 id="3-2-5-自定义线程创建：ThreadFactory"><a href="#3-2-5-自定义线程创建：ThreadFactory" class="headerlink" title="3.2.5 自定义线程创建：ThreadFactory"></a>3.2.5 自定义线程创建：ThreadFactory</h3><p>ThreadFactory是一个借口 它只有一个方法，用来创建线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread newThread(Runnable r)</span><br></pre></td></tr></table></figure><p>当线程池需要新建线程时 就会调用这个方法</p><p>自定义线程池可以帮助我们做不少事，比如 等我们可以追踪线程池究竟在何时创建了多少线程，也可以自定义线程的名称，组以及优先级等信息，设置可以任性地将所有线程设置为守护线程。总之，使用自定义线程池可以让我们更加自由地设置池中所有线程的状态</p><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter3/ThreadFactoryDemo.java" target="_blank" rel="noopener">ThreadFactoryDemo</a></p><h3 id="3-2-6-我的应用我做主：扩展线程池"><a href="#3-2-6-我的应用我做主：扩展线程池" class="headerlink" title="3.2.6 我的应用我做主：扩展线程池"></a>3.2.6 我的应用我做主：扩展线程池</h3><p>虽然JDK已经帮我们实现了这个稳定的高性能线程池 但如果我们需要对这个线程池做一些扩展 比如 我们想监控每个任务的开始和结束时间 或者其他一些自定义的增强功能 这个就可以通过ThreadPoolExecutor扩展的功能来实现 它提供了beforeExecutor(),afterExecute()和terminated()三个接口对线程池进行控制</p><p>在默认的ThreadPoolExecutor实现中，提供了空的beforeExecute()和afterExecute()实现，在实际应用中。可以对其扩展来实现对线程池运行状态的跟踪 输出一些有用的调试信息， 以帮助系统故障诊断，这对多线程程序输出错误排查是很有帮助的</p><p>下面有个例子</p><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter3/ExThreadPool.java" target="_blank" rel="noopener">ExTreadPool</a></p><h3 id="3-2-7-合理的选择：优化线程池线程数量"><a href="#3-2-7-合理的选择：优化线程池线程数量" class="headerlink" title="3.2.7 合理的选择：优化线程池线程数量"></a>3.2.7 合理的选择：优化线程池线程数量</h3><p>线程池的大小对系统的性能有一定影响 过大或者过小的线程数量都无法发挥最优的性能 但是线程池大小的确定也不需要做的非常精准 因为只要避免极大和极小俩种情况 线程池的带下对系统的性能并不会影响太大 ，一般来说 确定线程池的大小需要考虑CPU数量 内存大小等因素 在《Java Concurrency in Practice》 一书中给出了一个估算线程池大小的经验公式</p><p>$$Ncpu=Cpu的数量$$</p><p>$$Ucpu=目标CPU的使用率,0&lt;=Ucpu&lt;=1$$</p><p>$$W/C=等待时间与计算时间的比率$$</p><p>在Java中 可以通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().availableProcessors()</span><br></pre></td></tr></table></figure><p>取得可用的CPU数量</p><h3 id="3-2-8-堆栈去哪里了：在线程池中寻找堆栈"><a href="#3-2-8-堆栈去哪里了：在线程池中寻找堆栈" class="headerlink" title="3.2.8 堆栈去哪里了：在线程池中寻找堆栈"></a>3.2.8 堆栈去哪里了：在线程池中寻找堆栈</h3><p>先看一个简单的错误案例</p><p>相关代码请见DivTask</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class DivTask implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    int a,b;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public DivTask(int a, int b) &#123;</span><br><span class="line"></span><br><span class="line">        this.a=a;</span><br><span class="line"></span><br><span class="line">        this.b=b;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line"></span><br><span class="line">        double re = a / b;</span><br><span class="line"></span><br><span class="line">        System.out.println(re);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果程序运行了这个任务，那么我们期望它可以打印出给定俩个数的商。现在我们构造几个这样的任务 希望程序可以为我们计算一组给定数组的商</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor pools = new TraceThreadPoolExecutor(0, Integer.MAX_VALUE, 0L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line"></span><br><span class="line">            pools.submit(new DivTask(100, i));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>上述代码将DivTask提交到线程池 从这个for循环来看 我们应该会得到5个结果分别是100除以给定的i后的商 但如果真的运行程序 就发现全部结果是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">33.0</span><br><span class="line"></span><br><span class="line">50.0</span><br><span class="line"></span><br><span class="line">100.0</span><br><span class="line"></span><br><span class="line">25.0</span><br></pre></td></tr></table></figure><p>只有4个输出 缺少了一个值 这个缺少的值很有可能是由于除以0导致的</p><p>因此 使用线程池虽然是件好事 但是还得处处留意这些“坑” 线程池很有可能会“吃”掉程序抛出的异常 导致我们对程序的错误一无所知</p><p>向线程池讨回异常堆栈（异常堆栈是非常重要的 类似水手的指南针）</p><ul><li>一种最简单的方法，就是放弃submit()，改用execute()</li><li>另外一种用Future对象进行接收 <code>Futere re =pools.submit(new DivTask(100,i));re.get();</code></li></ul><p>上面两种方法都可以得到部分堆栈信息</p><p>注意 是部分 这是因为从这俩个异常堆栈中我们只能知道异常是在哪里抛出的 但是我们还希望得到另外一个更重要的信息 那就是这个任务到底是在哪里提交的？而任务的具体提交位置已经被线程池完全淹没了</p><p>解决方法就是我们扩展自己的ThreadPoolExecutor线程池 在它调度任务之前 先保存一下提交任务线程的堆栈信息</p><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter3/TraceThreadPoolExecutor.java" target="_blank" rel="noopener">TraceThreadPoolExecutor</a></p><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter3/DivTask.java" target="_blank" rel="noopener">DivTask</a></p><h3 id="3-2-9-分而治之：Fork-Join框架"><a href="#3-2-9-分而治之：Fork-Join框架" class="headerlink" title="3.2.9 分而治之：Fork/Join框架"></a>3.2.9 分而治之：Fork/Join框架</h3><p>“分而治之”这是一个非常有效的处理大量的数据的方法 也是一个归并排序的实现思想 注明的MapReduce也是采取了分而治之的思想</p><p>Fork一词原始含义是吃饭用的叉子 ，也有分叉的意思。在Linux平台中 fork()函数用来创建子进程</p><p>使得系统进程可以多一个执行分支。在Java中也沿用了类似的命名方式</p><p>而Join()的含义在之前的章节已经介绍 这里也是相同的意思 表示等待 也就是使用fork()后系统多了一个执行分支（线程）,所以需要等待这个执行分支执行完毕 才有可能得到最终的结果 因此join()就表示等待</p><p>在实际使用中 如果毫无顾忌使用fork()开启线程进行处理 那么很有可能导致系统开启过多的线程而严重影响性能 所以 JDK中 给出一个ForkJoinPool线程池 对于fork()方法并不急着开启线程 而是提交给ForkJoinPool线程池进行处理 以节省系统资源</p><p>由于线程池的优化，提交的任务和线程数量并不是一对一的关系。在绝大多数情况下，一个物理线程时间上是需要出来多个逻辑任务的 因此 每个线程必然需要拥有一个任务队列。因此 在实际过程中 会遇到一种情况 线程A已经处理完自己的任务了 但是线程B还有一堆没有处理 于是A就可以去帮助B 从线程B的任务队列拿出一个任务过了处理 尽可能达到平衡</p><blockquote><p>一个值得的地方是 当线程试图帮助别人时 总是从任务队列的底部开始拿数据，而线程视图执行自己的任务时，则是从相反的顶部开始拿 因此这种行为也十分有利于避免数据竞争</p></blockquote><p>ForkJoinPool的一个重要接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</span><br></pre></td></tr></table></figure><p>你可以向ForkJoinPool线程池提交一个ForkJoinTask任务 所谓ForkJoinTask任务就是支持fork()分析以及join()等待的任务 ForkJoinTask有俩个重要的子类，RecursiveAction和RecursiveTask。它们分别表示没有返回值的任务和可以携带返回值的任务</p><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter3/CountTask.java" target="_blank" rel="noopener">CountTask</a></p><p>此外,ForkJoin线程池使用了一个无锁的栈来管理空闲线程 如果一个工作线程暂时取不到可用的任务 则可能会挂起 挂起的线程将会被压入线程池维护的栈中 待将来有任务可用时 再从栈中唤醒这些线程</p><h2 id="3-3-不要重复的发明轮子：JDK的并发容器"><a href="#3-3-不要重复的发明轮子：JDK的并发容器" class="headerlink" title="3.3 不要重复的发明轮子：JDK的并发容器"></a>3.3 不要重复的发明轮子：JDK的并发容器</h2><h3 id="3-3-1-超好用的工具类：并发集合简介"><a href="#3-3-1-超好用的工具类：并发集合简介" class="headerlink" title="3.3.1 超好用的工具类：并发集合简介"></a>3.3.1 超好用的工具类：并发集合简介</h3><p>JDK提供的这些容器大部分在java.util.concurrent包中</p><ul><li>ConcurrentHashMap:这是一个高效的并发HashMap 可以理解为一个线程安全的HashMap</li><li>CopyOnWriteArrayList：这是一个List 从名字看是ArrayList一族的 在读多邪少的场合 这个List性能非常好 远远好于Vector</li><li>ConcurrentLinkedQueue：高效的并发队列，使用链表实现 可以看做一个线程安全的LinkedList</li><li>BlockingQueue ：这是一个借口 JDK内部通过链表 数组 等方式实现了这个接口 表示阻塞队列 非常适合用于作为数据共享的通道</li><li>ConcurrentSkipListMap:跳表的实现 这是一个Map 使用跳表的数据结构进行快速查找</li></ul><h3 id="3-3-2-线程安全的HashMap"><a href="#3-3-2-线程安全的HashMap" class="headerlink" title="3.3.2 线程安全的HashMap"></a>3.3.2 线程安全的HashMap</h3><p>让一个线程不安全的HashMap如何变成线程安全的HashMap 一种可行方案就是使用<code>Collections.synchronizedMap()</code>方法包装我们的HashMap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public   Map map = Collections.synchronizedMap(new HashMap&lt;&gt;());</span><br></pre></td></tr></table></figure><p>这个内部实现的方法就是实现一个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line"></span><br><span class="line">          synchronized (mutex) &#123;return m.get(key);&#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>很明显通过一个mutex作为监听对象的来进行锁 从而实现线程安全</p><p>如果并发级别不高 一般也够用 但是 在高并发的环境中 我们也有必要寻求新的解决方案</p><p>一个更加专业的并发HashMap是ConcurrentMap 它位于java.util.concurrent包内 它专门为并发进行性能优化 因此 更加适合多线程的场合</p><h3 id="3-3-3-有关List的线程安全"><a href="#3-3-3-有关List的线程安全" class="headerlink" title="3.3.3 有关List的线程安全"></a>3.3.3 有关List的线程安全</h3><p>队列 链表也是极其常用 几乎所有的应用程序都会与之相关 在Java中 ArrayList与Vector都是使用数组作为其内部实现 俩者最大的不同在于Vector是线程安全的 而ArrayList不是</p><h3 id="3-3-4-高效读写的队列：深度剖析ConcurrentLinkedQueue"><a href="#3-3-4-高效读写的队列：深度剖析ConcurrentLinkedQueue" class="headerlink" title="3.3.4 高效读写的队列：深度剖析ConcurrentLinkedQueue"></a>3.3.4 高效读写的队列：深度剖析ConcurrentLinkedQueue</h3><p>队列Queue也是常用的数据结构之一 在JDK中提供了一个ConcurrentLinkedQueue类用来实现高并发的队列</p><p>ConcurrentLinkedQueue应该算是高并发环境中性能最好的队列就可以了 它之所以有很好的性能 是因为内部复杂的实现</p><blockquote><p>这里需要无锁操作的一些知识</p></blockquote><p>ConcurrentLinkedQueue内部定义结点Node</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    volatile E item;</span><br><span class="line"></span><br><span class="line">    volatile Node&lt;E&gt; next;</span><br></pre></td></tr></table></figure><p>item用来表示目标元素 next字段表示当前Node的下一个元素 这属于数据结构的基础了</p><p>对Node进行操作时 使用了CAS操作(CAS是无锁操作相关的知识)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">boolean casItem(E cmp, E val) &#123;</span><br><span class="line"></span><br><span class="line">        return UNSAFE.compareAndSwapObject(this, itemOffset, cmp, val);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    void lazySetNext(Node&lt;E&gt; val) &#123;</span><br><span class="line"></span><br><span class="line">        UNSAFE.putOrderedObject(this, nextOffset, val);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    boolean casNext(Node&lt;E&gt; cmp, Node&lt;E&gt; val) &#123;</span><br><span class="line"></span><br><span class="line">        return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ConcurrentLinkedQueue有俩个重要的字段 head和tail 分别表示链表的头部和尾部 它们都是Node类型 对于head来说 它永远不会为null 并且通过head以及succ()后继方法一定能完整地遍历整个链表 对于tail来说 它自然应该表示队列的末尾</p><p>但ConcurrentLinkedQueue的内部实现非常的复杂 它允许在运行多个不同的状态 以tail为例 一般来说 我们期望tail总是为链表的末尾 但实际上 tail的更新并不是及时的 而是可能会产生拖延现象 每次更新会跳跃俩个元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public boolean offer(E e) &#123;</span><br><span class="line"></span><br><span class="line">       checkNotNull(e);</span><br><span class="line"></span><br><span class="line">       //创建入队节点</span><br><span class="line"></span><br><span class="line">       final Node&lt;E&gt; newNode = new Node&lt;E&gt;(e);</span><br><span class="line"></span><br><span class="line">      //t为tail节点，p为尾节点，默认相等，采用失败即重试的方式，直到入队成功</span><br><span class="line"></span><br><span class="line">       for (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line"></span><br><span class="line">           //获得p的下一个节点</span><br><span class="line"></span><br><span class="line">           Node&lt;E&gt; q = p.next;</span><br><span class="line"></span><br><span class="line">            // 如果下一个节点是null,也就是p节点就是尾节点</span><br><span class="line"></span><br><span class="line">           if (q == null) &#123;</span><br><span class="line"></span><br><span class="line">               // p是最后一个结点</span><br><span class="line"></span><br><span class="line">               if (p.casNext(null, newNode)) &#123;</span><br><span class="line"></span><br><span class="line">                    //每俩次更新一下tail</span><br><span class="line"></span><br><span class="line">                   if (p != t)  </span><br><span class="line"></span><br><span class="line">                       casTail(t, newNode);   </span><br><span class="line"></span><br><span class="line">                   return true;</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               // CAS竞争失败 再尝试</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">              //遇到哨兵结点 从head开始遍历 也可能是刚初始化</span><br><span class="line"></span><br><span class="line">              //但如果tail被修改 则使用tail(因为tail可能被修改对了)</span><br><span class="line"></span><br><span class="line">           else if (p == q)</span><br><span class="line"></span><br><span class="line">               p = (t != (t = tail)) ? t : head;</span><br><span class="line"></span><br><span class="line">           else</span><br><span class="line"></span><br><span class="line">               // 取下一个结点 或者最后一个结点</span><br><span class="line"></span><br><span class="line">               p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>能看懂就看懂吧 不懂的话看原书就好 这里写起来字太多 就说些关键的</p></blockquote><p>第二个判断p==q的情况 这种情况是遇到了哨兵结点导致的 所谓哨兵结点 就是next指向自己的结点 这种结点没什么价值 主要表示要删除的结点 或者空结点 当遇到哨兵结点时 无法通过next获得后继元素 就直接返回head 从链表头部开始遍历 但一旦发生在执行过程中 tail被其他线程修改的情况 则进行一次“打赌” 使用新的tail作为链表末尾（这样就避免了重新查找tail的开销)</p><p>那么有的人就会对这个语句会不明白了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = (t != (t = tail)) ? t : head;</span><br></pre></td></tr></table></figure><p>这句代码虽然只有一行 首先！=不是原子操作 它是可以被中断的 也就是说 在执行‘！=’时 程序会先拿t的值 再执行t=tail,并取得新的t的值 然后比较这俩个值是否相等 在单线程中 t!=t这种语句显然不会成立 但是在并发环境中 有可能在获得左边t值后，右边的t值就被其他线程修改 这样t!=t就成立 这里就是这种情况 如果在比较过程中 tail被其他线程修改 当它被再次赋值给t时 就会导致等式左边的t和右边的t不同 如果俩个t不同 表示tail在中断被其他线程篡改 这时 我们就可以用新的tail作为链表末尾 这就是这里等式右边的t 但如果tail没有被修改 则返回head 要求从头部开始 重新查找尾部</p><p>下边来看 哨兵结点如何产生的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public E poll() &#123;</span><br><span class="line"></span><br><span class="line">    restartFromHead:</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line"></span><br><span class="line">        for (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line"></span><br><span class="line">            E item = p.item;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            if (item != null &amp;&amp; p.casItem(item, null)) &#123;</span><br><span class="line"></span><br><span class="line">                // Successful CAS is the linearization point</span><br><span class="line"></span><br><span class="line">                // for item to be removed from this queue.</span><br><span class="line"></span><br><span class="line">                if (p != h) // hop two nodes at a time</span><br><span class="line"></span><br><span class="line">                    updateHead(h, ((q = p.next) != null) ? q : p);</span><br><span class="line"></span><br><span class="line">                return item;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            else if ((q = p.next) == null) &#123;</span><br><span class="line"></span><br><span class="line">                updateHead(h, p);</span><br><span class="line"></span><br><span class="line">                return null;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            else if (p == q)</span><br><span class="line"></span><br><span class="line">                continue restartFromHead;</span><br><span class="line"></span><br><span class="line">            else</span><br><span class="line"></span><br><span class="line">                p = q;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里写起来又得很麻烦 推荐还是看原书吧 写一些点 这个代码如果看懂之前的offer看这个应该是比较容易了</p></blockquote><p>首先假设加了一个元素在链表中 当前的head的item是null的 使用直接跳到最后p=q 注意在第二个判断中q=p.next 所以这时候p就是p.next了 那么第二次循环item显然不是null的 那么才会去执行<code>p.casItem(item.null)</code>这条语句 成功了就往下走 p当然不等于链表的head了 所以就更新头 而原有的head就被设置为哨兵了</p><p>这其实也能感觉到CAS操作设计非常复杂 好处是性能提升 但是难度也是一大跨度</p><h3 id="3-3-5-高效读取：不变模式下的CopyOnWriteArrayList"><a href="#3-3-5-高效读取：不变模式下的CopyOnWriteArrayList" class="headerlink" title="3.3.5 高效读取：不变模式下的CopyOnWriteArrayList"></a>3.3.5 高效读取：不变模式下的CopyOnWriteArrayList</h3><p>很多应用场景下 读远远大于写 这也是之前的读写锁说的话</p><p>为了将读取的性能发挥到极致 JDK中提供了CopyOnWriteArrayList类 对它来说 读取完全不用加锁 并且更好的消息是 写入也不会阻塞读操作 只有写入与写入之间需要同步等待</p><p>其实就是在写入操作时 进入一次自我复制 换句话说 当这个List需要修改时 我不修改原有的内容 而是对原有的数据进行一次复制 将修改的内容写入副本中 写完之后 再将修改完的副本替换原来的数据 这样就可以保证写不影响读了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line"></span><br><span class="line">     return get(getArray(), index);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">final Object[] getArray() &#123;</span><br><span class="line"></span><br><span class="line">      return array;</span><br><span class="line"></span><br><span class="line"> &#125;   </span><br><span class="line"></span><br><span class="line">public E get(int index) &#123;</span><br><span class="line"></span><br><span class="line">       return get(getArray(), index);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取代码没有然后同步控制和所操作 理由就是内部数据array不会发生修改 只会被另外一个array替换因此可以保证数据安全</p><p>写入就麻烦了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line"></span><br><span class="line">       final ReentrantLock lock = this.lock;</span><br><span class="line"></span><br><span class="line">       lock.lock();</span><br><span class="line"></span><br><span class="line">       try &#123;</span><br><span class="line"></span><br><span class="line">           Object[] elements = getArray();</span><br><span class="line"></span><br><span class="line">           int len = elements.length;</span><br><span class="line"></span><br><span class="line">           Object[] newElements = Arrays.copyOf(elements, len + 1);</span><br><span class="line"></span><br><span class="line">           newElements[len] = e;</span><br><span class="line"></span><br><span class="line">           setArray(newElements);</span><br><span class="line"></span><br><span class="line">           return true;</span><br><span class="line"></span><br><span class="line">       &#125; finally &#123;</span><br><span class="line"></span><br><span class="line">           lock.unlock();</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>写入操作用锁 当然这个锁仅限于控制写-写的情况 其重点在于 进行了内部元素的玩转复制 因此 会生成一个新的数组newElements 然后 天魂 而且array是volatile变量 会立即发现</p><h3 id="3-3-6-数据共享通道：BlockingQueue"><a href="#3-3-6-数据共享通道：BlockingQueue" class="headerlink" title="3.3.6 数据共享通道：BlockingQueue"></a>3.3.6 数据共享通道：BlockingQueue</h3><p>前面提到 是用ConcurrentQueue作为高性能的队列的</p><p>并发是追求高性能的 但是多线程的开发模式还会引入一个问题 如何进行多个线程间的数据共享呢</p><p>一般来说 我们希望整个系统是松散耦合的</p><p>把这个BlockingQueue当做一个‘意见箱’ 双方都放东西 但是双方解耦 保证系统平滑过渡</p><p>BlockingQueue是一个接口 主要还是在Blocking上 这个意思就是阻塞</p><p>BlockingQueue会让服务线程在队列为空时 进行等待 当有新的消息进入队列后 自动将线程唤醒</p><p>我们主要还是用ArrayBlockingQueue这个实现类来说明</p><p>向队列中压入元素可以使用offer()和put()方法 对于offer方法 如果当期队列已经满了 它就会返回false 如果没有满 则执行正常的入队操作 所以我们不讨论这个方案 关注put方法 put方法也是将元素压入队列末尾 但如果队列满了 它会一直等待 直到队列中有空闲的位置</p><p>从队列中弹出元素可以用poll()方法和take()方法 它们都从队列的头部获得一个元素 不同之处在于 如果队列为空 poll()方法之间返回null,而take()方法会等待 直到队列内有可用元素</p><p>因此put方法和take方法才是提醒Blocking的关键 为了做好等待和通知俩件事 在ArrayBlockingQueue定义了如下字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">final ReentrantLock lock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> private final Condition notEmpty;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> private final Condition notFull;</span><br></pre></td></tr></table></figure><p>当执行take()操作时 如果队列为空 则让当前线程等待在notEmpty上 新元素入队时 则执行一次notEmpty上的通知</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line"></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line"></span><br><span class="line">        while (count == 0)</span><br><span class="line"></span><br><span class="line">            notEmpty.await();</span><br><span class="line"></span><br><span class="line">        return dequeue();</span><br><span class="line"></span><br><span class="line">    &#125; finally &#123;</span><br><span class="line"></span><br><span class="line">        lock.unlock();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里如果为空就等待 等待新元素的插入 唤醒notEmpty</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private void enqueue(E x) &#123;</span><br><span class="line"></span><br><span class="line">     // assert lock.getHoldCount() == 1;</span><br><span class="line"></span><br><span class="line">     // assert items[putIndex] == null;</span><br><span class="line"></span><br><span class="line">     final Object[] items = this.items;</span><br><span class="line"></span><br><span class="line">     items[putIndex] = x;</span><br><span class="line"></span><br><span class="line">     if (++putIndex == items.length)</span><br><span class="line"></span><br><span class="line">         putIndex = 0;</span><br><span class="line"></span><br><span class="line">     count++;</span><br><span class="line"></span><br><span class="line">     notEmpty.signal();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>同理 对Put()操作也一样 当队列满是 需要让压入线程等待</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public void put(E e) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">       checkNotNull(e);</span><br><span class="line"></span><br><span class="line">       final ReentrantLock lock = this.lock;</span><br><span class="line"></span><br><span class="line">       lock.lockInterruptibly();</span><br><span class="line"></span><br><span class="line">       try &#123;</span><br><span class="line"></span><br><span class="line">           while (count == items.length)</span><br><span class="line"></span><br><span class="line">               notFull.await();</span><br><span class="line"></span><br><span class="line">           enqueue(e);</span><br><span class="line"></span><br><span class="line">       &#125; finally &#123;</span><br><span class="line"></span><br><span class="line">           lock.unlock();</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这里如果为空就等待 等待元素的删除 唤醒notFull</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private E dequeue() &#123;</span><br><span class="line"></span><br><span class="line">    // assert lock.getHoldCount() == 1;</span><br><span class="line"></span><br><span class="line">    // assert items[takeIndex] != null;</span><br><span class="line"></span><br><span class="line">    final Object[] items = this.items;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line"></span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line"></span><br><span class="line">    items[takeIndex] = null;</span><br><span class="line"></span><br><span class="line">    if (++takeIndex == items.length)</span><br><span class="line"></span><br><span class="line">        takeIndex = 0;</span><br><span class="line"></span><br><span class="line">    count--;</span><br><span class="line"></span><br><span class="line">    if (itrs != null)</span><br><span class="line"></span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line"></span><br><span class="line">    notFull.signal();</span><br><span class="line"></span><br><span class="line">    return x;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-7-跳表（SkipList）"><a href="#3-3-7-跳表（SkipList）" class="headerlink" title="3.3.7 跳表（SkipList）"></a>3.3.7 跳表（SkipList）</h3><p>跳表是一种可以用来快速查找的数据结构 有点类似于平衡树 它们都可以对元素进行快速的查找 但一个重要的区别是：对平衡树的插入和删除往往很可能导致平衡树进行一次全局的调整 对跳表的插入和删除只需要对整个数据结构的局部进行操作即可 这样带来的好处是：在高并发的情况下 你会需要一个全局锁来保证整个平衡树的线程安全 而对于跳表 你只需要部分锁即可 这样 在高并发的环境下 你就可以拥有更好的性能 而就查询的性能而言 跳表的时间复杂度也是O(log n) 所以在并发数据结构中 JDK使用跳表来实现一个Map</p><p>跳表的另外一个特点是随机算法 跳表的本质是同时维护了多个链表 并且链表是分层的 如下图所示</p><p><a href="http://www.spongeliu.com/wp-content/uploads/2010/09/2.png" target="_blank" rel="noopener"><img src="http://www.spongeliu.com/wp-content/uploads/2010/09/2.png" alt="此处输入图片的描述"></a></p><p>跳表所有的元素都是排序的 查找时也是如图所示 从顶级链表开始找 一旦发现被查找的元素大于当前链表中的取值 就会转入下一层链表继续找 这也就是说 查找的过程是跳跃式的</p><p>因此 很显然 跳表是一种使用空间换时间的算法</p><p>使用链表实现Map和使用哈希算法实现Map的另外一个不同之处是：哈希并不会保存元素的顺序 而跳表所有的元素都排序的 因此在对跳表进行遍历时 你会得到一个有序的结果 所以 如果你的应用需要有序性 那么跳表就是你不二的选择</p><p>跳表的内部结构有几个关键数据结构组成 一个是Node 一个是Index</p><p>Node则就是key value 还有一个next指向下一个Node Index就是索引 内部包装了Node 同时增加了向下引用与向上应用 此外 对于每一层的表头</p><p>还需要记录当前处于哪一层 为此 还需要一个称为HeadIndex的数据结构 表示链表头部的第一个Index 它继承于Inndex</p><h1 id="第四章-锁的优化及注意事项"><a href="#第四章-锁的优化及注意事项" class="headerlink" title="第四章 锁的优化及注意事项"></a>第四章 锁的优化及注意事项</h1><h2 id="4-1-有助于提高“锁”性能的几点建议"><a href="#4-1-有助于提高“锁”性能的几点建议" class="headerlink" title="4.1 有助于提高“锁”性能的几点建议"></a>4.1 有助于提高“锁”性能的几点建议</h2><h3 id="4-1-1-减少锁持有时间"><a href="#4-1-1-减少锁持有时间" class="headerlink" title="4.1.1 减少锁持有时间"></a>4.1.1 减少锁持有时间</h3><p>程序开发应尽可能的减少对某个锁的占用时间 以减少程序互斥的可能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public  synchronized void syncMethod()&#123;</span><br><span class="line">  othercode1();</span><br><span class="line">  mutextMethod();</span><br><span class="line">  othercode2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里假设只有mutextMethod方法是有同步需要的 而othercode1()和othercode2()并不需要同步控制 如果othercode1和othercode2是重量级的方法的话 使用整个个方法做同步 会导致等待线程大量增加 因为一个线程 在进入该方法时获得内部锁 只有在所有任务都执行完后 才会释放锁</p><p>一个较为优化的解决方案是 只在必要时进行同步 这样就能明显减少线程持有锁的时间 提高系统的吞吐量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void syncMethod2()&#123;</span><br><span class="line">    othercode1();</span><br><span class="line">    synchronized(this)&#123;</span><br><span class="line">        mutextMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在改进的代码中 只针对mutextMethod()方法做了同步 锁占用的时间相对较短 因此能有更改的并行度 这种技术手段在JDK的源码包中也可以很容易地找到 比如处理正则表达式的Pattern类</p><blockquote><p>减小锁的持有时间有助于减低锁冲突的可能性 进而提高系统的并发能力</p></blockquote><h3 id="4-1-2-减小锁粒度"><a href="#4-1-2-减小锁粒度" class="headerlink" title="4.1.2 减小锁粒度"></a>4.1.2 减小锁粒度</h3><p>减小锁粒度也是削弱多线程锁竞争的有效手段 这种技术典型的使用场景就是ConcurrentHashMap类的实现 在3.3节中介绍了这个类 但是没有仔细的介绍 这节仔细的介绍一下</p><p>对于HashMap来说 最重要的俩个方法就是get()和put()。一种最自然的方法就是对HashMap加锁 必然可以得到一个线程安全的对象 但是这样做 我们就认为加锁粒度太大了 对于ConcurrentHashMap 它内部进一步细分为若干个小的HashMap 称之为段(SEGMENT) 默认情况下 一个ConcurrentHashMap被进一步细分为16个段</p><p>如果需要在ConcurrentHashMap中增加一个新的表项 并不是将整个HashMap加锁 而是首先根据hashcode得到该表现应该存放到哪个段中 然后对该段加锁 并完成put()操作 只要被加入的表项不存放在同一个段中 则线程间便可以做到真正的并行</p><p>但是 减小锁粒度会引入一个新的问题 即：当系统需要取得全局锁时 其消耗的资源会比较多 仍然以ConcurrentHashMap类为例 虽然其put()方法很好地分离了锁 但是当试图访问ConcurrentHashMap全局信息时 就会需要同时取得所有段的锁方能顺利实施 比如ConcurrentHashMap的size()方法 它将返回ConcurrentHashMap的有效表项的数量 即ConcurrentHashMap的全部有效表项之和 要获取这个信息需要取得所有子段的锁</p><p>事实上 size()方法会先使用无锁的方式求和 如果失败才会尝试加锁的方法 但不管怎么说 在高并发场合ConcurrentHashMap的size()的性能依然要差于同步的HashMap</p><p>因此 只有在类似size()获取全局信息的方法调用并不频繁时 这种减小锁粒度的方法才能真正意义上提高系统吞吐量</p><blockquote><p>ConcurrentHashMap在JDK1.8版本中大规模的重构了 这里的笔记只适用于JDK1.7版本</p></blockquote><blockquote><p>所谓减少锁粒度 就是指减少锁定对象的访问 从而减少锁冲突的可能性 进而提高系统的并发能力</p></blockquote><h3 id="4-1-3-读写分离锁来替换独占锁"><a href="#4-1-3-读写分离锁来替换独占锁" class="headerlink" title="4.1.3 读写分离锁来替换独占锁"></a>4.1.3 读写分离锁来替换独占锁</h3><p>使用ReadWriteLock可以提高系统的性能 使用读写分离锁来替代独占锁是减小锁粒度的一种特殊情况 那么 读写锁则是对系统功能点的分割</p><p>在读多写少的场合 读写锁对系统性能还是很有好处的 因为如果系统在读写数据时均只使用独占锁 那么读操作和写操作间 写操作和写操作间均不能做到真正的并发 并且需要互相等待 而读操作本身不会影响数据的完整性和一致性 因此 理论上讲 在大部分情况下 应该可以运行多线程同时读，读写锁正是实现了这种功能</p><blockquote><p>在读多写少的场合 使用读写锁可以有效提示系统的并发能力</p></blockquote><h3 id="4-1-4-锁分离"><a href="#4-1-4-锁分离" class="headerlink" title="4.1.4 锁分离"></a>4.1.4 锁分离</h3><p>如果将读写锁的思想做进一步的延伸 就是锁分离 读写锁根据读写操作功能的不同进行了有效的锁分离 依据应用程序的功能特点 使用类似的分离思想 也可以对独占锁进行分离 一个典型的案例就是java.util.LinkedBlockingQueue的实现</p><p>在LinkedBlockingQueue的实现中 take()函数和put()函数分别实现了从队列中取得数据和往队列中增加数据的功能 虽然俩个函数都对当前队列进行了修改操作 但由于LinkedBlockingQueue是基于链表的 因此 俩个操作分别作用域队列的前端和尾端 从理论上说 俩者并不冲突</p><p>如果使用独占锁 则要求俩个操作进行时获取当前队列的独占锁 那么take()和put()操作就不可能真正的并发 在运行时 它们会彼此等待对方释放锁资源 在这种情况下 锁竞争会相对比较激烈 从而影响程序在高并发时的性能<br>因此 在JDK的实现中 并没有采用这样的方式 取而代之的是俩把不同的锁 分离了take()和put()操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/** Lock held by take, poll, etc */</span><br><span class="line">    private final ReentrantLock takeLock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    /** Wait queue for waiting takes */</span><br><span class="line">    private final Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line">    /** Lock held by put, offer, etc */</span><br><span class="line">    private final ReentrantLock putLock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    /** Wait queue for waiting puts */</span><br><span class="line">    private final Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure><p>以上代码片段 定义了takeLock和putLock 它们分别在take()操作和put()操作中使用 因此 take()函数和put()函数就此相互独立 它们之间不存在锁竞争关系 只需要在take()和take()间,put()和put()间分别对takeLock和putLock进行竞争 从而 削弱了锁竞争的可能性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">       E x;</span><br><span class="line">       int c = -1;</span><br><span class="line">       final AtomicInteger count = this.count;</span><br><span class="line">       final ReentrantLock takeLock = this.takeLock;</span><br><span class="line">       takeLock.lockInterruptibly(); //不能有俩个线程同时取数据</span><br><span class="line">       try &#123;</span><br><span class="line">           while (count.get() == 0) &#123;//如果当前没有可用数据 一直等待</span><br><span class="line">               notEmpty.await(); //等待 put()操作的通知</span><br><span class="line">           &#125;</span><br><span class="line">           x = dequeue();//取得第一个数据</span><br><span class="line">           c = count.getAndDecrement(); //数量减一 原子操作 因为会和put()函数同时访问count 注意：变量c是count减一前的值 </span><br><span class="line">           if (c &gt; 1)</span><br><span class="line">               notEmpty.signal();//通知其他take()操作</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           takeLock.unlock();//释放锁</span><br><span class="line">       &#125;</span><br><span class="line">       if (c == capacity)</span><br><span class="line">           signalNotFull();//通知put()操作 已有空余空间</span><br><span class="line">       return x;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>函数put()的实现如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void put(E e) throws InterruptedException &#123;</span><br><span class="line">      if (e == null) throw new NullPointerException();</span><br><span class="line">      int c = -1;</span><br><span class="line">      Node&lt;E&gt; node = new Node&lt;E&gt;(e);</span><br><span class="line">      final ReentrantLock putLock = this.putLock;</span><br><span class="line">      final AtomicInteger count = this.count;</span><br><span class="line">      putLock.lockInterruptibly(); //不能有俩个线程同时进行put()</span><br><span class="line">      try &#123;</span><br><span class="line">          while (count.get() == capacity) &#123;//如果队列满了</span><br><span class="line">              notFull.await();//等待</span><br><span class="line">          &#125;</span><br><span class="line">          enqueue(node);//插入数据</span><br><span class="line">          c = count.getAndIncrement();//更新总数 变量c是count加1前的值</span><br><span class="line">          if (c + 1 &lt; capacity)</span><br><span class="line">              notFull.signal();//有足够的空间 通知其他线程</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          putLock.unlock();//释放锁</span><br><span class="line">      &#125;</span><br><span class="line">      if (c == 0)</span><br><span class="line">          signalNotEmpty();//插入成功后 通知take()操作取数据</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>通过takeLock和putLock俩把锁 LinkedBlockingQueue实现了取数据和写数据的分离 使俩者在真正意义上成为可并发的操作</p><h3 id="4-1-5-锁粗化"><a href="#4-1-5-锁粗化" class="headerlink" title="4.1.5 锁粗化"></a>4.1.5 锁粗化</h3><p>通常情况下 为了保证多线程间的有效并发 会要求每个线程持有锁的时间尽量短 即在使用完公共资源后 应该立即释放锁 只有这样 等待在这个锁上的其他线程才能尽早的获得资源执行任务 但是 如果对同一个锁不停的进行请求，同步和释放 其本身也会消耗系统宝贵的资源 反而不利于性能的优化</p><p>为此 虚拟机在遇到一连串连续对同一锁不断进行请求和释放的操作时，便会把所有的锁操作整合成对锁的一次请求 从而减少对锁的请求同步次数 这个操作叫锁的粗化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void demoMethod()&#123;</span><br><span class="line">    synchronized()&#123;</span><br><span class="line">    // do sth</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//做其他不需要的同步的工作 但能很快执行完毕</span><br><span class="line">synchronized(lock)&#123;</span><br><span class="line">    //do sth</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会被整合为如下形式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void demoMethod()&#123;</span><br><span class="line">   //整合成一次锁请求</span><br><span class="line">   synchronized(lock)&#123;</span><br><span class="line">       //do sth</span><br><span class="line">       //做其他不需要的同步的工作 但能很快执行完毕</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在开发过程中 大家也应该有意识地在合理的场合进行锁的粗化 尤其当在循环内请求锁时 以下是一个循环内请求锁的例子 在这种情况下 意味着每次循环都有申请锁和释放锁的操作 但在这种情况下 显然是没有必要的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(int i =0;i&lt;CIRCLE;i++)&#123;</span><br><span class="line">    synchronized(lock)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以 一种更合理的做法应该是在外层只请求一次锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">synchronized(lock)&#123;</span><br><span class="line">for(int i=0;i&lt;CIRCLE;i++)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意 性能优化是根据运行时的真是情况对各个资源点进行权衡折中的过程 锁粗化的思想和减少锁持有时间是相反的 但在不同的场合 它们的效果并不相同 所以大家需要根据实际情况 进行权衡</p></blockquote><h2 id="4-2-Java虚拟机对锁优化所做的努力"><a href="#4-2-Java虚拟机对锁优化所做的努力" class="headerlink" title="4.2 Java虚拟机对锁优化所做的努力"></a>4.2 Java虚拟机对锁优化所做的努力</h2><h3 id="4-2-1-锁偏向"><a href="#4-2-1-锁偏向" class="headerlink" title="4.2.1 锁偏向"></a>4.2.1 锁偏向</h3><p>锁偏向是一种针对加锁操作的优化手段 它的核心思想是：如果一个线程获得了锁 那么锁就进入了偏向模式 当这个线程再次请求锁时 无须再做任何同步操作 这样就节省了大量相关锁申请的操作 从而提高了程序性能 因此 对于几乎没有锁竞争的场合 偏向锁有比较好的优化效果 因为连续多次极有可能是同一个线程请求相同的锁 而对于锁竞争比较激烈的场合 其效果不佳 因为在竞争激烈的场合 最有可能的情况是每次都是不同的线程来请求相同的锁 这样偏向模式会失效 因此还不如不启用偏向锁 使用Java虚拟机参数-XX:+UseBiasedLocking可以开启偏向锁</p><h3 id="4-2-2-轻量级锁"><a href="#4-2-2-轻量级锁" class="headerlink" title="4.2.2 轻量级锁"></a>4.2.2 轻量级锁</h3><p>如果偏向锁失败 虚拟机并不会立即挂起线程 它还会使用一种称之为轻量级锁的优化手段,轻量级锁的操作也很轻便 它只是简单的将对象头部作为指针 指向持有锁的线程堆栈的内部 来判断一个线程是否持有对象锁 如果线程获得轻量级锁成功 则可以顺利进入临界区 如果轻量级锁加锁失败 则表示其他线程抢先争夺到了锁 那么当前线程的锁请求就会膨胀为重量级锁</p><p><a href="http://www.cnblogs.com/paddix/p/5405678.html" target="_blank" rel="noopener">偏向锁与轻量锁的讲解</a></p><h3 id="4-2-3-自旋锁"><a href="#4-2-3-自旋锁" class="headerlink" title="4.2.3 自旋锁"></a>4.2.3 自旋锁</h3><p>锁膨胀后，虚拟机为了避免线程真实地在操作系统层面挂起 虚拟机还会在做最后的努力<br>—自旋锁 由于当前线程暂时无法获得锁 但是什么时候可以获得锁是一个未知数<br>也许在几个CPU时钟周期后 就可以得到锁 如果这样 简单粗暴地挂起线程可能是一种得不偿失的操作 因此 系统会进行一次赌注：它会加上在不久的将来 线程可以得到这把锁 因此 虚拟机会让当前线程做几个空循环（这也是自旋的含义）在经过若干次循环后 如果可以得到锁 那么就顺利进入临界区 如果还不能获得锁 才会真实地将线程在操作系统层面挂起</p><h3 id="4-2-4-锁消除"><a href="#4-2-4-锁消除" class="headerlink" title="4.2.4 锁消除"></a>4.2.4 锁消除</h3><p>锁消除是一种更彻底的锁优化 Java虚拟机在JIT编译时 通过对运行上下文的扫描 去除不可能存在共享资源竞争的锁 通过锁消除 可以节省毫无意义的请求锁时间</p><p>如果不可能存在竞争 为什么程序还要加上锁呢 这是因为在Java软件开发的过程中 我们必然会使用一些JDK的内置API，比如StringBuffer，Vector等 你在使用这些类的时候 也许根本不会考虑这些对象到底内部是如何实现的 比如 你很有可能在一个不可能存在并发竞争的场合使用Vector 而众所周知 Vector内部使用了synchronized请求锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public String[] createStrings()&#123;</span><br><span class="line"> Vector&lt;String&gt; v =new Vecotr&lt;String&gt;();</span><br><span class="line"> for(int i=0;i&lt;100;i++)&#123;</span><br><span class="line">  v.add(Integer.toString(i);</span><br><span class="line"> &#125;</span><br><span class="line"> return v.toArray(new String[]&#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如在这种情况下 Vector的实例对象v只是一个局部变量 局部变量是在栈上的 属于线程私有的数据 因此不可能被其他线程访问 所以 在这种情况下 Vector内部所有加锁同步都是没有必要的 如果虚拟机检测到这种情况 就会将这些无用的操作去除</p><p>锁消除涉及的一项关键技术为逃逸分析 所谓逃逸分析就是观察某一个变量是否会逃出某一个作用域<br>在本例中 变量v显然没有逃出createStrings()函数之外 以此为基础 虚拟机才可以大胆地将v内部的加锁操作去除 如果createStrings()返回的不是String数组 而是v本身 那么就认为变量v逃逸出了当前函数 也就是说v有可能被其他线程访问 如果是这样 虚拟机就不能消除v中的锁操作</p><p>逃逸分析必须要在-server模型下进行 可以使用-XX:DoEscapeAnalysis参数打开逃逸分析 使用-XX:+EliminateLocks参数可以打开锁消除</p><h2 id="4-3-人手一只笔：ThreadLocal"><a href="#4-3-人手一只笔：ThreadLocal" class="headerlink" title="4.3 人手一只笔：ThreadLocal"></a>4.3 人手一只笔：ThreadLocal</h2><p>除了控制资源的访问外 我们还可以通过增加资源来保证所有对象的线程安全</p><h3 id="4-3-1-ThreadLocal的简单实用"><a href="#4-3-1-ThreadLocal的简单实用" class="headerlink" title="4.3.1 ThreadLocal的简单实用"></a>4.3.1 ThreadLocal的简单实用</h3><p>从ThreadLocal的名字上可以看到 这是一个线程的局部变量 也就是说只有当前线程可以访问 既然是只有当前线程可以访问的数据 自然是线程安全的</p><p>下面看一个简单的示例<br>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter4/ThreadLocalDemo.java" target="_blank" rel="noopener">ThreadLocalDemo</a></p><p>从这里也可以看到 为每一个线程人手分配一个对象的工作并不是由ThreadLocal来完成的 而是需要在应用层面保证的 如果在应用上为每一个线程分配了相同的对象实例 那么ThreadLocal也不能保证线程安全 这点也需要大家注意</p><blockquote><p>注意：为每一个线程分配不同的对象 需要在应用层面保证 ThreadLocal只是起到了简单的容器作用</p></blockquote><h3 id="4-3-2-ThreadLocal的实现原理"><a href="#4-3-2-ThreadLocal的实现原理" class="headerlink" title="4.3.2 ThreadLocal的实现原理"></a>4.3.2 ThreadLocal的实现原理</h3><p>我们需要关注的 自然是ThreadLocal的set()方法和get()方法 从set()方法说起</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">      Thread t = Thread.currentThread();</span><br><span class="line">      ThreadLocalMap map = getMap(t);</span><br><span class="line">      if (map != null)</span><br><span class="line">          map.set(this, value);</span><br><span class="line">      else</span><br><span class="line">          createMap(t, value);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以看到这个方法set时 先获得当前线程对象 然后通过getMap()拿到线程的ThreadLocalMap，并将值设入ThreadLocalMap 而ThreadLocalMap就理解为一个Map就好 但是它是定义在Thread内部的成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.ThreadlocalMap threadLocals =null;</span><br></pre></td></tr></table></figure><p>而设置到ThreadLocal中的数据 也正是写入了threadLocals这个Map 其中 key为ThreadLocal当前对象 value就是我们需要的值 而threadLocals本身就保存了当前所在线程的所有“局部变量”，也就是一个ThreadLocal变量的集合</p><p>在进行get()操作时 自然就是将这个Map中的数据拿出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">     public T get() &#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        if (map != null) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class="line">            if (e != null) &#123;</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return setInitialValue();</span><br><span class="line">    &#125;</span><br><span class="line">​```   </span><br><span class="line"> </span><br><span class="line">首先 get()方法也是先取得当前线程的ThreadLocalMap对象 然后 通过将自己做为key取得内部的实际数据</span><br><span class="line">在了解ThreadLocal的内部实现后 我们自然会引出一个问题 那就是这些变量是维护在Thread类内部的（ThreadLocalMap定义所在类)，这也意味着只有线程不退出 对象的引用将一直存在</span><br><span class="line">当线程退出时 Thread类会进行一些清理工作 其中就包括清理ThreadLocalMap </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​```java</span><br><span class="line">    /**在线程退出前 由系统回调 进行资源清理</span><br><span class="line">    /</span><br><span class="line">     private void exit() &#123;</span><br><span class="line">            if (group != null) &#123;</span><br><span class="line">                group.threadTerminated(this);</span><br><span class="line">                group = null;</span><br><span class="line">            &#125;</span><br><span class="line">            target = null;</span><br><span class="line">            //加速资源清理</span><br><span class="line">            threadLocals = null;</span><br><span class="line">            inheritableThreadLocals = null;</span><br><span class="line">            inheritedAccessControlContext = null;</span><br><span class="line">            blocker = null;</span><br><span class="line">            uncaughtExceptionHandler = null;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>因此 如果我们使用线程池 那就意味着当前线程未必会退出（比如固定大小的线程池，线程总是存在） 如果这样 将一些大大的对象设置到ThreadLocal中(它实际保存在线程持有的ThreadLocal Map内) 可能会使系统出现内存泄露的可能(这里的意思是：你设置对象到ThreadLocal中 但是不清理它 在你使用几次后 这个对象也不再有用了 但是它却无法被回收)<br>此时 如果你希望及时回收对象 最好使用ThreadLocal.remove()方法将这个变量移出 就像我们有时候为了加速垃圾回收 会特意写出类似obj=null的代码 如果这么做 obj指向的对象就会更容易的被垃圾回收器发现 从而加速垃圾回收</p><p>同理 如果对于ThreadLocal的变量 我们也手动将其设置为null 比如tl=null 那么这个ThreadLocal对于的所有线程的局部变量都有可能被回收</p><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter4/ThreadLocalDemo_Gc.java" target="_blank" rel="noopener">ThreadLocalDemo_GC</a></p><p>要了解这里的回收机制 我们需要更进一步了解ThreadLocal.ThreadLocalMap的实现 ThreadLocalMap是一个类似WeakHashMap的东西</p><p>ThreadLocalMap的实现使用了弱引用 弱引用是比强引用弱的多的引用 Java虚拟机在垃圾回收时 如果发现弱引用 就立即回收 ThreadLocalMap内部是由一系列Entry构成 每一个Entry都是WeakReference</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">          /** The value associated with this ThreadLocal. */</span><br><span class="line">          Object value;</span><br><span class="line"></span><br><span class="line">          Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">              super(k);</span><br><span class="line">              value = v;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>这里的参数k就是Map的key v就是Map的value 其中k也就是ThreadLocal实例 作为弱引用使用(super(k)就是调用了WeakReference的构造函数) 因此 虽然这里使用ThreadLocal作为Map的key 但是实际上 它并不真的持有ThreadLocal的引用 而当ThreadLocal的外部强引用被回收时 ThreadLocalMap中的key就变为null 当系统进行ThreadLocalMap清理时（比如将新的变量加入表 就会自动进行一次清理 虽然JDK不一定会进行一次彻底的扫描但显然在我们这个案例中 它奏效了） 就会自然将这些垃圾数据回收</p><h3 id="4-3-3-对性能有何帮助"><a href="#4-3-3-对性能有何帮助" class="headerlink" title="4.3.3 对性能有何帮助"></a>4.3.3 对性能有何帮助</h3><p>为每一个线程分配一个独立的对象对系统性能也许是有帮助的 当然 这也不一定 这完全取决于共享对象的内部逻辑 如果共享对象对于竞争的处理容易引起性能损失<br>我们还是应该考虑使用ThreadLocal为每个线程分配单独的对象 一个典型的案例就是在多线程下使用随机数</p><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter4/RandomThreadLocalTest.java" target="_blank" rel="noopener">RandomThreadLocalTest</a></p><h2 id="4-4-无锁"><a href="#4-4-无锁" class="headerlink" title="4.4 无锁"></a>4.4 无锁</h2><p>人是分为乐天派与悲观派的 那么对并发控制的处理也是分为乐观与悲观的</p><p>锁就是一种悲观的策略 它总是假设每一次的临界区操作会产生冲突，因此，必须对每次操作都小心翼翼 如果有多个线程同时需要访问临界区资源 就宁可牺牲性能让线程进行等待 所以说锁会阻塞线程执行</p><p>而无锁是一种乐观的策略 它总是假设对资源的访问是没有冲突的 既然没有冲突 自然不需要等待 所以所有的线程都可以在不停顿的状态下持续执行 那遇到冲突怎么办?无锁的策略使用一种叫比较交换的技术（CAS CompareAndSwap)来鉴别线程冲突 一旦检测到冲突产生 就重试当前操作直到没有冲突为止</p><h3 id="4-4-1-与众不同的并发策略-比较交换（CAS"><a href="#4-4-1-与众不同的并发策略-比较交换（CAS" class="headerlink" title="4.4.1 与众不同的并发策略:比较交换（CAS)"></a>4.4.1 与众不同的并发策略:比较交换（CAS)</h3><p>与锁相比 使用比较交换 简称为CAS会使程序看起来复杂一些 但由于其非阻塞性 它对死锁问题天生免疫 并且 线程间的相互影响也远远比基于锁的方式要小 更为重要的是 使用无锁的方式完全没有锁竞争代理的系统开销 也没有线程间频繁调度带来的开销 因此 它要比基于锁的方式拥有更优越的性能</p><p>CAS算法的过程是这样的：它包含3个参数CAS(V,E,N),V表示要更新的变量 E表示预期值 N表示新值 仅当V值等于E值时 才会将V的值更新为N 如果V值和E值不同 则说明已经有其他线程做了更新 则当前线程什么都不做 最后 CAS返回当前V的真实值 CAS操作是抱着乐观的态度进行的 它总是认为自己可以独立完成操作<br>当多个线程同时使用CAS操作一个变量时 只有一个会胜出 并成功更新 其他均会失败 失败的线程不会被挂起 仅是被告知失败 并且允许再次尝试 当然也允许失败的线程放弃操作 基于这样的原理 CAS操作即使没有锁 也可以发现其他线程对当前线程的干扰 并进行恰当的处理</p><p>简单的说,CAS需要你额外给出一个期望值 也就是你认为这个变量现在应该是什么样子的 如果变量不是你想象的那样 那说明它已经被别人修改过了 你就重新读取 再次尝试修改就好了</p><p>在硬件层面 大部分的现代处理器都已经支持原子化的CAS指令 在JDK5.0以后 虚拟机便可以使用这个指令来实现并发操作和并发数据结构 并且 这种操作在虚拟机中可以说是无处不在</p><h3 id="4-4-2-无锁的线程安全整数-AtomicInteger"><a href="#4-4-2-无锁的线程安全整数-AtomicInteger" class="headerlink" title="4.4.2 无锁的线程安全整数 AtomicInteger"></a>4.4.2 无锁的线程安全整数 AtomicInteger</h3><p>为了让Java程序员能够受益于CAS等CPU指令 JDK并发包中有一个atomic包 里面实现了一些直接使用CAS操作的线程安全类型</p><p>其中 最常用的一个类 应该就是AtomicInteger 你可以把它看做是一个整数 但是与Integer不同 它是可变的 并且是线程安全的 对其进行修改等任何操作 都是用CAS指令进行的 这里简单列举一些AtomicInteger的一些主要方法 对于其他原子类 操作也是非常相似的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public final int get()//取得当前值</span><br><span class="line">public final void  set(int newValue)//设置当前值</span><br><span class="line">public final int  getAndSet(int newValue)//设置新值 并返回旧值</span><br><span class="line">public final boolean compareAndSet(int expect,int u)//如果当前值为expect 则设置为u</span><br><span class="line">public final int getAndIncrement()//当前值加1并返回旧值</span><br><span class="line">public final int getAndDecrement()//当前值减1并返回旧值</span><br><span class="line">public final int getAndAdd(int delta)//当前值增加delta，返回旧值</span><br><span class="line">public final int incrementAndGet() //当前值加1 返回新值</span><br><span class="line">public final int decrementAndGet() //当前值减1 返回新值</span><br><span class="line">public final int addAndGet(int delta)//当前值增加delta 返回旧值</span><br></pre></td></tr></table></figure><p>就内部实现上来说 AtomicInteger中保存了一个核心字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private volatile int value;</span><br></pre></td></tr></table></figure><p>它代表了AtomicInteger的当前实际值 此外还有一个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pirvate static final long valueObject;</span><br></pre></td></tr></table></figure><p>它保存了value字段在AtomicInteger对象中的偏移量 后面你会看到 这个偏移量是实现AtomicInteger的关键</p><p>下面的代码是AtomicInteger的使用示例</p><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter4/AtomicIntegerDemo.java" target="_blank" rel="noopener">AtomicIntegerDemo</a></p><p>使用AtomicInteger会比使用锁有更好的性能 这里就不进行测试了</p><p>和AtomicInteger类似的类还有AtomicLong用来代码long类型 AtomicBoolean表示boolean型 AtomicReference表示对象引用</p><h3 id="4-4-3-Java中的指针-Unsafe类"><a href="#4-4-3-Java中的指针-Unsafe类" class="headerlink" title="4.4.3 Java中的指针:Unsafe类"></a>4.4.3 Java中的指针:Unsafe类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final boolean compareAndSet(int expect, int update) &#123;</span><br><span class="line">       return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在这里，我们看到了一个特殊的变量unsafe 它是sun.misc.Unsafe类型 从名字看 这个类应该是封装了一些不安全的操作 那什么操作是不安全的呢 学习过C或者c++都知道 指针是不安全的 这也是在Java中把指针去除的重要原因 如果指针指错了位置或者计算指针偏移量出错 结果可能是灾难性的 你很有可能覆盖别人的内存 导致系统崩溃</p><p>而这里的Unsafe就是封装了一些类似指针的操作 compareAndSwapInt()方法是一个natvie 方法 它的几个参数含义如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final native boolean compareAndSwapInt(Object o, long offset, int expected, int x);</span><br></pre></td></tr></table></figure><p>第一个参数o为给定的对象 offset为对象内的偏移量(其实就是一个字段到对象头部的偏移量 通过这个偏移量可以快速定位字段),expected表示期望值 x表示要设置的值 如果指定的字段的值等于expected 那么就会把它设置为x</p><p>不难看出,compareAndSwapInt()方法的内部 比如是使用CAS原子指令完成的 此外 Unsafe类还提供了一些方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//获得给定对象偏移量上的int值</span><br><span class="line">public native int getInt(Object o,long offset);</span><br><span class="line">//设置给定对象偏移量上的int值</span><br><span class="line">public native void putInt(Object o,long offset,int x);</span><br><span class="line">//获得字段在对象中的偏移量</span><br><span class="line">public native void objectFieldOffset(Field f);</span><br><span class="line">//设置给定对象的int值 使用volatile语义</span><br><span class="line">public native void putIntVolatile(Object o,long offset,int x);</span><br><span class="line">//获得给定对象对象的int值，使用volatile语义</span><br><span class="line">public native int getIntVolatile(Object o,long offset);</span><br><span class="line">//和putIntVolatile()一样 但是它要求被操作字段就是volatile类型的</span><br><span class="line">public native void putOrderdInt(Object o,long offset,int x);</span><br></pre></td></tr></table></figure><p>在之前的3.3.4 深度剖析ConcurrentLinkedQueue一节中描述的ConcurrentLinkedQueue实现 应该对ConcurrentLinkedQueue中的Node还有些印像 Node的有一些CAS操作也是使用Unsafe类来是实现的<br>这里就可以看到 虽然Java派遣了指针 但是在关键时刻 类似指针的技术还是必不可少的 这里底层的Unsafe实现就是最好的例子 但是很不幸 JDK的开发人员不希望大家使用这个类 获得Unsafe实例的方法就是调动其工厂方法getUnsafe()，但是他的实现却是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static Unsafe getUnsafe() &#123;</span><br><span class="line">       Class var0 = Reflection.getCallerClass();</span><br><span class="line">       if(!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;</span><br><span class="line">           throw new SecurityException(&quot;Unsafe&quot;);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           return theUnsafe;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>注意 这里的代码如果是ClassLoader不为null 就会抛出异常 拒绝工作 因此 这也使得我们自己的应用程序无法直接使用Unsafe类 它是一个JDK内部使用的专属类</p><blockquote><p>注意：根据Java类加载器的工作原理 应用程序的类由AppLoader加载 而系统核心类 如rt.jar中的类由Bootstrap类加载器加载 Bootstrap加载器没有Java对象的对象 因此试图获得这个类加载器会返回null 所以 当一个类的类加载器为null时 说明它是Bootstrap加载的 而这个类极有可能是rt.jra中的类</p></blockquote><h3 id="4-4-4-无锁的对象引用：AtomicReference"><a href="#4-4-4-无锁的对象引用：AtomicReference" class="headerlink" title="4.4.4 无锁的对象引用：AtomicReference"></a>4.4.4 无锁的对象引用：AtomicReference</h3><p>AtomicReference和AtomicInteger非常类似 不同之处就在与AtomicInteger是对整数的封装 而AtomicReference则对应普通的对象引用<br>也就是它可以保证你在修改对象引用是的线程安全性</p><p>之前说过 线程判断被修改对象是否可以正确写入的条件是对象的当前值和期望值是否一致 这个逻辑从一般意义上是对的 但是有一个小小的意外 这个就是ABA问题 当你获得对象当前数据后 在准备修改为新值前 对象的值被其他线程连续修改了俩次 而经过这俩次修改后 对象的值又恢复为旧值 这样 当前线程就无法正确判断这个对象究竟是否被修改过</p><p>一般来说 发生这种情况的概率很小 而且即使发生了 可能也不是什么大问题 比如 我们只是很简单地做一个数值加法 即使我在取得期望值后 这个数字被不断的修改 只要它最终改回了我的期望值 我的加法计算就不会出错 也就是说 当你修改个对象没有过程的状态信息 所有的信息都只保存与对象的数值本身</p><p>但是 在现实中 还可能存在另外一种场景 就是我们是否能修改对象的值 不仅取决于当前值 还和对象的过程变化有关 这时 AtomicRenference就无能无力了</p><p>举个例子 如果有一家点 为了挽留客户 决定为贵宾卡余额小于20元的客户一次性赠送20元 刺激消费者充值与消费<br>但条件时 每个客户只能被赠送一次<br>使用AtomicReference演示这个场景</p><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter4/AtomicReferenceDemo.java" target="_blank" rel="noopener">AtomicReferenceDemo</a></p><p>这里就会出现一个问题 用户正好在进行消费 就在赠予金额的同时 他进行了一次消费 使得总金额又小于20元 并且正好累计消费了20元 使得消费，赠予后的金额等于消费前，赠予前的金额 这时 后台的赠予进程就会误以为这个账户还没有赠予 所以 存在被多次赠予的可能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">余额小于20元 充值成功，余额:39元</span><br><span class="line">大于10元</span><br><span class="line">成功消费10元，余额:29</span><br><span class="line">大于10元</span><br><span class="line">成功消费10元，余额:19</span><br><span class="line">大于10元</span><br><span class="line">成功消费10元，余额:9</span><br><span class="line">余额小于20元 充值成功，余额:29元</span><br><span class="line">大于10元</span><br><span class="line">成功消费10元，余额:39</span><br><span class="line">余额小于20元 充值成功，余额:39元</span><br></pre></td></tr></table></figure><p>从输出中可以看到 这个账号先后被反复充值 其原因正是因为账号余额被反复修改 修改后的值等于原有的值 使得CAS操作无法正确判断当前数据状态</p><p>虽然说这种情况出现的概率不大 但是依然是有可能出现的 因此 当业务确实可能出现这种情况时 我们也必须多加防范 体贴的JDK也已经为我们考虑到了这种情况 使用AtomicStampedReference就可以很好地解决这个问题</p><h3 id="4-4-5-带有时间戳的对象引用：AtomicStampedReference"><a href="#4-4-5-带有时间戳的对象引用：AtomicStampedReference" class="headerlink" title="4.4.5 带有时间戳的对象引用：AtomicStampedReference"></a>4.4.5 带有时间戳的对象引用：AtomicStampedReference</h3><p>AtomicReference无法解决上述问题的根本是因为对象在修改的过程中 丢失了状态信息 对象值本身与状态被画上了等号 因此 我们只要能记录对象在修改过程中的状态值 就可以很好的解决对象被反复修改导致线程无法正确判断对象状态的问题</p><p>AtomicStampedReference就是这么做的 它内部不仅维护对象值 还维护了一个时间戳（我这里把它称之为时间戳，实际上它可以使任何一个整数来表示状态值） 当AtomicStampedReference对应的数值被修改时 除了更新数据本身外 还必须要更新时间戳 当AtomicStampedReference设置新对象时 对象值以及时间戳必须满足期望值 写入才会成功 因此 即使对象值被反复读写 写回原值 只有时间戳发生变化 就能防止不恰当的写入</p><p>AtomicStampedReference的几个API在AtomicReference的基础上新增了有关时间戳的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//比较设置 参数以此为：期望值 写入新值 期望时间戳 新时间戳</span><br><span class="line">public boolean compareAndSet(V expectedReference,V new Reference,int expectedStamp,int newStamp)</span><br><span class="line">//获得当前对象引用</span><br><span class="line">public V getReference()</span><br><span class="line">//获得当前时间戳</span><br><span class="line">public int getStamp9)</span><br><span class="line">//设置当前对象引用和时间戳</span><br><span class="line">public void set(V newReference,int newStamp)</span><br></pre></td></tr></table></figure><p>有了AtomicStampedReference这个法宝 我们就再也不用担心对象被写坏<br>使用AtomicStampedReference来修正AtomicReferenceDemo的问题</p><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter4/AtomicStampedReferenceDemo.java" target="_blank" rel="noopener">AtomicStampedReferenceDemo</a></p><p>我们使用AtomicStampedReference代替原来的AtomicReference 首先获得账户的时间戳 后续的赠予操作以这个时间戳为依据 如果赠予成功 则修改时间戳 使得系统不可能发生二次赠予的情况 消费线程也是类似 每次操作 都使得时间戳加1 使之不可能重复</p><h3 id="4-4-6-数组也能无锁：AtomicIntegerArray"><a href="#4-4-6-数组也能无锁：AtomicIntegerArray" class="headerlink" title="4.4.6 数组也能无锁：AtomicIntegerArray"></a>4.4.6 数组也能无锁：AtomicIntegerArray</h3><p>除了提供基本数据类型外 JDK还为我们提供了数组等复合结构 当前可用的原子数组有:AtomicIntegerArray,AtomicLongArray和AtomicReferenceArray,分别表示整数数组 long类型数组和普通的对象数组</p><p>AtomicIntegerArray本质上是对int[]类型的封装 使用Unsafe类通过CAS的方式控制int[]在多线程下的安全性 它提供了以下几个核心API</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//获得数组第i个下标的元素</span><br><span class="line">public final int get(int i)</span><br><span class="line">//获得数组的长度</span><br><span class="line">public final int length()</span><br><span class="line">//将数组第i个下标设置为newVlaue，并返回旧的值</span><br><span class="line">public final int getAndSet(int i,int newValue)</span><br><span class="line">//进行CAS操作 如果第i个下标的元素等于expect，则设置为update，设置成功返回true</span><br><span class="line">public final boolean compareAndSet(int i,int expect,int update)</span><br><span class="line">//将第i个下标的元素加1</span><br><span class="line">public final int getAndIncrement(int i)</span><br><span class="line">//将第i个下标的元素减1</span><br><span class="line">public final int getAndDecrement(int i)</span><br><span class="line">//将第i个下标的元素增加delta(delta可以是负数)</span><br><span class="line">public final int getAndAdd(int i,int delta)</span><br></pre></td></tr></table></figure><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter4/AtomicIntegerArrayDemo.java" target="_blank" rel="noopener">AtomicIntegerArrayDemo</a></p><h3 id="4-4-7-让普通变量也享受原子操作-AtomicIntegerFieldUpdater"><a href="#4-4-7-让普通变量也享受原子操作-AtomicIntegerFieldUpdater" class="headerlink" title="4.4.7 让普通变量也享受原子操作:AtomicIntegerFieldUpdater"></a>4.4.7 让普通变量也享受原子操作:AtomicIntegerFieldUpdater</h3><p>有时候,由于初期考虑不周 或者后期的需求变化 一些普通变量可能也会有线程安全的需求 如果改动不大 我们可以简单地修改程序中的每一个使用或者读取这个变量的地方 但显然，这样不符合软件设计中的一条重要原则 —开闭原则 也就是系统对功能的增加应该是开发的 而对修改应该是相对保守的</p><p>所以在原子包里还有一个实用的工具类AtomicIntegerFieldUpdater 它可以让你不改动原有代码的基础上 让普通的变量也享受CAS操作带来的线程安全性 这样你可以修改极少的代码，来获得线程安全的保证</p><p>根据数据类型的不同 这个Updater有三种 分别是AtomicIntegerFieldUpdater,AtomicLongFieldUpdater和AtomicReferenceFieldUpdater 顾名思义 它们分别可以对int,long和普通对象进行CAS修改</p><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter4/AtomicIntegerFieldUpdaterDemo.java" target="_blank" rel="noopener">AtomicIntegerFieldUpdaterDemo</a></p><p>虽然AtomicIntegerField很好用 但是还有几个注意事项：</p><ul><li>第一 Updater只能修改它可见访问内的变量 因为Updater使用反射 如果变量不可见 就会出错 比如如果score申明为private 就是不可行的</li><li>第二 为了确保变量被正确的读取 它必须是volatile类型的 如果我们原有代码中未申明这个类型 那么简单地申明一下就行 这不会引起什么问题</li><li>第三 由于CAS操作会通过对象实例中的偏移量直接进行赋值 因此 它不支持static字段(Unsafe.objectFieldOffset()不支持静态变量)</li></ul><h3 id="4-4-8-挑战无锁算法-无锁的Vector实现"><a href="#4-4-8-挑战无锁算法-无锁的Vector实现" class="headerlink" title="4.4.8 挑战无锁算法:无锁的Vector实现"></a>4.4.8 挑战无锁算法:无锁的Vector实现</h3><blockquote><p>这段讲我很迷 以后再补吧 这里讲的是 Amino CBB 实现的LockFreeVector 我不知道作者在这里主要讲Vector的扩容机制的目的是什么 可能是因为get与push_back俩个方法是最关键的俩个方法把 有兴趣的自己翻书吧</p></blockquote><h3 id="4-4-9-让线程之间互相帮助-细看SynchronousQueue的实现"><a href="#4-4-9-让线程之间互相帮助-细看SynchronousQueue的实现" class="headerlink" title="4.4.9 让线程之间互相帮助:细看SynchronousQueue的实现"></a>4.4.9 让线程之间互相帮助:细看SynchronousQueue的实现</h3><p>在对线程池的介绍中 提到了一个非常特殊的等待队列SynchronousQueue<br>SynchronousQueue的容量为0<br>任何一个对SynchronousQueue的写需要等待一个SynchronousQueue的读 反之亦然 因此 SynchronousQueue与其说是一个队列 不如说是一个数据交换通道</p><p>SynchronousQueue中有大量的无锁操作<br>对SynchronousQueue来说 它将put()和take()俩个功能截然不同的操作抽象为一个共同的方法Transferer.transfer() 从字面上看 它就是数据传递的意思<br>它的完整签名如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E transfer(E e, boolean timed, long nanos)</span><br></pre></td></tr></table></figure><p>当参数e未非空时 表示当前操作传递给一个消费者 如果为空 则表示当前操作需要请求一个数据 timed参数决定是否存在timeout时间 nanos决定了timeout的时长 如果返回值为非空 则表示数据已经接受或者正常提供 如果为空 则表示失败（超时或者失败）</p><p>SynchronousQueue内部会维护一个线程等待队列</p><p>Trasferer.transfer()函数的实现是SynchronousQueue的核心 它大体分为三个步骤</p><ol><li>如果等待队列为空 或者队列中的节点的类型和本次操作是一致的 那么将当前操作压入队列等待 比如等待队列中是读线程等待 本次操作也是读 因此这俩个读都需要等待 进入等待队列的线程可能会被挂起 它们会等待一个‘匹配’操作</li><li>如果等待队列中的元素和本次操作互补(比如等待操作是读，而本次操作是写) 那么就可以插入一个‘完成’状态节点 并且让他‘匹配’到一个等待节点上 接着弹出这俩个节点 并且使得对于的俩个线程继续执行</li><li>如果线程发现等待队列的节点就是‘完成’节点 那么帮助这个节点完成任务 其流程和步骤2是一致的</li></ol><p>步骤一的实现如下 代码参考JDK 1.8.0_141</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SNode h = head;</span><br><span class="line">                if (h == null || h.mode == mode) &#123;  // 如果队列为空 或者模式相同</span><br><span class="line">                    if (timed &amp;&amp; nanos &lt;= 0) &#123;      // 不进行等待</span><br><span class="line">                        if (h != null &amp;&amp; h.isCancelled())</span><br><span class="line">                            casHead(h, h.next);     //取消处理行为</span><br><span class="line">                        else</span><br><span class="line">                            return null;</span><br><span class="line">                    &#125; else if (casHead(h, s = snode(s, e, h, mode))) &#123;</span><br><span class="line">                        SNode m = awaitFulfill(s, timed, nanos);</span><br><span class="line">                        if (m == s) &#123;               // 等待被取消</span><br><span class="line">                            clean(s);</span><br><span class="line">                            return null;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if ((h = head) != null &amp;&amp; h.next == s)</span><br><span class="line">                            casHead(h, s.next);     // 帮助s的fulfiller</span><br><span class="line">                        return (E) ((mode == REQUEST) ? m.item : s.item);</span><br><span class="line">                    &#125;</span><br></pre></td></tr></table></figure><p>第一行SNode表示等待队列的节点 内部封装了当前线程，next节点，匹配节点，数据内容等信息 第二行 判断当前等待队列为空 或者队列中的元素的模式与本次操作相同 第8行 生成一个新的节点并置于队列头部 这个节点就代表当前线程 如果入队成功 则执行第9行的awaitFulfill()函数，该函数被唤醒后(表示已经读取到数据或者自己尝试的数据已经被别的线程读取)在14-15行尝试帮助对应的线程完成俩个头部节点的出队操作（仅仅是友情帮助) 并在最后 返回读取或者写入的数据</p><p>步骤二的实现如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#125; else if (!isFulfilling(h.mode)) &#123; // 是否处于fulfill状态</span><br><span class="line">                  if (h.isCancelled())            // 如果以前取消了</span><br><span class="line">                      casHead(h, h.next);         // 弹出并重试</span><br><span class="line">                  else if (casHead(h, s=snode(s, e, h, FULFILLING|mode))) &#123;</span><br><span class="line">                      for (;;) &#123; // 一直循环到匹配(match)或者没有等待者</span><br><span class="line">                          SNode m = s.next;       // m是s的匹配者</span><br><span class="line">                          if (m == null) &#123;        // 已经没有等待者了</span><br><span class="line">                              casHead(s, null);   // 弹出fulfill节点</span><br><span class="line">                              s = null;           // 下一次使用新的节点</span><br><span class="line">                              break;              // 重新开始主循环</span><br><span class="line">                          &#125;</span><br><span class="line">                          SNode mn = m.next;</span><br><span class="line">                          if (m.tryMatch(s)) &#123;</span><br><span class="line">                              casHead(s, mn);     // 弹出s和m</span><br><span class="line">                              return (E) ((mode == REQUEST) ? m.item : s.item);</span><br><span class="line">                          &#125; else                  // match失败</span><br><span class="line">                              s.casNext(m, mn);   // 帮助删除节点</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br></pre></td></tr></table></figure><p>首先判断头部节点是否处于Fulfill模式 如果是 进入步骤三 否则 就视自己为对应的fulfill线程 第4行 生成一个SNode节点 设置为fulfill模式并将其压入队列头部 接着 设置m(原始的队列头部)为s的匹配节点 这个tryMatch()操作将会激活一个等待线程 并将m传递给那个线程 如果设置成功 则表示数据投递完成 将s和m俩个节点弹出即可 如果tryMatch()失败 则表示已经有其他线程帮我完成了操作 那么简单得删除m节点即可 因为这个节点已经被投递 不需要再次处理 然后 再次跳转到第5行的循环体 进行下一个等待线程的匹配和数据投递 直到队列中没有等待线程为止</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#125; else &#123;                            // 帮助一个fulfiller</span><br><span class="line">                  SNode m = h.next;               // m 是h的match</span><br><span class="line">                  if (m == null)                  // 没有等待者</span><br><span class="line">                      casHead(h, null);           // 弹出fulfill节点</span><br><span class="line">                  else &#123;</span><br><span class="line">                      SNode mn = m.next;</span><br><span class="line">                      if (m.tryMatch(h))          // 尝试match</span><br><span class="line">                          casHead(h, mn);         // 弹出h和m</span><br><span class="line">                      else                        // match失败</span><br><span class="line">                          h.casNext(m, mn);       // 帮助删除节点</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br></pre></td></tr></table></figure><p>上述代码的执行原理与步骤2是完全一致的 唯一的不同是步骤3不会返回 因为步骤3进行工作是帮助其他线程尽快投递它们的数据 而自己并没有完成对应的操作 因此 线程进入步骤3后 再次进入大循环体 才能步骤1开始重新判断和投递数据</p><p>从整个数据投递的过程中可以看到 在SynchronousQueue中 参与工作的所有线程不仅仅是竞争资源的关系 更重要的是 它们彼此之间还会互相帮助 在一个线程内部 可能会帮助其他线程完成它们的工作 这种模式可以更大程度上减少饥饿的可能 提供系统整体的并行度</p><h2 id="4-5-有关死锁的问题"><a href="#4-5-有关死锁的问题" class="headerlink" title="4.5 有关死锁的问题"></a>4.5 有关死锁的问题</h2><p>在一般情况下 使用锁的情况一般比无锁要多 而且在复杂的业务系统中 使用无锁的难度也是非常的高 但是使用锁 就会引起一个问题 –那就是死锁</p><p>什么是死锁 死锁就是俩个或者多个线程 相互占用对方需要的资源 而都不进行释放 导致彼此之间都相互等待对方释放资源 产生了无限制等待的现象 死锁一旦发生 如果没有外力介入 这种等待将永远存在 从而对程序的产生严重的影响</p><p>用来描述死锁问题的一个有名场景就是‘<a href="https://zh.wikipedia.org/wiki/哲学家就餐问题" target="_blank" rel="noopener">哲学家就餐</a>’问题</p><p>假设有五位哲学家围坐在一张圆形餐桌旁，做以下两件事情之一：吃饭，或者思考。吃东西的时候，他们就停止思考，思考的时候也停止吃东西。餐桌中间有一大碗意大利面，每两个哲学家之间有一只餐叉。因为用一只餐叉很难吃到意大利面，所以假设哲学家必须用两只餐叉吃东西。他们只能使用自己左右手边的那两只餐叉。哲学家就餐问题有时也用米饭和筷子而不是意大利面和餐叉来描述，因为很明显，吃米饭必须用两根筷子。</p><p>哲学家从来不交谈，这就很危险，可能产生死锁，每个哲学家都拿着左手的餐叉，永远都在等右边的餐叉（或者相反）。<br>如图<a href="https://upload.wikimedia.org/wikipedia/commons/thumb/7/7b/An_illustration_of_the_dining_philosophers_problem.png/200px-An_illustration_of_the_dining_philosophers_problem.png" target="_blank" rel="noopener"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/7b/An_illustration_of_the_dining_philosophers_problem.png/200px-An_illustration_of_the_dining_philosophers_problem.png" alt="哲学家就餐"></a></p><p>假设最简单的情况 就是只有2个哲学家 A和B A左手拿着其中一只叉子 B也一样 这样他们的右手都在等待对方的叉子 并且这种等待会继续 从而导致线程无法运转<br>下面用一个简单的例子模拟这个过程<br>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter4/DeadLock.java" target="_blank" rel="noopener">DeadLock</a></p><p>如果在实际环境中 遇到了这种情况 通常的表现就是相关的进程不再工作 并且CPU占用率为0(因为死锁的显存不占用CPU)，不过这种表现线性只能猜测问题 如果想要确认问题 还需要使用JDK提供的一套专业工具<br>我们可以使用jps命令得到java进程的ID 接着使用jstack命令得到线程的线程堆栈</p><p>想要避免死锁 除了使用无锁的函数外 另外一种有效的方法就是使用第三章介绍的重入锁 通过重入锁的中断或者限时等待可以有效避免死锁代理的问题</p><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter4/DeadLockInterruptSolve.java" target="_blank" rel="noopener">DeadLockInterruptSolve</a><br>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter4/DeadLockTimeLockSolve.java" target="_blank" rel="noopener">DeadLockTimeLockSolve</a></p><h1 id="第5章-并行模式与算法"><a href="#第5章-并行模式与算法" class="headerlink" title="第5章 并行模式与算法"></a>第5章 并行模式与算法</h1><h2 id="5-1-探讨单例模式"><a href="#5-1-探讨单例模式" class="headerlink" title="5.1 探讨单例模式"></a>5.1 探讨单例模式</h2><p>单例模式是一个对象创建模式 用于产生一个对象的具体实例 它可以确保系统中一个类只产生一个实例 在Java中 这样的行为能带来俩大好处</p><ul><li>对于频繁使用的对象 可以省略new操作花费的时间 这对于那些重量级对象而言 是非常可观的一笔系统开销</li><li>由于new操作的次数减少 因而对系统内存的使用频率也会降低 这将减轻GC压力 缩短GC停顿时间</li></ul><p>严格来说 单例模式与并行没有直接的关系</p><p>下面是一个单例的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line"> private Singleton()&#123;</span><br><span class="line"> System.out.println(&quot;Singleton is create&quot;);</span><br><span class="line">&#125;</span><br><span class="line">privat static Singleton instance =new Singleton();</span><br><span class="line"></span><br><span class="line">public static Singleton getInstance()&#123;</span><br><span class="line">   return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要保证系统中不会有人意外创建多余的实例 因此 我们把Sington的构造函数设置为private 这点非常重要 这就警告所有的开发人员 不能随便创建这个类的实例 从而有效避免该类被错误的创建</p><p>第二点 instance对象必须是private并且static的 如果不是privat 那么instance的安全性无法得到保证 一个小小的以外就可能使得instance变成null 其次 因为工程方法getInstance()必须是static的 因此对于的instnace也必须是static</p><p>但是这种方式有一点不足 就是Singleton构造函数 或者说Sington实例在什么时候创建是不受控制的 对于静态成员instance 它会在类第一次初始化的时候被创建 这个时刻并不一定是getInstance()方法第一次被调用的时候</p><p>比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">public static int STATUS=1;</span><br><span class="line"></span><br><span class="line"> private Singleton()&#123;</span><br><span class="line"> System.out.println(&quot;Singleton is create&quot;);</span><br><span class="line">&#125;</span><br><span class="line">privat static Singleton instance =new Singleton();</span><br><span class="line"></span><br><span class="line">public static Singleton getInstance()&#123;</span><br><span class="line">   return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 这个单例还包含一个表示状态的静态成员STATUS 此时 在相同任何地方应用这个STATUS都会导致instance实例被创建（任何对Singleton方法或者字段的引用 都会导致类初始化 并创建intance实例 但是类初始化只有一次 因此instance实例永远只会被创建一次）</p><p>比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Singleton.STATUS);</span><br></pre></td></tr></table></figure><p>上述println会打印出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Singleton is  create </span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>可以看到 即使系统没有要求创建单例 new Singleton（）也会被调用</p><p>如果你想精准控制instance的创建时间 那么这种方法就不太友善了<br>有一种新的方法 一种支持延迟加载的策略 它慧慧在instance背第一次使用时 创建对象 具体实现如下</p><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter5/LazySingleton.java" target="_blank" rel="noopener">LazySingleton.java</a></p><p>LazySingleton的核心思想如下 最初 并不需要实例化instance 而当getInstance()方法被第一次调用时 创建单例对象 为了防止对象被多次创建 我们不得不需使用synchronized进行方法同步 这种实现的好处是充分利用了延迟加载 只在真正需要时创建对象 但坏处也很明显并发加锁竞争激烈的场合对性能会产生一定的影响</p><p>此外 还有一种被称为双重检测模式的方法可以用于创建单例 这里不打算介绍 这是一种不好又复杂的方法 甚至在低JDK中不能保证正确性<br>有一种方法可以结合二者之优势</p><p>相关代码请见<a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter5/StaticSingleton.java" target="_blank" rel="noopener">StaitcSingleton.java</a></p><p>以上代码实现了一个单例 并且同时拥有前俩种方法的优点 首先getInstance()方法中没有锁 这使得在高并发环境下性能卓越 其次 只有在getInstance()方法被第一次调用时 StaticSingleton的实例才会被创建 因为这种方法巧妙地使用了内部类和类的初始化方式 内部类SingletonHolder被申明为private 这使得我们不可能在外部访问并初始化它 而我们值可能在getInstance()内部对SingletonHolder类进行初始化 利用虚拟机的类初始化机制创建单例</p><h2 id="5-2-不变模式"><a href="#5-2-不变模式" class="headerlink" title="5.2 不变模式"></a>5.2 不变模式</h2><p>多线程对同一个对象进行读写操作时 为了保证对象数据的一致性和正确性 有必要对对象进行同步 而同步操作对系统性能是有相当的损耗的 可以使用一种不会改变的对象 依靠对象的不变形 可以确保其在没有同步操作时的多线程环境中依然始终保持内部状态的一致性和正确性 这就是不变模式</p><p>不变模式天生就是多线程友好的 它的核心思想是 一旦一个对象被创建 则它的内部状态永远不会发生改变 所以 没有一个线程可以修改其内部状态和数据 同时其内部状态也绝不会自行发生改变 基于这些特性 对不变对象的多线程操作不需要进行同步控制</p><p>同时还需要注意 不变对象和只读属性是有一定的区别的 不变模式是比只读属性具有更强的一致性和不变形 对只读属性的对象而言 对象本身不能被其他线程修改 但是对象的自身状态却可能自行修改</p><p>因此 不变模式的主要使用场景需要满足以下2个条件：</p><ul><li>当对象被创建后 其内部状态和数据不再发生任何变化</li><li>对象需要被共享 被多线程频繁访问</li></ul><p>在Javayuy中 不变模式的实现很简单 为确保对象被创建后 不发生任何改变 并保证不变模式正常工作 只需要注意以下4点</p><ul><li>去除setter方法以及所有修改自身属性的方法</li><li>将所有属性设置为私有 并用final标记 确保其不可修改</li><li>确保没有子类可以重载它的行为</li><li>有一个可以创建完整对象的构造函数</li></ul><p>下面代码实现了一个不变的产品对象 它拥有序列号 名称 和价格三个属性</p><p><a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter5/Product.java" target="_blank" rel="noopener">Product.java</a></p><p>在JDK中 不变模式用的非常广泛 其中 最为典型的就是java.lang.String类 此外 所有元数据包装类 都是使用不变模式实现的</p><p>由于基本数据类型和String类型在实际的软件开发中应用极其广泛 使用不变模式 所有实例的方法都不需要同步操作 保证了多线程下的性能</p><blockquote><p>不变模式通过回避问题而不是解决问题的态度来处理多线程并发访问控制</p></blockquote><h2 id="5-3-生产者-消费者模式"><a href="#5-3-生产者-消费者模式" class="headerlink" title="5.3 生产者-消费者模式"></a>5.3 生产者-消费者模式</h2><p>生产者-消费者模式是一个经典的多线程设计模式 它为多线程间的协作提供了良好的解决方案 在生产者-消费者模式中 通常有两类线程 即若干个生产者线程和若干个消费者线程 生成者线程负责提交用户请求 消费者线程则负责处理生产者提交的任务 生产者和消费者之间通过共享内存缓冲区来进行通信</p><blockquote><p>生产者-消费者模式中的内存缓存区的主要功能是数据在多线程间的共享 此外 通过该缓冲区 可以缓解生成者和消费者之间的性能差</p></blockquote><p>生产者-消费者模式的核心组件是共享内存缓冲区 它作为生产者和消费者间的通信桥梁</p><table><thead><tr><th style="text-align:left">角色</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">生产者</td><td style="text-align:left">用于提交用户请求 提取用户任务 并装入内存缓冲区</td></tr><tr><td style="text-align:left">消费者</td><td style="text-align:left">在内存缓冲区中提取并处理任务</td></tr><tr><td style="text-align:left">内存缓冲区</td><td style="text-align:left">缓冲生产者提交的任务或数据 供消费者使用</td></tr></tbody></table><p>其中 BlockingQueue充当了共享内存缓冲区 用于维护任务或数据队列</p><p><a href="http://img.blog.csdn.net/20170629174908752?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGVfc2h1YWkyMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" target="_blank" rel="noopener"><img src="http://img.blog.csdn.net/20170629174908752?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGVfc2h1YWkyMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="此处输入图片的描述"></a></p><blockquote><p>BlockingQueue在第三章</p></blockquote><p>相关代码请见<a href="https://github.com/SanShanYouJiu/CodeCollection/tree/master/Java高并发程序设计/javaHighConcurrentDesign/chapter5/blocingQueue" target="_blank" rel="noopener">BlcokingQueue</a></p><h2 id="5-4-高性能的生产者-消费者：无锁的实现"><a href="#5-4-高性能的生产者-消费者：无锁的实现" class="headerlink" title="5.4 高性能的生产者-消费者：无锁的实现"></a>5.4 高性能的生产者-消费者：无锁的实现</h2><p>BlockingQueue用于实现生产者和消费者一个不错的选择 它可以很自然的实现作为生产者和消费者的内存缓冲区<br>但是BlockingQueue并不是一个高性能的实现 它完全使用锁和阻塞等待实现线程间的同步 在高并发场合 它的性能并不是特别的卓越 就像之前已经提过的ConcurrentLinkedQueue是一个高性能的队列 但是BlockingQueue只是为了方便数据共享</p><h3 id="5-4-1-无锁的缓存框架：Disruptor"><a href="#5-4-1-无锁的缓存框架：Disruptor" class="headerlink" title="5.4.1 无锁的缓存框架：Disruptor"></a>5.4.1 无锁的缓存框架：Disruptor</h3><p>Disruptor是由LMAX公司开发的一款高效的无锁内存队列 它使用无锁的方式实现了一个环形队列 非常适合于实现生产者和消费者模式 比如事件和消息的发布 在Disruptor中 别出心裁的使用了环形队列（RingBuffer）来代替普通线性队列 这个环形队列内部实现为一个普通的数组 对于一般的队列 势必要提供队列同步head和尾部tail俩个指针 用于出队入队 增加了线程协作的复杂度 但是如果队列是环形的 则只需要对外提供一个当前位置cursor 利用这个指针即可以入队也可以进行出队操作 由于环形队列的缘故 队列的总大小必须事先指定 不能动态扩展 为了能快速从一个序列对应数组的实际位置（每次有元素入队 序列就加1），Disruptor要求我们必须将数组的大小设置为2的整数次方这样通过sequence&amp;（queueSize-1）就能立即定位到实际的元素位置index 这个要比取余(%)操作快得多</p><p>如果大家不理解上面的sequence&amp;（queueSize-1） 在这里简单说明一下 如果queueSize是2的整数次幂 则这个数字的二进制表示比如是10，100,1000 等形式 因此queueSize-1的二进制是一个全1的数字 因此它可以将sequnce限定在queueSize-1的范围内 并且不会有任何一位是浪费的</p><p><a href="https://modeshape.files.wordpress.com/2014/04/ringbuffer-31.png" target="_blank" rel="noopener"><img src="https://modeshape.files.wordpress.com/2014/04/ringbuffer-31.png" alt="此处输入图片的描述"></a><br>相关代码请见<a href="https://github.com/SanShanYouJiu/CodeCollection/tree/master/Java高并发程序设计/javaHighConcurrentDesign/chapter5/disruptor" target="_blank" rel="noopener">Disruptor案例</a><br>Disruptor至少要比BlockingQueue要高一个量级以上</p><h3 id="5-4-3-提高消费者的响应时间：选择合适的策略"><a href="#5-4-3-提高消费者的响应时间：选择合适的策略" class="headerlink" title="5.4.3 提高消费者的响应时间：选择合适的策略"></a>5.4.3 提高消费者的响应时间：选择合适的策略</h3><p>当有新数据在Disruptor的环形缓冲区中产生时 消费者如何知道这些新产生的数据呢 或者说 消费者如何监控缓冲区中的信息呢 为此 Disruptor提供了几种策略 这些策略由WaitStrategy接口封装 主要有以下几种实现</p><ul><li>BlockingWaitStrategy：这是默认的策略 使用BlockingWaitStrategy和使用BlockingQueue是非常类似的 它们都使用锁和条件(Condition)进行数据的监控和线程的唤醒 因为涉及到线程的切换 BlockingWaitStrategy策略是最节省CPU 但是在高并发下性能表现最糟糕的一种等待策略</li><li>SleepingWaitStrategy：这个策略也是对CPU使用率非常保守的 它会在循环中不断等待数据 它会先进行自旋等待 如果不成功 则使用Thread.yiled()让出cpu 并最终使用LockSupport.parkNanos(1)进行线程休眠 以确保不占用太多的CPU数据 因此 这个策略对于数据处理可能产生比较高的平均延时 它比较适合于延时要求不是特别高的场合 好处是它对生产者线程影响最小 典型的应用场景是异步日志</li><li>YiedldingWaitStrategy:这个策略用于低延时的场合 消费者线程会不断循环监控缓冲区变化 在循环内部 它会使用Thread.yield()让出CPU给别的线程执行时间 如果你需要一个高性能的系统 并且对延时有较为严格的要求 则可以考虑这种策略 使用这种策略时 相当于你的消费者线程变身为一个内部执行了Thread.yield()的死循环 因此 你最好有多余消费者线程数量的逻辑CPU数量（这里的逻辑CPU 指的是“双核四线程”中的四线程 否则 整个应用程序恐怕都会受到影响）</li><li>BusySpinWaitStrategy:这个是最疯狂的等待策略 它就是一个死循环！ 消费者线程会尽最大努力疯狂的监控缓冲区的变化 因此 它会吃掉所有的CPU资源 你只有在延时非常苛刻的场合可以考虑使用它（或者说 你的系统真的非常繁忙） 因为在这里你等同开启了一个死循环监控 所以你的物理CPU必须要大于消费者线程数 注意 这里说的是物理CPU 不是超线程技术模拟的俩个逻辑核 另外一个逻辑核显然会受到这种超密集计算的影响而不能正常工作</li></ul><h3 id="5-4-4-CPU-cache的优化：解决伪共享问题"><a href="#5-4-4-CPU-cache的优化：解决伪共享问题" class="headerlink" title="5.4.4 CPU cache的优化：解决伪共享问题"></a>5.4.4 CPU cache的优化：解决伪共享问题</h3><p>除了使用CAS和提供了各种不同的等待策略来提高系统的吞吐量外 Disruptor大有优化到底的气势 甚至尝试解决CPU缓存的伪共享问题</p><p>什么是伪共享问题 为了提高CPU的速度 CPU有一个高速缓存cache 在高速缓存中 读写数据最小单位为缓存行（Cache line） 它是从主存（memory）复制到缓存（Cache）的最小单位 一般为32字节到128字节</p><p>如果俩个变量存放在一个缓存行中 在多线程访问时可能会相互影响彼此的性能<br><a href="https://www.ibm.com/developerworks/cn/aix/library/au-aix-multicore-multiprocessor/false_sharing.png" target="_blank" rel="noopener"><img src="https://www.ibm.com/developerworks/cn/aix/library/au-aix-multicore-multiprocessor/false_sharing.png" alt="此处输入图片的描述"></a></p><p>为了不使这种情况发生 一种可行的方法就是在变量的前后都先占据一定的位置（叫做padding吧） 这样 当内存被读入缓存时 这个缓存行 只有这个变量是实际有效的 因此就不会发生多个线程修改缓存行中不同变量而导致变量全体失效的情况</p><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter5/disruptor/FalseSharing.java" target="_blank" rel="noopener">FlaseSharing.java</a></p><p>在代码的55行 准备了7个long型变量来填充缓存 实际上 只有VolatileLong.value是被使用的 而那写p1,p2等仅仅用于将数组中第一个VolatileLong.value和第二个VolatileLong.value分开 防止它们进入同一个缓存行</p><blockquote><p>注意 由于各个JDK版本内部实现不一致 在某些JDK版本中（比如JDK8）会自动优化不使用的字段 这将直接导致这种padding的伪共享问题解决方案失效 更多详细内容到第6章有关LongAddr的介绍</p></blockquote><p>在Disruptor内部充分考虑了这个问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public final class PaddedLong extends MutableLong</span><br><span class="line">&#123;</span><br><span class="line">    public volatile long p1, p2, p3, p4, p5, p6 = 7L;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Default constructor</span><br><span class="line">     */</span><br><span class="line">    public PaddedLong()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Construct with an initial value.</span><br><span class="line">     *</span><br><span class="line">     * @param initialValue for construction</span><br><span class="line">     */</span><br><span class="line">    public PaddedLong(final long initialValue)</span><br><span class="line">    &#123;</span><br><span class="line">        super(initialValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public long sumPaddingToPreventOptimisation()</span><br><span class="line">    &#123;</span><br><span class="line">        return p1 + p2 + p3 + p4 + p5 + p6;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-5-Future模式"><a href="#5-5-Future模式" class="headerlink" title="5.5 Future模式"></a>5.5 Future模式</h2><p>Future模式是多线程开发中非常常见的一种设计模式 它的核心思想是异步调用<br><a href="http://img.blog.csdn.net/20141112192253656" target="_blank" rel="noopener"><img src="http://img.blog.csdn.net/20141112192253656" alt="此处输入图片的描述"></a></p><h3 id="5-5-1-Future模式的主要角色"><a href="#5-5-1-Future模式的主要角色" class="headerlink" title="5.5.1 Future模式的主要角色"></a>5.5.1 Future模式的主要角色</h3><table><thead><tr><th style="text-align:left">参与者</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">Main</td><td style="text-align:left">系统启动 调用Client发出请求</td></tr><tr><td style="text-align:left">Client</td><td style="text-align:left">返回Data对象 立即返回FutreData并开启ClientThread线程装配RealData</td></tr><tr><td style="text-align:left">FutureData</td><td style="text-align:left">Future数据 构造很快 但是是一个虚拟的数据 需要装配RealData</td></tr><tr><td style="text-align:left">RealData</td><td style="text-align:left">真实数据 其构造是比较慢的</td></tr></tbody></table><p><a href="http://static.zybuluo.com/csqiang1992/4hdkathsfqkngvyd5ndus1az/futrue-core-impl.png" target="_blank" rel="noopener"><img src="http://static.zybuluo.com/csqiang1992/4hdkathsfqkngvyd5ndus1az/futrue-core-impl.png" alt="此处输入图片的描述"></a></p><h3 id="5-5-2-Future模式的简单实现"><a href="#5-5-2-Future模式的简单实现" class="headerlink" title="5.5.2 Future模式的简单实现"></a>5.5.2 Future模式的简单实现</h3><p>有一个核心接口Data 这就是客户端想要的数据<br>在Futre模式中 这个接口有俩个重要的实现 一个是RealData 也就是真实数据 一个是FutureData 只是用来提取RealData的一个订单<br>因此FutureData是可以立即返回的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Data &#123;</span><br><span class="line">    public String getResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FuturData实现了一个快速返回 它只是一个包装 或者说是一个RealData的虚拟实现 因此 它可以很快被构造并返回 当使用FutureData的getResult()方法时 如果实际的数据没有准备好 那么程序就会被阻塞 等待RealData准备好并注入到FutureData中 才最终返回数据</p><blockquote><p>FuturData是Future模式的关键 它实际上是真实数据RealData的代理 封装了获取RealData的等待过程</p></blockquote><p>相关代码请见<a href="https://github.com/SanShanYouJiu/CodeCollection/tree/master/Java高并发程序设计/javaHighConcurrentDesign/chapter5/future" target="_blank" rel="noopener">Future模式</a></p><h3 id="5-5-3-Jdk内部的Future模式"><a href="#5-5-3-Jdk内部的Future模式" class="headerlink" title="5.5.3 Jdk内部的Future模式"></a>5.5.3 Jdk内部的Future模式</h3><p>RunnablFuture继承了Future和Runnable俩个接口 其中run()方法用于构造真实的数据 它有一个具体的实现FutureTask类<br>FutureTask有一个内部类Sync 一些实质性的工作 会委托给Sync类实现 而Sync类最终会调用Callable接口 完成实际数据的组装工作</p><p><a href="http://www.joyhwong.com/wp-content/uploads/2016/11/123.jpg" target="_blank" rel="noopener"><img src="http://www.joyhwong.com/wp-content/uploads/2016/11/123.jpg" alt="此处输入图片的描述"></a><br>Callable接口只有一个方法call() 它会发货需要构造的实际数据 这个Callable接口也是这个Future框架和应用程序之间的重要接口 如果我们要实现自己的业务系统 通常需要实现自己的Callable对象 此外FutureTask类也与应用密切关联</p><p><a href="https://github.com/SanShanYouJiu/CodeCollection/tree/master/Java高并发程序设计/javaHighConcurrentDesign/chapter5/future2" target="_blank" rel="noopener">JDK内部的Futute模式</a></p><h2 id="5-6-并行流水线"><a href="#5-6-并行流水线" class="headerlink" title="5.6 并行流水线"></a>5.6 并行流水线</h2><p>并发算法虽然可以充分发挥多核CPU的性能 但不幸的是 并非所有的计算都可以改造成并发的形式 简单的说 执行过程中有数据相关性的运算都是无法完美并行化的</p><p>比如(B+C)<em>B/2 这个过程就无法并行的 原因是 如果B+C无法完成 则永远算不出（B+C)</em>B 这就是数据相关性 如果线程执行过程中 所需的数据存在这种依赖关系 那么 就没有办法将它们完美的并行化</p><p>遇到这种情况 补救措施就是采用日常生活中的流水线思想<br>相关代码请见<a href="https://github.com/SanShanYouJiu/CodeCollection/tree/master/Java高并发程序设计/javaHighConcurrentDesign/chapter5/concurrent/compute" target="_blank" rel="noopener">并行计算</a></p><h2 id="5-7-并行搜索"><a href="#5-7-并行搜索" class="headerlink" title="5.7 并行搜索"></a>5.7 并行搜索</h2><p>搜索是几乎每个软件都有个功能 对于有序数据 通常可以采用二分法 对于无序数据 只能挨个查找</p><p>给定一个数组 要查找满足条件的元素 对于串行程序来说 只要遍历一下数组就可以得到结果 但如果要使用并行方式 则需要额外增加一些线程间的通信机制 使各个线程可以有效的运行</p><p>一种简单的策略就是将原始数据集合按照期望的线程数进行分割，如果我们计划使用俩个线程进行搜索 那么就可以把一个数组或集合分割成俩个 每个线程各自的独立搜索 当其中有一个线程找到数据后 立即返回结果即可</p><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter5/concurrent/search/SearchDemo.java" target="_blank" rel="noopener">SearchDemo.java</a></p><h2 id="5-8-并行排序"><a href="#5-8-并行排序" class="headerlink" title="5.8 并行排序"></a>5.8 并行排序</h2><p>排序是一个非常常用的操作 在应用程序运行时 无时无刻不在排序<br>当排序元素有很多时 若使用并行算法代替串行算法 显然可以更加有效的利用CPU 但将串行算法改造为并行算法并非易事 甚至会极大的增强原有算法的复杂度<br>这里介绍几个简单平行排序算法</p><h3 id="5-8-1-分离数据相关性：奇偶交换排序"><a href="#5-8-1-分离数据相关性：奇偶交换排序" class="headerlink" title="5.8.1 分离数据相关性：奇偶交换排序"></a>5.8.1 分离数据相关性：奇偶交换排序</h3><p>奇偶排序是对冒泡排序的并行改造</p><blockquote><p>在<a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter5/concurrent/sort/SerialSort.java" target="_blank" rel="noopener">SerialSort.java</a>中有相关冒泡排序的代码</p></blockquote><p>对于奇偶排序来说 它将排序分为俩个阶段 奇交换与偶交换 对于奇交换来说 它总是比较奇数索引以及相邻的后续元素 而偶交换总是比较偶数索引和其相邻的后续元素 并且 奇交换与偶交换会成对出现 这样才能保证比较和交换涉及到数组中的每一个元素<br>奇偶交换的串行实现也在<a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter5/concurrent/sort/SerialSort.java" target="_blank" rel="noopener">SerialSort.java</a>中有相关代码</p><p>这样的代码虽然是串行代码 但是已经很好改造为并行模式了</p><p>相关代码请见<a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter5/concurrent/sort/OddEventSort.java" target="_blank" rel="noopener">OddEventSort.java</a></p><h3 id="5-8-2-改进的插入排序：希尔排序"><a href="#5-8-2-改进的插入排序：希尔排序" class="headerlink" title="5.8.2 改进的插入排序：希尔排序"></a>5.8.2 改进的插入排序：希尔排序</h3><p>插入排序也是一种很常用的排序算法</p><blockquote><p>在<a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter5/concurrent/sort/SerialSort.java" target="_blank" rel="noopener">SerialSort.java</a>中有相关插入排序的代码<br>简单的插入排序是很难并行化的 因为这一次的数据插入依赖上一次得到的有序排列 因此多个步骤是无法并行的</p></blockquote><p>希尔排序将整个数组根据间隔h分割为若干个子数组 子数组相互穿插在一起 每一次的排序时 分别对每一个子数组进行排序</p><p>在每一组排序完成后 可以递减h的值 进行下轮更加精细的排序 直到h为1 此时等价于一次插入排序</p><p>并行排序的一个主要优点是，即使一个较小的元素在数组的末尾 由于每次元素移动都以h为间隔进行 因此数组末尾的小元素可以在很少的交换次数下 就被置换到最接近元素最终位置的地方</p><p>希尔排序的串行实现<br>相关代码请见<a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter5/concurrent/sort/SerialSort.java" target="_blank" rel="noopener">SerialSort.java</a></p><p>希尔排序就很好改造为并行程序了<br>相关代码请见<a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter5/concurrent/sort/ShellSortDemo.java" target="_blank" rel="noopener">ShellSort.java</a></p><h2 id="5-9-并行算法-矩阵算法"><a href="#5-9-并行算法-矩阵算法" class="headerlink" title="5.9 并行算法:矩阵算法"></a>5.9 并行算法:矩阵算法</h2><blockquote><p>同第四章的无锁Vector一样 不好找具体工具 就不再说明了</p></blockquote><h2 id="5-10-准备好了再通知我：网络NIO"><a href="#5-10-准备好了再通知我：网络NIO" class="headerlink" title="5.10 准备好了再通知我：网络NIO"></a>5.10 准备好了再通知我：网络NIO</h2><p>Java NIO是NEW IO的简称 它是一种可以替代Java IO的一套新的IO机制 它提供了一套不同于java标准的IO的操作机制 严格来说 NIO与并发无直接的关系 但是 使用NIO技术可以大大的提高线程的使用效率</p><p>Java NIO涉及的基础内容有通道(Channel)和缓冲区（Buffer）,文件IO和网络IO 有关通道，缓冲区以及文件IO在这里不打算进行详细的介绍</p><h3 id="5-10-1-基于Socket的服务端的多线程模式"><a href="#5-10-1-基于Socket的服务端的多线程模式" class="headerlink" title="5.10.1 基于Socket的服务端的多线程模式"></a>5.10.1 基于Socket的服务端的多线程模式</h3><p>这里 以一个简单的Echo服务器为例 对于Echo服务器 它会读取客户端的一个输入 并将这个输入原封不动的返回给客户端</p><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter5/socket/io/MultiThreadEchoServer.java" target="_blank" rel="noopener">MultiThreadEchoServer.java</a><br>这是一个支持多线程的服务端的核心内容 它的特点是 在相同可支持的线程访问内 可以尽量多地支持客户端的数量 同时和单线程服务器相比 它可以更好的支持多核CPU<br>相关代码请见<a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter5/socket/io/MultiThreadEchoClient.java" target="_blank" rel="noopener">MultiThreadEchoClient.java</a></p><p>对于绝大部分应用来说 这种模式可以很好地工作 但是 如果想让你的程序工作更加高效 就必须知道这个模式一个重大的弱点 那就是倾向于让CPU进行IO等待<br>下面有个清晰的例子<br><a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter5/socket/io/https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter5/socket/io/HeavySocketClient.java" target="_blank" rel="noopener">HeavySocketClient.java</a><br>之所以处理的慢 并不是因为服务端有多少繁重的业务 而仅仅是因为服务线程在等待IO而已 让高速运转的CPU去等待极其低效的网络IO是非常不合算的行为<br>是不是可以将网络IO的等待时间从线程中分离出来呢？</p><h3 id="5-10-2-使用NIO进行网络编程"><a href="#5-10-2-使用NIO进行网络编程" class="headerlink" title="5.10.2 使用NIO进行网络编程"></a>5.10.2 使用NIO进行网络编程</h3><blockquote><p><a href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html#ibm-pcon" target="_blank" rel="noopener">一个NIO入门链接</a></p></blockquote><p>首先知道NIO中的一个关键组件Channel(通道)Channel有点类似于流 一个Channel可以和文件或者网络Socket对应 如果Channel对应一个Socket 那么往这个Channel中写数据 就等于往Socket中写数据</p><p>和Channel一起使用的另外一个重要组件就是Buffer 大家可以简单的把Buffer理解成一个内存区或者Byte数组 数据需要包装成Buffer的形式才能和Channel交互(写入或读取）</p><p>另外一个与Channel密切相关的是Selector(选择器) 在Channel众多实现中 SelectableChannel实现 表示可被选择的通道<br>任何一个SelectableChannel都可以将自己注册到一个Selector中 这样这个Channel就能被Selector所管理 而一个Selector可以管理多个SelectableChannel 当SelectableChannel的数据准备好时 Selector就会接到通知 得到那写已经准备好的数据 而SocketChannel就是SelectableChannel的一种</p><p>这样的话 一个Selector可以由一个线程进行管理 而一个SocketChannel则可以表示一个客户端连接 因此就构成由一个或者极少数线程 来处理大量客户端连接的结构 当与客户端连接的数据没有准备好时 Selector会处于等待状态(不过 幸好 用于管理Selector的线程是极少量的） 而一旦有任何一个SocketChannel准备好了数据 Selector就能立即得到通知 获取数据进行处理</p><p>相关代码请见<a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter5/socket/nio/NioServerSocket.java" target="_blank" rel="noopener">NioServerSocket.java</a></p><h3 id="5-10-3-使用NIO来实现客户端"><a href="#5-10-3-使用NIO来实现客户端" class="headerlink" title="5.10.3 使用NIO来实现客户端"></a>5.10.3 使用NIO来实现客户端</h3><p>相关代码请见 <a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter5/socket/nio/NioSocketClient.java" target="_blank" rel="noopener">NioSocketClient.java</a></p><h2 id="5-11-读完了再通知我：AIO"><a href="#5-11-读完了再通知我：AIO" class="headerlink" title="5.11 读完了再通知我：AIO"></a>5.11 读完了再通知我：AIO</h2><p>AIO是异步IO的缩小 即Asynchronized 虽然NIO在网络操作中 提供了非阻塞的方法 但是NIO的IO行为还是同步的 对于NIO来说 我们的业务线程是在IO操作准备好时 得到通知 接着就由这个线程自行进行IO操作 IO操作本身还是同步的</p><p>但是对AIO来说 就更进一步 它不是在IO准备好时再通知线程 而是在IO操作已经完成后 再给线程发出通知 因此AIO是完全不会阻塞的 此时 我们的业务逻辑将变为一个回调函数 等待IO操作完成后 由系统自动触发</p><h3 id="5-11-1-AIO-EchoServer的实现"><a href="#5-11-1-AIO-EchoServer的实现" class="headerlink" title="5.11.1 AIO EchoServer的实现"></a>5.11.1 AIO EchoServer的实现</h3><p>相关代码请见<a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter5/socket/aio/AioEchoServer.java" target="_blank" rel="noopener">AioEchoServer.java</a></p><h3 id="5-11-2-AIO-Echo客户端实现"><a href="#5-11-2-AIO-Echo客户端实现" class="headerlink" title="5.11.2 AIO Echo客户端实现"></a>5.11.2 AIO Echo客户端实现</h3><p>相关代码请见<a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter5/socket/aio/AioEchoClient.java" target="_blank" rel="noopener">AioEchoClient.java</a></p><h1 id="第六章-Java8与并发"><a href="#第六章-Java8与并发" class="headerlink" title="第六章 Java8与并发"></a>第六章 Java8与并发</h1><h2 id="6-1-Java8的函数式编程简介"><a href="#6-1-Java8的函数式编程简介" class="headerlink" title="6.1 Java8的函数式编程简介"></a>6.1 Java8的函数式编程简介</h2><h3 id="6-1-1-函数作为一等公民"><a href="#6-1-1-函数作为一等公民" class="headerlink" title="6.1.1 函数作为一等公民"></a>6.1.1 函数作为一等公民</h3><p>函数可以作为另外一个函数的返回值 这也是函数式编程的特点</p><h3 id="6-1-2-无副作用"><a href="#6-1-2-无副作用" class="headerlink" title="6.1.2 无副作用"></a>6.1.2 无副作用</h3><p>函数的副作用指的是在调用过程中 除了给出了返回值外 还修改了函数状态 比如 函数在调用过程中 修改了某一个全局状态 函数式编程认为，函数的副作用应该被尽量避免</p><blockquote><p>显示函数指函数与外界交换数据的唯一渠道就是参数和返回值 显示函数不会去读取或者修改函数的外部状态 与之相对的是隐式函数 隐式函数除了参数和返回值外 还会读取外部信息 或者可能修改外部信息</p></blockquote><p>完全的无副作用实际上做不到的 因为系统总是需要获取或者修改外部信息的</p><h3 id="6-1-3-申明式的（Declarative）"><a href="#6-1-3-申明式的（Declarative）" class="headerlink" title="6.1.3 申明式的（Declarative）"></a>6.1.3 申明式的（Declarative）</h3><p>函数式编程是申明式的编程方式，相对于命令式（Imperative)而言 命令式的程序设计喜欢大量使用可变对象和指令<br>在申明式的编程范式 你不再需要提供明确的指令操作 所有的细节指令将会更好地被程序库所封装 你要做的只是提出你的需求 申明你的用意即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int[] arr = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9,10&#125;;</span><br><span class="line">      for (int i : arr) &#123;</span><br><span class="line">          System.out.println(i);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>与之对应的申明式代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> int[] arr = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9,10&#125;;</span><br><span class="line">Arrays.stream(arr).forEach((final int x)-&gt;&#123;</span><br><span class="line">           System.out.println(x);</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><p>在此 我们只是简单的申明了我们的用意 有关循环以及判断是否结束等操作都被简单地封装在程序库中</p><h3 id="6-1-4-不变的对象"><a href="#6-1-4-不变的对象" class="headerlink" title="6.1.4 不变的对象"></a>6.1.4 不变的对象</h3><p>在函数式编程中 几乎所有传递的对象都不会被轻易修改<br>例子如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static int[] arr = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9,10&#125;;</span><br><span class="line"> Arrays.stream(arr).map((x)-&gt;x=x+1).forEach(System.out::println);</span><br><span class="line">System.out.println();</span><br><span class="line">Arrays.stream(arr).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>在使用函数式编程时 这种状态是一种常态 几乎所有的对象都拒绝被修改 这非常类似于不变模式</p><h3 id="6-1-5-易于并行"><a href="#6-1-5-易于并行" class="headerlink" title="6.1.5 易于并行"></a>6.1.5 易于并行</h3><p>由于对象都处于不变的状态 因此函数式编程更加易于并行 我们之所以要关注线程安全 一个很重要的原因是当多个线程对同一个对象进行写操作 容易将这个对象”写坏” 但是 由于对象是不变的 因此 在多线程环境下 也就没有必要进行任何同步操作</p><h3 id="6-1-6-更少的代码"><a href="#6-1-6-更少的代码" class="headerlink" title="6.1.6 更少的代码"></a>6.1.6 更少的代码</h3><p>通常情况下 函数式编程更加简明扼要 代码更少</p><h2 id="6-2-函数式编程基础"><a href="#6-2-函数式编程基础" class="headerlink" title="6.2 函数式编程基础"></a>6.2 函数式编程基础</h2><p>Java 8 提出了函数式接口的概念 所谓函数式接口 简单来说 就是只定义了的单一抽象方法的接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Runnable &#123;</span><br><span class="line">    /**</span><br><span class="line">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span><br><span class="line">     * to create a thread, starting the thread causes the object&apos;s</span><br><span class="line">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span><br><span class="line">     * thread.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span><br><span class="line">     * take any action whatsoever.</span><br><span class="line">     *</span><br><span class="line">     * @see     java.lang.Thread#run()</span><br><span class="line">     */</span><br><span class="line">    public abstract void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释FunctionInterface用于表明Runnable是一个函数式接口 该接口被定义为只包含一个抽象方法run() 因此它符合函数式接口的设计 如果一个函数满足函数式接口的定义 那么即使不标注为@FunctionInterface 编译器依然会把它看做函数式接口 这有点像@Overried注释 如果你的函数符合重载的要求 无论你是否标注了@Overried 编译器都识别这个重载函数 但一旦你进行了标注 而实际的代码不符合规范 那么就会得到一个编译错误</p><p>这里需要强调的是 函数式接口只能有一个抽象方法 而不是只能有一个方法 这份俩点来说 在java8中 接口运行存在实例方法 比如默认方法 静态方法 其次 如何被java.lang.Object实现的方法 都不能视为抽象方法</p><h3 id="6-2-2-接口默认方法"><a href="#6-2-2-接口默认方法" class="headerlink" title="6.2.2 接口默认方法"></a>6.2.2 接口默认方法</h3><h3 id="6-2-4-方法引用"><a href="#6-2-4-方法引用" class="headerlink" title="6.2.4 方法引用"></a>6.2.4 方法引用</h3><h2 id="6-3-一步一步走入函数式编程"><a href="#6-3-一步一步走入函数式编程" class="headerlink" title="6.3 一步一步走入函数式编程"></a>6.3 一步一步走入函数式编程</h2><blockquote><p>关于这几章其实我在博客中的另外一篇博客 <a href="http://sanshanyoujiu.coding.me/2017/07/23/JAVA8新特性/" target="_blank" rel="noopener">JAVA8新特性总结</a>中已经介绍过了</p></blockquote><h2 id="6-4-并行流与并行排序"><a href="#6-4-并行流与并行排序" class="headerlink" title="6.4 并行流与并行排序"></a>6.4 并行流与并行排序</h2><h3 id="6-4-1-使用并行流过滤数据"><a href="#6-4-1-使用并行流过滤数据" class="headerlink" title="6.4.1 使用并行流过滤数据"></a>6.4.1 使用并行流过滤数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">     public class PrimeUtil &#123;</span><br><span class="line"></span><br><span class="line">    public static boolean isPrime(int number) &#123;</span><br><span class="line">        int  tmp =number;</span><br><span class="line">        if (tmp &lt; 2) &#123;</span><br><span class="line">            return  false;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i=2;Math.sqrt(tmp) &gt;=i;i++) &#123;</span><br><span class="line">            if (tmp % i == 0) &#123;</span><br><span class="line">                return  false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println( IntStream.range(1, 1000000).parallel().filter(PrimeUtil::isPrime).count());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用parallel()方法得到一个并行流 接着 在并行流进行过滤 此时 PrimeUtil.isPrime()会被多线程并发调用 应用于流的所有元素</p><h3 id="6-4-2-从集合得到并行流"><a href="#6-4-2-从集合得到并行流" class="headerlink" title="6.4.2 从集合得到并行流"></a>6.4.2 从集合得到并行流</h3><p>在函数式编程中 我们可以从集合得到一个流或者并行流</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; ss = new AskThread();</span><br><span class="line">double ave=ss.stream().mapToInt(s-&gt;s.score).avarage().getAsDouble();</span><br></pre></td></tr></table></figure><p>在集合对象List中 我们使用stream()方法可以得到一个流 如果希望将这段代码并行化 则可以使用parallelStream()函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double ave=ss.parallelStream().mapToInt(s-&gt;s.score).avarage().getAsDouble();</span><br></pre></td></tr></table></figure><h3 id="6-4-3-并行排序"><a href="#6-4-3-并行排序" class="headerlink" title="6.4.3 并行排序"></a>6.4.3 并行排序</h3><p>除了并行流外 对于普通数组 Java8中也提供了简单的并行功能 比如 对于数组排序 有Arrays.sort()方法 当然这是串行排序 在Java8中也有新增的Arrays.paralleSort()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] arr = new int[10];</span><br><span class="line">Arrays.parallelSort(arr);</span><br></pre></td></tr></table></figure><p>除了并行排序外 Arrays中还增加了一些API用于数组中数据的赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Random r = new Random();</span><br><span class="line">Arrays.setAll(arr, (i) -&gt; r.nextInt());</span><br><span class="line">//并行版本的setAll</span><br><span class="line">Arrays.parallelSetAll(arr, (i) -&gt; r.nextInt());</span><br></pre></td></tr></table></figure><h2 id="6-5-增强的Future：CompletableFuture"><a href="#6-5-增强的Future：CompletableFuture" class="headerlink" title="6.5 增强的Future：CompletableFuture"></a>6.5 增强的Future：CompletableFuture</h2><p>CompleteableFuture是Java8新增的一个超大型工具类 为什么说它大呢 一方面是实现了Future接口 更重要的是实现了CompletionStage接口<br>这个接口含有多达约40种方法 之所以这么多方法 视为了函数式编程的流式调用准备的 通过CompletionStage提供的接口 我们可以在一个执行结果上多次流式调用 以此得到最终结果</p><h3 id="6-5-1-完成了就通知我"><a href="#6-5-1-完成了就通知我" class="headerlink" title="6.5.1 完成了就通知我"></a>6.5.1 完成了就通知我</h3><p>CompletableFutre与Future一样 可以作为函数调用的契约 如果你向CpmpletableFuture请求一个数据 如果数据还没有准备好 请求线程就会等待 而让人惊喜的是 CompletableFuture是可以手动设置完成状态的<br>相关代码请见<a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter6/parallel/AskThread.java" target="_blank" rel="noopener">AskThread.java</a></p><h3 id="6-5-2-异步执行任务"><a href="#6-5-2-异步执行任务" class="headerlink" title="6.5.2 异步执行任务"></a>6.5.2 异步执行任务</h3><p>通过将CCpmletableFuture提供的进一步封装 我们很容易实现Future模式那样的异步调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> public  static Integer calc(Integer para)&#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           //模拟一个长时间的执行</span><br><span class="line">           Thread.sleep(1000);</span><br><span class="line">       &#125; catch (InterruptedException e) &#123;</span><br><span class="line">       &#125;</span><br><span class="line">       return para/2;</span><br><span class="line">   &#125;</span><br><span class="line">public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">       final CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; calc(50));</span><br><span class="line">       System.out.println(future.get());</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>上述代码中 使用了一个CompletableFuture.supplyAsync()方法构造一个CompletableFuture实例 在supplyAsync()函数中 它会在一个新的线程中 执行传入的参数 在这里 它会执行calc()方法 而calc()方法执行是比较慢的 但是这不影响CompletableFuture实例的构造速度 因此supplyAsync()会理解返回 它返回的CompletableFuture对象实例 在supplyAsync()函数中 它会在一个新的线程中 执行传入的参数 但这不影响CompletableFuture实例的构造速度 因此supplyAsync()会立即返回<br>它返回的CompletableFuture对象实例就可以作为这次调用的契约 在将来的任何场合 用于获得最终的计算结果<br>如果当前计算没有完成 则调用get()方法的线程会等待</p><p>在CompletableFuture中 类似的工厂方法有以下几个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier)</span><br><span class="line"></span><br><span class="line">public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier,</span><br><span class="line">                                                   Executor executor)</span><br><span class="line"></span><br><span class="line">public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable,</span><br><span class="line">                                               Executor executor)</span><br><span class="line"></span><br><span class="line">public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable,</span><br><span class="line">                                               Executor executor)</span><br><span class="line">​```       </span><br><span class="line">其中supplyAsync()方法用于那些需要有返回值的场景 比如计算某个数据等 而runAsync()方法用于没有返回值的场景 比如 仅仅是简单地执行一个异步任务</span><br><span class="line"></span><br><span class="line">在这俩个方法中 都有一个方法可以接受Executor参数 这就使我们可以让Suppilier&lt;U&gt;或者Runnable在指定的线程池中工作 如果不指定 则在默认的系统公共的ForkJoinPool.common线程池中执行</span><br><span class="line">                                                   </span><br><span class="line">&gt;注意 在Java8中 新增了ForkJoinPool.commonPool()方法 它可以获得一个公共的ForkJoin线程池 这个公共的线程池中的所有线程都是Daemon线程 这意味着如果主线程退出 这些线程无论是否执行完毕 都会退出系统 </span><br><span class="line"></span><br><span class="line">### 6.5.3 流式调用</span><br><span class="line">​```java</span><br><span class="line">  public  static Integer calc(Integer para)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //模拟一个长时间的执行</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        return para/2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">   CompletableFuture&lt;Void&gt; fu = CompletableFuture.supplyAsync(() -&gt; calc(50)).thenApply((i) -&gt; Integer.toString(i))</span><br><span class="line">                .thenApply((str)-&gt;&quot;\&quot;&quot;+str+&quot;\&quot;&quot;)</span><br><span class="line">                .thenAccept(System.out::println);</span><br><span class="line">        fu.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中 使用supplyAsync()函数执行一个异步任务 接着连续使用流式调用对任务的处理结果进行再加工 直到最后结果输出</p><h3 id="6-5-4-CompletableFuture中的异常处理"><a href="#6-5-4-CompletableFuture中的异常处理" class="headerlink" title="6.5.4 CompletableFuture中的异常处理"></a>6.5.4 CompletableFuture中的异常处理</h3><p>CompletableFuture提供了一个异常处理方法execptionally();</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  public  static Integer calc(Integer para)&#123;</span><br><span class="line">        return para/0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">         CompletableFuture&lt;Void&gt; fu = CompletableFuture.supplyAsync(() -&gt; calc(50))</span><br><span class="line">                .exceptionally(ex-&gt;&#123;</span><br><span class="line">                    System.out.println(ex.toString());</span><br><span class="line">                    return 0;</span><br><span class="line">                &#125;)</span><br><span class="line">                .thenApply((i) -&gt; Integer.toString(i))</span><br><span class="line">                .thenApply((str)-&gt;&quot;\&quot;&quot;+str+&quot;\&quot;&quot;)</span><br><span class="line">                .thenAccept(System.out::println);</span><br><span class="line">        fu.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中 第8行对当前的CompletableFuture进行异常处理 如果没有异常发生 则CompletableFuture就会返回原有的结果 如果遇到了异常 就可以在exceptionally()中处理异常 并返回一个默认的值</p><h3 id="6-5-5-组合多个CompletableFuture"><a href="#6-5-5-组合多个CompletableFuture" class="headerlink" title="6.5.5 组合多个CompletableFuture"></a>6.5.5 组合多个CompletableFuture</h3><p>CompletableFuture还允许你将多个CompletableFuture进行组合 一种方法是使用thenCompose()</p><p>一个CompletableFuture可以在执行完成后 将执行结果通过Function传递给下一个CompletionStage进行处理(Function接口返回新的CompletionStage实例)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public  static Integer calc(Integer para)&#123;</span><br><span class="line">        return para/2;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        CompletableFuture&lt;Void&gt; fu = CompletableFuture.supplyAsync(() -&gt; calc(50))</span><br><span class="line">                .thenCompose((i) -&gt; CompletableFuture.supplyAsync(() -&gt; calc(i)))</span><br><span class="line">                .thenApply((str) -&gt; &quot;\&quot;&quot; + str + &quot;\&quot;&quot;)</span><br><span class="line">                .thenAccept(System.out::println);</span><br><span class="line">        fu.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一种组合多个CompletableFuture的方法是thenCombine()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public  static Integer calc(Integer para)&#123;</span><br><span class="line">        return para/2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">      CompletableFuture&lt;Integer&gt; intFuture =CompletableFuture.supplyAsync(()-&gt;calc(50));</span><br><span class="line">        CompletableFuture&lt;Integer&gt; intFuture2 =CompletableFuture.supplyAsync(()-&gt;calc(25));</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Void&gt; fu =intFuture.thenCombine(intFuture2,(i,j)-&gt;(i+j)).thenApply((str)-&gt;&quot;\&quot;&quot;+str+&quot;\&quot;&quot;)</span><br><span class="line">                .thenAccept(System.out::println);</span><br><span class="line">        fu.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中 首先生成俩个CompletableFuture实例 接着使用thenCombine（）组合将这俩个CompletableFuture 将这俩者的执行结果进行累加 并将其累加结果转换为字符串</p><h2 id="6-6-读写锁的改进：StampedLock"><a href="#6-6-读写锁的改进：StampedLock" class="headerlink" title="6.6 读写锁的改进：StampedLock"></a>6.6 读写锁的改进：StampedLock</h2><p>StampedLock是java8引入的一种新的锁机制 简单的理解 可以认为它是读写锁的一个改进版本 读写锁虽然分离了读与写 使得读与读之间可以完全并发 但是 读和写之间依然是冲突的 读锁会完全阻塞写锁 它使用的依然是悲观的锁策略 如果有大量的读线程 也有可能会引起写线程的“饥饿”<br>而StampedLock是一种乐观的读策略 这种乐观的锁非常类似无锁的操作 使得乐观锁完全不会阻塞写线程</p><h3 id="6-6-1-StampedLock使用示例"><a href="#6-6-1-StampedLock使用示例" class="headerlink" title="6.6.1 StampedLock使用示例"></a>6.6.1 StampedLock使用示例</h3><p>相关代码请见<a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter6/parallel/Point.java" target="_blank" rel="noopener">Point.java</a></p><p>在上述代码中 使用了StampedLock.trtOptimisticRead()方法 这个方法表示试图尝试一次乐观锁 它会返回一个类似于时间戳的邮戳整数stamp 这个stamp就可以作为这一次锁获取的凭证<br>其中有一个validate()方法 这个方法用来判断这个stamp是否在读过程发生期间被修改过 如果stamp没有被修改过 则认为这次读取是有效的 就可以进行数据处理 反之 如果stamp不可用 则意味着在读取的过程中 可能被其他线程改写了数据 因此 有可能出现脏读 如果出现这种情况 我们可以像处理CAS操作那样在一个死循环中一直使用乐观锁 直到成功为止<br>也可以升级锁的级别 在本例中 就升级为了悲观锁 如果当前对象正被修改 读操作就会导致线程被挂起</p><p>可以看到 StampedLock通过引入乐观锁来增加系统的并行度</p><h3 id="6-6-2-StampedLock的小陷阱"><a href="#6-6-2-StampedLock的小陷阱" class="headerlink" title="6.6.2 StampedLock的小陷阱"></a>6.6.2 StampedLock的小陷阱</h3><p>StampedLock内部实现时 使用类似CAS操作的死循环反复尝试的策略<br>在它挂起线程时 使用的是Unsafe.park()函数 而park()函数在遇到线程中断时 会直接返回（注意，不同于Thread.sleep()它不会直接抛出异常)<br>而在StampedLock的死循环逻辑中 没有处理有关中断的逻辑 因此 这就会导致阻塞在park()上的线程被中断后 会再次进入循环 而当退出条件得不到满足时 就会发生疯狂占用CPU的情况 这一点值得注意<br>下面的例子演示了这个问题<br><a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter6/parallel/StampedLockDemo.java" target="_blank" rel="noopener">StampedLockCPUDemo.java</a></p><h3 id="6-6-3-有关StampedLock的实现思想"><a href="#6-6-3-有关StampedLock的实现思想" class="headerlink" title="6.6.3 有关StampedLock的实现思想"></a>6.6.3 有关StampedLock的实现思想</h3><p>StampedLock的内部实现是基于CLH锁的 CLH锁是一种自旋锁 它保证没有饥饿发生 并且可以保证FIFO(First-In-First-Out)的服务顺序</p><p>CLH锁的基本思想如下：<br>锁维护一个等待线程队列 所有申请锁 但是没有成功的线程都记录在这个队列中 每一个节点(一个节点代表一个线程) ,保存一个标志位(Locked),用于判断当前线程是否已经释放锁</p><p>当一个线程试图获得锁，取得当前等待队列的尾部结点作为其前序节点 并使用类似如下代码判断前序节点是否已经成功释放锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while(pred.locked)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要前序节点(pred)没有释放锁 则表示当前线程还不能继续运行 因此会自旋等待<br>反之 如果前序线程已经释放锁 则当前线程可以继续执行<br>释放锁时 也遵循这个逻辑 线程会将自身节点的locked位置标记为false 那么后续等待的线程就能继续执行了</p><p>StampedLock正是基于这种思想 但是实现上更为复杂<br>在StampedLock内部 会维护一个等待链表队列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static final class WNode &#123;</span><br><span class="line">    volatile WNode prev;</span><br><span class="line">    volatile WNode next;</span><br><span class="line">    volatile WNode cowait;    // list of linked readers</span><br><span class="line">    volatile Thread thread;   // non-null while possibly parked</span><br><span class="line">    volatile int status;      // 0, WAITING, or CANCELLED</span><br><span class="line">    final int mode;           // RMODE or WMODE</span><br><span class="line">    WNode(int m, WNode p) &#123; mode = m; prev = p; &#125;</span><br><span class="line">&#125;</span><br><span class="line">/** Head of CLH queue */</span><br><span class="line">private transient volatile WNode whead;</span><br><span class="line">/** Tail (last) of CLH queue */</span><br><span class="line">private transient volatile WNode wtail;</span><br></pre></td></tr></table></figure><p>上述代码中 WNode为链表的基本元素 每一个WNode表示一个等待线程 字段whead和wtail分别指向等待链表的头部和尾部</p><p>另外一个很重要的字段state</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/** Lock sequence/state */</span><br><span class="line">private transient volatile long state;</span><br></pre></td></tr></table></figure><p>字段state表示当前锁的状态 它是一个long型 有64位 其中 倒数第8位表示写锁状态 如果该位为1 表示当前由写锁占领</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public long tryOptimisticRead() &#123;</span><br><span class="line">     long s;</span><br><span class="line">     return (((s = state) &amp; WBIT) == 0L) ? (s &amp; SBITS) : 0L;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>一次成功的乐观锁必须保证当前锁没有写锁占用 其中WBIT用来获取写锁状态位 值为0X80 如果成功 则返回当前state的值（末尾7位清零，末尾7位表示当前正在读取的线程数量）<br>如果在乐观锁读后 有线程申请了写锁 那么state的状态就会改变</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public long writeLock() &#123;</span><br><span class="line">      long s, next;  // bypass acquireWrite in fully unlocked case only</span><br><span class="line">      return ((((s = state) &amp; ABITS) == 0L &amp;&amp;</span><br><span class="line">               U.compareAndSwapLong(this, STATE, s, next = s + WBIT)) ?</span><br><span class="line">              next : acquireWrite(false, 0L));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上述代码第4行 设置写锁位为1（通过加上WBIT（0x80）) 这样 就会改变state的取值 那么在乐观锁确认时（validate）时 就会发现这个改动 导致乐观锁失效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public boolean validate(long stamp) &#123;</span><br><span class="line">     U.loadFence();</span><br><span class="line">     return (stamp &amp; SBITS) == (state &amp; SBITS);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上述validate()函数比较当前stamp和发生乐观锁时取得的stamp，如果不一致 则宣告乐观锁失败</p><p>乐观锁失败后 可以提高锁级别 升级为悲观锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public long readLock() &#123;</span><br><span class="line">      long s = state, next;  // bypass acquireRead on common uncontended case</span><br><span class="line">      return ((whead == wtail &amp;&amp; (s &amp; ABITS) &lt; RFULL &amp;&amp;</span><br><span class="line">               U.compareAndSwapLong(this, STATE, s, next = s + RUNIT)) ?</span><br><span class="line">              next : acquireRead(false, 0L));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>悲观锁会尝试设置state状态（第4行） 它会将state加1（前提是读线程数量没有溢出，对于读线程数量溢出的情况 会使用辅助的readerOverflow进行统计 这里不讨论）用于统计线程的数量 如果失败 则进入acquireRead（）二次尝试锁获取</p><p>在acquireRead()中 线程会在不同条件下进行若干次自旋 试图通过CAS操作获得锁 如果自旋宣告失败 则会启用CLH队列 将自己加入到队列中 之后再启用自旋 如果发现自己成功获得了读锁 则会进一步把自己cowait队列中的读线程全部激活(使用Unsafe.unpark()方法) 如果最终依然无法成功获得读锁 则会使用Unsafe.park()方法挂起当前线程<br>方法acquireWrite()和acquireRead()也非常类似 也是通过自旋尝试 加入等待队列 直至最终Unsafe.park()方法挂起线程的逻辑进行的 释放锁时与加锁动作想法 以unlockWrite()为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void unlockWrite(long stamp) &#123;</span><br><span class="line">       WNode h;</span><br><span class="line">       if (state != stamp || (stamp &amp; WBIT) == 0L)</span><br><span class="line">           throw new IllegalMonitorStateException();</span><br><span class="line">       state = (stamp += WBIT) == 0L ? ORIGIN : stamp;</span><br><span class="line">       if ((h = whead) != null &amp;&amp; h.status != 0)</span><br><span class="line">           release(h);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>上述代码第5行 将写标识位清理 如果state发生溢出 则退回到初始值<br>接着 如果等待队列不为空 则从等待队列中激活一个线程（绝大多数情况下是第一个等待线程）继续执行（第7行）</p><h2 id="6-7-原子类的增强"><a href="#6-7-原子类的增强" class="headerlink" title="6.7 原子类的增强"></a>6.7 原子类的增强</h2><h3 id="6-7-1-更快的原子类"><a href="#6-7-1-更快的原子类" class="headerlink" title="6.7.1 更快的原子类"></a>6.7.1 更快的原子类</h3><p>在AtomicInteger类中 它们都是在一个死循环中 不断尝试修改目标值 直到修改成功 如果竞争不激烈的情况下 修改成功率很高 否则 修改失败的概率就会很高 在大量修改失败时 这些原子操作就会进行多次循环尝试 因此性能就会受到影响</p><p>那么当竞争激烈的时候 有一种方案可以使用热点分离 将竞争的数据进行分解 提高系统的性能 基于这种思路 虽然CAS操作中没有锁 但是像减小锁粒度这种分离热点的思想依然可以使用<br>一种可行的方案就是仿造ConcurrentHashMap 将热点数据分离 比如 可以将AtomicInteger的内部核心数据value分离成一个数组 每个线程访问时 通过哈希等算法映射到其中一个数字进行计数 而最终的计算结果 则为这个数组的求和累加<br>而LongAddrer正是使用了这种思想</p><p>在实际的操作中 LongAdder并不会一开始就动用数组进行处理 而是将所有数据都先记录在一个称为base的变量中 如果在多线程条件下 大家修改base都没有冲突 那么也没有必要扩展为cell数组 但是一旦发现base修改发生冲突 就会初始化cell数组 使用新的策略 如果使用cell数组更新后 发现某一个cell上的更新依然发生冲突 那么系统就会尝试创新的cell 或者将cell的数量加倍 以减少冲突的可能</p><p>简单的分析一个increment（）方法的内部实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void increment() &#123;</span><br><span class="line">       add(1L);</span><br><span class="line">   &#125;</span><br><span class="line">public void add(long x) &#123;</span><br><span class="line">       Cell[] as; long b, v; int m; Cell a;</span><br><span class="line">       if ((as = cells) != null || !casBase(b = base, b + x)) &#123;</span><br><span class="line">           boolean uncontended = true;</span><br><span class="line">           if (as == null || (m = as.length - 1) &lt; 0 ||</span><br><span class="line">               (a = as[getProbe() &amp; m]) == null ||</span><br><span class="line">               !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class="line">               longAccumulate(x, null, uncontended);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>它的核心是第4行的add()方法 最开始cells为null 因此数据会向base增加 但是如果对base的操作冲突 则会进入第7行 并设置冲突标记uncontended为true 接着<br>如果判断cells数组不可用 或者当前线程对应的cell为null 则直接进入longAccumulate（)方法 否则会尝试使用CAS方法更新对应的cell数据 如果成功 则退出 失败则进入longAccumulate()方法</p><p>longAccumulate()方法比较复杂 其大致内容为根据需要创建新的cell或者对cell数组进行扩容 以减少冲突</p><p>下面进行一个例子简单的对LongAdder，原子类以及同步锁进行性能测试 测试方法是使用多个线程对同一个整数进行累加 观察使用3种不同方法所消耗的时间<br><a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter6/parallel/LongAdderDemo.java" target="_blank" rel="noopener">LongAdderDemo.java</a></p><p>这本书说的是LongAdder的表现最好 但是可能是因为我是i5的cpu只有双核 速度表现并不理想 最好的是原子类<br>LongAdder的另外一个优化手段就是避免了伪共享 在第5章有有关伪共享的问题 但是 需要注意的是 LongAdder中并不是直接使用padding这种看起来比较碍眼的做法 而是引入了一种新的注释<a href="mailto:&#39;@sun.misc.Contended" target="_blank" rel="noopener">&#39;@sun.misc.Contended</a>‘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@sun.misc.Contended static final class Cell &#123;</span><br><span class="line">      volatile long value;</span><br><span class="line">      Cell(long x) &#123; value = x; &#125;</span><br><span class="line">      final boolean cas(long cmp, long val) &#123;</span><br><span class="line">          return UNSAFE.compareAndSwapLong(this, valueOffset, cmp, val);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // Unsafe mechanics</span><br><span class="line">      private static final sun.misc.Unsafe UNSAFE;</span><br><span class="line">      private static final long valueOffset;</span><br><span class="line">      static &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">              UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">              Class&lt;?&gt; ak = Cell.class;</span><br><span class="line">              valueOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                  (ak.getDeclaredField(&quot;value&quot;));</span><br><span class="line">          &#125; catch (Exception e) &#123;</span><br><span class="line">              throw new Error(e);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以看到 在上述代码第一行申明了Cell类为sun.misc.Contended 这将会使得Java虚拟机自动为Cell解决伪共享问题<br>当然 在我们的代码中也可以使用sun.misc.Contened来解决伪共享问题 但是需要额外使用虚拟机参数-XX:-RestrictConteded 否则 这个注释将被忽略</p><h3 id="6-7-2-LongAdder的功能增强版：LongAccumulator"><a href="#6-7-2-LongAdder的功能增强版：LongAccumulator" class="headerlink" title="6.7.2 LongAdder的功能增强版：LongAccumulator"></a>6.7.2 LongAdder的功能增强版：LongAccumulator</h3><p>LongAccumulator是LongAdder的亲兄弟 它们有公共的Striped64 因此 LongAccumulator的内部的优化方式和LongAdder是一样的 它们都有一个long型的整数进行分割 存储在不同的变量中 以防止多线程竞争 俩者的主要逻辑是类似的 但是LongAccumulator是LongAdder的功能扩展 对于LongAdder来说 它只是每次对给定的整数执行一次加法 而LongAccumulator则可以用任意函数操作</p><p>可以使用下面的构造函数创建一个LongAccumulator实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public LongAccumulator(LongBinaryOperator accumulatorFunction,</span><br><span class="line">                       long identity)</span><br></pre></td></tr></table></figure><p>第一个参数accumulatorFunction就是需要执行的二元函数（接受俩个long行参数并返回long），第二个参数是初始值<br>下面那个例子展示了LongAccumulator的使用 它将通过多线程访问若干个整数 并返回遇到的最大的那个数字</p><p>相关代码请见<a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter6/parallel/LongAccumulatorDemo.java" target="_blank" rel="noopener">LongAccumulatorDemo.java</a></p><p>在上述代码中 构造了LongAccumulator实例 并且过滤了最大值 因此传入Long::max函数句柄 当有数据通过accumulate()方法传入LongAccumulator后 LongAccumulator会通过Long::max识别最大值并且保存在内部 在第24行 通过longValue()函数对所有的cell进行了Long::max操作 得到最大值</p><h1 id="第7章-使用AKKA构建高并发程序"><a href="#第7章-使用AKKA构建高并发程序" class="headerlink" title="第7章 使用AKKA构建高并发程序"></a>第7章 使用AKKA构建高并发程序</h1><p>写出一个高并发并且可扩展的应用是很难的 那么是否有一个好的框架可以帮助我们轻松构建这么一个应用呢 Akka提供了这么一个方式 Akka是遵循Apache2许可的开源人员 这意味你可以无偿并且几乎没有限制的使用它 包括应用商业环境</p><p>Akka是使用scala创建的 但是Scala和java一样 都是jvm上的内容 都可以互相调用 但是实际使用中 还是推荐使用Scala来进行Akka的编写</p><p>Akka提供了一种Actor的并发模型 其粒度比线程更小 可以在代码中启用极其大量的Actor</p><p>其次 Akka中提供了一套容错机制 运行在Actor出现异常时进行一些恢复或者重置操作</p><p>最后 通过Akka不仅可以在单机上构建高并发程序 也可以在网络上构建分布式程序<br>并提供位置透明的Actor定位服务</p><h2 id="7-1-新并发模型-Actor"><a href="#7-1-新并发模型-Actor" class="headerlink" title="7.1 新并发模型:Actor"></a>7.1 新并发模型:Actor</h2><p>在使用Akka中 基本就可以忘记线程了 当你使用Akka时 就有了一个全新的执行单元-Actor<br>Actor可以比喻为一个人 多个人之间可以通过语言交流</p><p>传统Java并行程序 还是完全基于对象的方法 我们还是通过对象的方法调用进行信息的传递 这时 如果对象的方法会修改对象本身的状态 那么在多线程情况下 就有可能出现对象状态的不一致 所以我们就必须对这类方法调用进行同步 当然 同步往往是以牺牲性能为代价的</p><p>在Actor模型中 我们失去了对象的方法调用 我们不是通过调用Actor对象的某一个方法来告诉Actor你需要做什么 而是给Actor发生一条消息 当一个Actor收到消息后 它有可能会根据消息的内容做出某些行为 包括更改自身状态 但是 在这种情况下 这个状态的更改是Actor自己进行的 并不是由外界强迫进行的</p><h2 id="7-2-Akka之Hello-World"><a href="#7-2-Akka之Hello-World" class="headerlink" title="7.2 Akka之Hello World"></a>7.2 Akka之Hello World</h2><p>一个Acotr的实现<br><a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter7/Helloworld/Greeter.java" target="_blank" rel="noopener">Greeter.java</a><br><a href="https://github.com/SanShanYouJiu/CodeCollection/tree/master/Java高并发程序设计/javaHighConcurrentDesign/chapter7/Helloworld" target="_blank" rel="noopener">HelloWorld.java</a></p><p>上述代码中 定义了一个换一种Greeter 继承自UntypedActor（它自然是Akka中的核心成员了） UntypedActor就是我们说的Actor 之所以说是无类型 是因为还有一种有类型 有类型的Actor可以使用系统中的 其他类型构造 可以缓解Java单继承的问题 因为你在继承UntypedActor后 就不能再继承系统中其他类了 如果你一定想这么做 那么就只能选择有类型的Actor 否则UntypedActor就是你的首选</p><p>在HelloWorld.java中又实现了一个HelloWorld的Actor 其中的preStart()方法为Akka的回调方法 在Actor启动前 会在Akka框架调用，完成一些初始化的工作<br>在这里 由于创建Greeter时使用的是HelloWorld的上下文 因此 它属于HelloWorld的子Actor<br>onReceive()函数是为HelloWorld的消息处理函数</p><p>主函数如下：<br><a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter7/Helloworld/HelloMainSimple.java" target="_blank" rel="noopener">HelloWorldMain.java</a><br>在主函数中 创建了ActorSystem 表示管理和维护Actor的系统 一般来说 一个应用程序只需要一个ActorSystem就够用了 ActorSystem.create()的第一个参数‘hello’为系统名称 第2个参数为配置文件<br>通过AcotorSystem创建一个顶级的Acotor(HelloWorld)</p><p>可以看到 当使用Actor的时候 关注点已经不在线程上了 实际上 线程调度已经被Akka框架进行了封装 只需关注Actor对象即可 而Actor对象之间的交流和普通对象的函数调用有明显区别 它们是通过显示的消息发送来传递消息的</p><p>当系统有多个Actor存在时 Akka会自动在线程池中选择线程来执行我们的Actor 因此 当多个不同的Actor可能被同一个线程执行 同时 一个Actor也有可能被不同线程执行 因此 一个值得注意的地方是：不要在一个Actor中执行耗时的代码 这样可能会导致其他Actor的调度出现问题</p><h2 id="7-3-有关消息投递的一些说明"><a href="#7-3-有关消息投递的一些说明" class="headerlink" title="7.3 有关消息投递的一些说明"></a>7.3 有关消息投递的一些说明</h2><p>整个Akka应用是由消息驱动的 消息是除了Actor之外最重要的核心组件 作为在并发程序中的核心组件 在Actor之间传递应该满足不变性 也就是不变模式 因为可变模式无法高效的在并发环境使用 理论上Akka的消息可以使用任何对象实例 但实际使用中 强烈推荐使用不可变模式</p><p>实际上 对于消息投递 可以有3种不同的策略</p><ul><li>第一种 称为最多一次传递 每条消息最多投递一次 在这种情况 偶尔会有投递失败 从而导致消息丢失</li><li>第二种 称为最少一次投递 每一条消息至少会被投递一次 直到成功为止 在一些偶然的场合 接受者可能会受到重复的消息 但不会发生消息丢失</li><li>第三种 称为精准的消息传递，也就是所有的消息精准地投递并成功接收一次 既不会有丢失 也不会重复接收<br>很明显 第一种性能最好 第二种其次 第三种 成本最高 最难以实现</li></ul><p>那么是否真的需要保证消息投递的可靠性呢<br>答案是否定的 实际上 我们没有必要在Akka层保证消息的可靠性 这样做 成本太高了 也是没有必要的 消息的可靠性更应该在应用的业务层去维护 因为也许在有些时候 丢失一些消息完全是符合应用要求的 因此在使用Akka时 需要在业务层对此进行保证</p><p>此外 对于消息投递Akka可以在一定程度上保证顺序性 比如Actor A1向A2顺序发送M1，M2和M3三条消息 Actor A3向A2顺序发送了M4，M5和M6三条消息</p><ol><li>如果M1没有丢失 那它一定先于M2和M3被A2收到</li><li>如果M2没有丢失 那它一定先于M3被A2收到</li><li>如果M4没有丢失 那它一定先于M5和M6被A2收到</li><li>如果M5没有丢失 那它一定先于M6被A2收到</li><li>对A2来说 来自A1和A3的消息可能交织在一起 没有顺序保证</li></ol><p>在这里 值得注意的一点是，这种消息投递规则不具备可传递性 比如：<br>Actor A向C发生M1，接着Actor A向B发送了M2，B将M2转发给Actor C那么在这种情况下 C收到M1和M2的先后顺序是没有保证的</p><h2 id="7-4-Actor的生命周期"><a href="#7-4-Actor的生命周期" class="headerlink" title="7.4 Actor的生命周期"></a>7.4 Actor的生命周期</h2><p>一个Actor在actorOf()函数被调用后开始建立 Actor实例创建后 会回调preStart()方法 在这个方法里面 可以进行一些资源的初始化工作 在Actor的工作过程中 可能会出现一些异常 这种情况下 Actor会重启 当Actor被重启时 会回调preRestart()方法 （在老的实例上）接着系统会创建一个新的Actor对象实例（虽然是新的实例，但它们都表示同一个Actor）当新的Actor实例创建后 会回调postRestart()方法 表示启动完成 同时新的实例将会代替旧的实例 停止一个Actor也有很多方式 你可以调用Stop()方法或者给Actor发送一个PosionPill Actor停止后 postStop()方法会被调用 同时这个Actor的监听者会受到一个Terminated消息</p><p>下面是一个既带有生命周期回调函数的Actor<br><a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter7/liftcycle/MyWorker.java" target="_blank" rel="noopener">MyWorker.java</a><br>另外为MyWoker指定了一个监听者<br><a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter7/liftcycle/WatchActor.java" target="_blank" rel="noopener">WatcherActor.java</a><br>本质上，它也是一个Actor 但不同的是 它会在它的上下文中watch一个Actor 如果将来这个被监视的Actor的退出终止 WatchActor就能收到一条Terminated消息 在这里 我们将简单地打印终止消息Terminated的相关Actor路径 并且关闭整个ActorSystem</p><p>主函数如下<br><a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter7/liftcycle/DeadMain.java" target="_blank" rel="noopener">DeadMain.java</a><br>注意在创建WatchActor的时候 第一个参数为要创建的Actor类型 第2个参数为这个Actor的构造函数的参数(在这里 就是要调用WatchActor的构造函数)</p><h2 id="7-5-监督策略"><a href="#7-5-监督策略" class="headerlink" title="7.5 监督策略"></a>7.5 监督策略</h2><p>如果一个Actor在执行过程中发生意外 比如没有处理某些异常 导致出错 那么这个时候该怎么办<br>对于这种情况 Akka框架给予了我们足够的控制权 在Akka框架内 父Actor可以对子Actor进行监督 监控Actor的行为是否有异常 大体上 监督策略可以分为俩种 一种是OneForOneStrategy的监督 另外一种是AllForOneStrategy</p><p>对于OneForOneStrategy的策略 父Actor只会对出问题的子Actor进行处理 比如重启或者停止 而对于AllForOneStrategy 父Actor会对出问题的子Actor以及它所有的兄弟类进行处理 很显然 对于AllForStrategy策略 它更适合对各个Actor联系紧密的场景 如果多个Actor间只要一个Actor出现故障 则宣告整个任务的失败 就比较适合使用AllForStrategy 否则 在更多的场景中 应该使用OneForOneStrategy<br>当然 这也是Akka中的默认策略</p><p>要指定这些监督行为 只要构造一个自定义的监督策略即可<br>首先定义一个父Actor 它作为所有子Actor的监督者<br><a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter7/supervisor/Supervisor.java" target="_blank" rel="noopener">Supervisor.java</a><br>上述代码 定义了一个OneForOneStrategy监督策略 在这个策略中 运行Actor在遇到错误后 在1分钟内进行3次重试 如果超过这个频率 那么就会直接杀死actor</p><p>32-34行覆盖父类的supervisorStrategy()方法 设置使用自定义的监督策略<br>第39行用来新建一个名为restartActor的子Actor 这个子Actor就由当前的supervisor进行监督 当Supervisor接受一个Props对象时 就会更加这个Props配置生成一个restartActor</p><p>RestartActor的实现如下<br><a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter7/supervisor/RestartActor.java" target="_blank" rel="noopener">RestartActor.java</a><br>定义了一些Actor的生命周期的回调接口 目的是更好的观察Actor的活动情况 在32-34行模拟了一些异常情况 第42行会抛出NullPointerException 而44行会抛出ArithmeticException</p><p>在主函数里面有一点要进行说明 就是49-53行 向Restart发送了100条RESTART信息 这会使得RestartActor抛出NullPointerException</p><p>这里粘贴一部分的输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">preStart hashcode:1062883844</span><br><span class="line">meet NullPointerException,restart</span><br><span class="line">preReStart hashcode:1062883844</span><br><span class="line">preStart hashcode:1915158180</span><br><span class="line">postRestart hashcode:1915158180</span><br></pre></td></tr></table></figure><p>第一行preStart表示RestartActor正在初始化 注意hashcode为1062883844<br>接着遇到了NullPointerException 根据自定义的策略 这将导致它重启<br>因此 就有了preRestart 因为preRestart在正是重启之前调用 因此HashCode还是1062883844 表示当前Actor和上一个Actor还是同一个实例<br>接着就进入了preStart hashcode已经变为了1915158180 说明已经不是一个实例 系统已经为这个RestartActor生成了新的实例 原有的实例因为重启已经被回收 这说明同一个RestartActor在系统的工作始终 未必能保持同一个实例 重启完成后 调用postRestart（）方法<br>实际上 Actor重启后的preStart()方法 就是在postRestart()中调用的(Actor父类的postRestart（）会调用preStart()方法）</p><h2 id="7-6-选择Actor"><a href="#7-6-选择Actor" class="headerlink" title="7.6 选择Actor"></a>7.6 选择Actor</h2><p>在一个ActorSystem中 可能存在大量的Actor 如何才能有效地对大量Actor进行批量管理和通信呢 Akka为我们提供了一个ActorSelection类 用来批量进行消息发送</p><p>下面只写示意代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0;i&lt;WORDER_COUNT;i++)&#123;</span><br><span class="line"> workers.add(system.actorOf(Props.create(MyWorker.class,i),&quot;worker_&quot;+i);</span><br><span class="line">&#125;</span><br><span class="line">ActorSelection selection=getContext().actorSelection(&quot;/user/worker_*&quot;);</span><br><span class="line">selection.tell(5,getSelf());</span><br></pre></td></tr></table></figure><p>上述代码 批量生成了大量Actor 接着 我们要给这些worker发送信息 通过actorSelection()方法提供的选择通配符 可以得到代表所有满足条件的ActorSelection 最后通过这个ActorSelection实例 便可以向所有worker Actor发送消息</p><h2 id="7-7-消息收件箱（Inbox"><a href="#7-7-消息收件箱（Inbox" class="headerlink" title="7.7. 消息收件箱（Inbox)"></a>7.7. 消息收件箱（Inbox)</h2><p>我们知道 所有Actor之间的通信都是通过消息来进行的 这是否意味着我们必须构建一个Actor来控制整个系统呢 不一定需要这么做 Akka框架已经为我们准备了一个叫做‘收件箱’的组件 使用收件箱 可以很方便地对Actor进行消息发送和接收 大大方便了应用程序与Actor之间的交互</p><p><a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter7/inbox/MyWorker.java" target="_blank" rel="noopener">MyWorker.java</a></p><p>在上述代码中 与这个MyWorker Actor交互的 并不是一个Actor 而是一个邮箱 邮箱的使用很简单 在上述代码中 根据ActorSystem绑定了一个Inbox 接着使用邮箱监视MyWorker 这样就能在MyWoker停止后得到一个消息通知 在45-47行 通过邮箱向MyWoker发送消息<br>第48到59行 进行消息接受 如果发现MyWorker已经停止工作 则关闭整个ActorSystem</p><h2 id="7-8-消息路由"><a href="#7-8-消息路由" class="headerlink" title="7.8 消息路由"></a>7.8 消息路由</h2><p>Akka提供了非常灵活的消息发送机制 有时候 我们也许会使用一组Actor而不是一个Actor来提供一项服务 这一组Actor组中的所有Actor都是对等的 也就是说你可以找任何一个Actor来为你服务 在这种情况下 为了快速有效的找到合适的Actor 或者说如何更为合理调度这些消息 才可以使负载均衡地分配在这一组Actor</p><p>为了解决这个问题 Akka使用了一个路由器组件（Router)来封装消息的调度 系统提供了几种消息路由策略 比如 轮训选择Actor进行消息发送<br>随机消息发送 将消息发送给最为空闲的Actor 甚至在组内广播消息</p><p><a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter7/route/WatchActor.java" target="_blank" rel="noopener">WatchActor.java</a><br>在上面的代码中定义了路由器组件Router 在构造Router时 需要指定路由策略和一组被路由的Actor(Routee) 这里使用了RoundRobinRoutingLogic路由策略 也就是对所有的Routee进行轮询消息发送 在本例中 Routee是由5个MyWorker Actor构成</p><p>当有消息需要传递给这5个MyWorker时 只需要将消息投递给这个Router即可 Router就会根据给定的消息路由策略进行消息投递 当一个MyWorker停止工作时 还可以简单地从其将工作组移出 在这里 如果发现没有可用的Actor 就会直接关闭系统</p><p>主函数如下：<br><a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter7/route/RouteMain.java" target="_blank" rel="noopener">RouteMain.java</a></p><p>除了RoundRobinRoutingLogic外 还可以尝试BroadcastRoutingLogic广播策略 RandomRoutingLogic随机投递策略 ，SmallestMailBoxRoutingLogic空闲Actor优先投递策略</p><h2 id="7-9-Actor的内置状态转换"><a href="#7-9-Actor的内置状态转换" class="headerlink" title="7.9 Actor的内置状态转换"></a>7.9 Actor的内置状态转换</h2><p>在很多场景下 Actor的业务逻辑可能比较复杂<br>Actor可能需要根据不同的状态对同一条消息作出不同的处理 Akka已经为我们考虑到了这一点<br>一个Actor内部消息处理函数可以拥有多个不同的状态 在特定的状态下 可以对同一消息进行不同的处理 状态之间也可以任意切换</p><p>下面模拟一个婴儿作为例子<br><a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter7/Baby/BabyActor.java" target="_blank" rel="noopener">BabyActor.java</a><br>在上述代码中 使用了become()方法用于切换Actor的状态 方法become()接受一个Procedure参数 Procedure在这里可以表示一种Actor的状态 同时 更重要的是它封装了在这种状态下的消息处理逻辑</p><p>在上面这个例子中 定义了俩种Prodcedure 一种是angry 另外一个是happy<br>在初始状态下 BabyActor没有开心也没有生气 因此angry处理函数和happy处理函数都不会工作 当BabyActor接受到消息时 会用onReceive()方法来处理这个消息</p><p>在onReceive（）函数中 当处理SLEEP消息时 就会切换当前Actor为angry 如果是play消息 则切换状态为happy</p><p>一旦完成状态切换 当后续有新的消息送达时 就不会再由onReceive()处理了 由于angry和happy都是消息处理函数 因此 后续的消息就直接交由当前状态处理 从而很好地封装了Actor的多个不同处理逻辑</p><p>由此可见 Akka为Actor提供了灵活的状态切换机制 处于不同状态的Actor可以绑定不同的消息处理函数进行消息处理<br>这对构造结构化应用有着重要的帮助</p><h2 id="7-10-询问模式：Actor中的Future"><a href="#7-10-询问模式：Actor中的Future" class="headerlink" title="7.10 询问模式：Actor中的Future"></a>7.10 询问模式：Actor中的Future</h2><p>由于Actor之间都是异步消息通信的 当你发送一条消息给一个Actor后 你通常只能等待Actor的返回 与 与同步方法不同 在你发送异步消息后 接受消息的Actor 可能还根本来不及处理你的消息 而调用方已经返回了<br>这种模式与我们之间提到的Future模式非常相像 不同之处只是在传统的异步调用中 我们进行的是函数调用 但是在这里 我们发送了一条消息</p><p><a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter7/future/AskMain.java" target="_blank" rel="noopener">AskMain.java</a><br>上述代码给出了俩处在Actor交互中使用Future的例子</p><p>上述代码使用aks()方法给worker发送消息 方法ask()不会等待worker处理 会立即返回一个Future对象<br>在第34行 使用Await方法等待worker的返回 接着在35行打印结果</p><p>在这种方法中 我们间接的将一个异步调用转为同步阻塞调用 虽然比较容易理解 但是在有些场合可能会出现性能问题 另外一种更有效的方法是使用pipe()函数</p><p>38行再次使用ask()方法询问worker 并传递数值6给worker 接着不进行等待 而是使用pipe()函数将这个future重定向到另外一个称为printer的actor pipe()函数不会阻塞程序运行 会立即返回</p><h2 id="7-11-多个Actor同时修改数据：Agent"><a href="#7-11-多个Actor同时修改数据：Agent" class="headerlink" title="7.11 多个Actor同时修改数据：Agent"></a>7.11 多个Actor同时修改数据：Agent</h2><p>在实际开发中 很难避免 多个Actor需要访问同一个共享变量的情况</p><p>在Akka中 使用Agent的组件来实现这个功能 一个Agent提供了一个变量的异步更新 当一个Actor希望改变Agent的值时 它就会向这个Agent下发一个动作 当多个Actor同时改变Agent时 这些action将会在ExecutionContext中并发调度执行 在任意时刻 一个Agent最多只能执行一个action 对于某一个线程来说 它执行action的顺序与它的发生顺序一致 但对于不同线程来说 这些action可能会交织在一起<br>Agent的修改可以使用俩个方法send()或者alter() 它们都可以向Agent发送一个修改动作 但是send（）方法没有返回值 而alter()方法会返回一个Future对象便于跟踪Agent的执行</p><p><a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter7/Agent/CounterActor.java" target="_blank" rel="noopener">CounterActor.java</a><br>上述代码定义了一个累加的Actor 在12-17行 定义了累计动作action addMapper 它的作用就是对Agent的值进行修改 这里简单的加1</p><p>CounterActor的消息处理函数onReceive()中 对全局的counterAgent进行累加操作 alter()指定了累加动作addMapper 由于我们希望在将来知道累加行为是否完成 因此在这里将返回的Future对象进行收集 完成任务后 Actor自行退出</p><p>程序的主函数如下<br><a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter7/Agent/AgentDemo.java" target="_blank" rel="noopener">AgentDemo.java</a></p><p>上述代码中 创建了10个CounterActor对象 在27-31行 使用Inbox与CounterActor进行通信 第29行将触发CounterActor进行累加操作 第35到45行将等待所有10个CounterAcotr运行结束 执行完成后 我们便已经收集了所有的future 在第47行 将所有的Future进行串行组合(使用sequence（）方法） 构造了一个整体的Future 并为它创建onCompete()回调函数 在所有的Agent操作执行完成后 onComplete()方法就会被调用 在这个例子中 我们简单地输出最终的counterAgent的值</p><h2 id="7-12-像数据库一样操作内存数据：软件事务内存"><a href="#7-12-像数据库一样操作内存数据：软件事务内存" class="headerlink" title="7.12 像数据库一样操作内存数据：软件事务内存"></a>7.12 像数据库一样操作内存数据：软件事务内存</h2><p>在一些函数式编程语言中 支持一种叫做软件事务内存（STM）的技术 什么是软件事务内存？ 这里的事务和数据库说的事务非常相似 具有隔离性 原子性和一致性 与数据库事务不同的是 内存事务不具备持久性（很显然内存数据不会保存下来）</p><p>在很多场合 某一项工作可能要由多个Actor协作完成 在这种协作事务中 如果一个Actor处理失败 根据事务的原子性 其他Actor所进行的操作必须要进行回滚<br>下面来看是如何启动一个内存事务的：<br><a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter7/STM/STMDemo.java" target="_blank" rel="noopener">STMDemo.java</a><br>这里新建了一个Coordinated协调者 并且将这个协调者当做消息发送给company 当company收到这个协调者消息后 自动成为这个事务的第一个成员<br>下面是代表公司账户的Actor<br><a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter7/STM/CompanyActor.java" target="_blank" rel="noopener">CompanyActor.java</a><br>首先判断是不是Coordinated 如果是Coordinated 则表示这是一个新事物的开始 则表示这是一个新事物的开始 接着<br>将调用Coordinated.coordinate()方法 将employee也加入到当前事务中 这样这个事务中就有俩个参与者了</p><p>调用了Coordinated.atomic()定义了原子执行块作为这个事务的一部分 在这个执行块中 对公司账户进行余额调整</p><p>作为转账接收方的雇员账户如下：<br><a href="https://github.com/SanShanYouJiu/CodeCollection/blob/master/Java高并发程序设计/javaHighConcurrentDesign/chapter7/STM/EmployeeActor.java" target="_blank" rel="noopener">EmployeeActor.java</a><br>上述代码中 判断消息是否为Coordinated 如果是Coordinated 则当前Actor会自动加入Coordinated指定的事务</p><p>在这里 俩个Actor都已经加入到同一个协调事务Coordinated中了 因此当公司账户出现异常后 雇员账户的余额就会回滚</p><h2 id="7-13-一个有趣的粒子：并发粒子群的实现"><a href="#7-13-一个有趣的粒子：并发粒子群的实现" class="headerlink" title="7.13 一个有趣的粒子：并发粒子群的实现"></a>7.13 一个有趣的粒子：并发粒子群的实现</h2><p>粒子群算法（PSO）是一种进化算法 它与大名鼎鼎的遗传算法非常相似 可以用来解决一些优化问题</p><blockquote><p><a href="https://zh.wikipedia.org/wiki/粒子群优化" target="_blank" rel="noopener">粒子群优化的具体解释</a> 注意wiki百科中文内容 需要翻墙阅读</p></blockquote><h3 id="7-13-3-粒子群算法能做什么"><a href="#7-13-3-粒子群算法能做什么" class="headerlink" title="7.13.3 粒子群算法能做什么"></a>7.13.3 粒子群算法能做什么</h3><p>粒子群算法应用族多的场景就是进行最优化计算 实际上 以粒子群算法为代表的进化算法 可以说最优化方法中的通用方法 几乎一切最优化问题都可以通过这种随机搜索的模式解决 其成本低 难度小 效果好 因此颇受欢迎<br>下面就是有一个典型优化的问题</p><p>假设有400万资金 要求4年用完 若存在第一年使用x万元 则可以得到效益√x万元（效益不能再使用） 当年不用的资金可存入银行 年利率为10% 尝试制定出资金的使用规划 使4年效益最大</p><p>很明显 对于此类问题 不同的方案得到结果可能会有很大的差异<br>如果使用拉格朗日乘子法对方程组求解 可以得到第一年使用86.19万 第2年使用104.29万 第三年使用126.19万 第4年使用152.69万为这个问题的最优解 总效益达43.09万</p><p>由于求解过程过于复杂 需要对12个未知数和方程进行联立求解 比较难以实现<br>对于这种问题就是粒子群算法的涉猎范围 当使用粒子群算法 我们可以先随机给出若干个满足提交的资金规划方案 接着 根据粒子群的演化公式 不断调整各个粒子的位置（粒子的每一个位置都代表一个方案）逐步探索更优的方案</p><h3 id="7-13-4-使用Akka实现粒子群"><a href="#7-13-4-使用Akka实现粒子群" class="headerlink" title="7.13.4 使用Akka实现粒子群"></a>7.13.4 使用Akka实现粒子群</h3><p>使用Actor的模式与粒子群算法之间有天生契合度 粒子群算法由于涉及到多个甚至是极其大量的粒子参与运算 因此它隐含着并行计算的模式 其次 从直观上我们也可以知道 粒子群算法的求解精度或者说求解的质量 与参与运算的例子有着直接的关系 很显然 参与运算的粒子数量越多 得到的解自然也就够精确</p><p>如果采用传统的多线程的方式实现粒子群 一个最大的问题就是线程数量的可能是非常有限的 在当前这种应用场景中 我们希望可以有数万 甚至数十万的粒子 但是一台计算机 开启数万的线程是不可能的 就是可以 系统的效率也会非常的低 因此 使用多线程的模型无法很好地和粒子群的实现相融合</p><p>但Akka的actor不同 由于多个Actor可以复用一个线程 而Actor本身作为轻量级的并发执行单元可以有极其大量的存在 因此 我们就可以使用Actor来模拟整个粒子群计算的场景</p><p><a href="https://github.com/SanShanYouJiu/CodeCollection/tree/master/Java高并发程序设计/javaHighConcurrentDesign/chapter7/PSO" target="_blank" rel="noopener">Akka实现PSO代码</a></p><p>代码本身没有什么特别需要说明的地方<br>首先是俩个表示pBest和gBest的消息类型 用于多个Actor之间传递个体最优和全局最优</p><p>其次在PsoValue中 主要包括俩个信息 第一是表示投资规划的方案 即每一年分别需要投资多少钱 第二是这个投资方案的总收益<br>在Fitness中的fitness()函数返回了给定投资方案的适应度 适应度也就是投资的收益 我们自然应该更倾向于选择适应度更高的投资方案</p><p>Bird就是基本粒子</p><p>MasterBird是用来管理和通知全局全优的</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一章-走入并行世界&quot;&gt;&lt;a href=&quot;#第一章-走入并行世界&quot; class=&quot;headerlink&quot; title=&quot;第一章 走入并行世界&quot;&gt;&lt;/a&gt;第一章 走入并行世界&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;介绍 没有什么需要记的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;第二章-Java并发程序基础&quot;&gt;&lt;a href=&quot;#第二章-Java并发程序基础&quot; class=&quot;headerlink&quot; title=&quot;第二章 Java并发程序基础&quot;&gt;&lt;/a&gt;第二章 Java并发程序基础&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="JAVA" scheme="http://yoursite.com/tags/JAVA/"/>
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>JAVA8新特性总结</title>
    <link href="http://yoursite.com/2017/07/23/JAVA8%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/07/23/JAVA8%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/</id>
    <published>2017-07-22T16:00:00.000Z</published>
    <updated>2019-12-01T10:54:20.843Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考 Java核心技术第十版 Java编程思想<br>还有网上的各位大大的博客<br>在尾部会一一列出</p></blockquote><a id="more"></a><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="接口与静态方法"><a href="#接口与静态方法" class="headerlink" title="接口与静态方法"></a>接口与静态方法</h2><p>在JAVASE8中 允许在接口中增加静态方法 理论 没有任何理由认为这是不合法的 只是这有违于将接口作为抽象规范的初衷</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface TestStaticInterace &#123;</span><br><span class="line">static  void ceshi(String s)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="这里插点自己的一些想法"><a href="#这里插点自己的一些想法" class="headerlink" title="这里插点自己的一些想法"></a>这里插点自己的一些想法</h2><p>关于接口与静态方法<br>在JAVASE8之前的版本中 接口是用来定义规范的 接口中的方法默认都是public abstract前缀的 是不能进 static修饰<br>在抽象类中 同样的 abstract修饰的方法也是不能进行static（SE8中也不能）<br>在编程思想中有这么两句话描述</p><blockquote><p>The interface keyword produces a completely abstract class, one that provides no implementation at all. It allows the creator to determine method names, argument lists, and return types, but no method bodies. An interface provides only a form, but no implementation</p></blockquote><hr><blockquote><p>When you say something is static, it means that particular field or method is not tied to any particular object instance of that class</p></blockquote><p>总体的意思就是</p><ol><li>接口是完全抽象的 只是用来定义规范的 就是没有方法体 要让实现类去实现</li><li>一个静态的什么东西 方法或者字段之类 它是不能绑定到某个特定的实例对象上去的</li></ol><p>这个意思就很明显了 在接口中定义了这个static 要去某个特定类实现 但是这个静态方法是不能绑定到某个特定的实例对象上的 这就是自相矛盾了 也是之前没有在接口中加入static修饰的原因之一吧</p><p>至于为什么现在加入了 更多我的觉得是一个API简洁与维护 扩展（默认方法同） 而不用到一个特定的实现类中</p><p>比如以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void ceshi(String s);//实现于某特定对象实例</span><br><span class="line"></span><br><span class="line">static  void ceshi2(String s)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;//接口中新定义的static 新的cehis方法</span><br></pre></td></tr></table></figure><blockquote><p>如果放到类中的话 事实上给人的感觉却是此API的用户并不是面向这个接口进行编程，而是面向这个接口的实现类在编程</p></blockquote><p>这样子在一些代码中维护起来就会方便很多<br>另外的话单独直接在接口中定义的话也会使用起来方便很多<br>也保持了API的简洁 最重要还是方便 这个具体用处还是自己体会比较好</p><h2 id="接口与默认方法"><a href="#接口与默认方法" class="headerlink" title="接口与默认方法"></a>接口与默认方法</h2><p>注意 默认方法不是静态方法 静态方法我们直接点击接口名之后就能点击出来 但是默认方法不是这样 是在实现类中进行引用的<br>下面是例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> interface  iTest&#123;</span><br><span class="line">    int size();</span><br><span class="line">    default boolean isEmpty()&#123;</span><br><span class="line">        return size() == 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class Testimpl implements iTest&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Testimpl test=  new Testimpl();</span><br><span class="line">    test.isEmpty();//在这里进行使用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于其意义何在<br>引用俩段话</p><blockquote><p>在 java 8 之前，接口与其实现类之间的 耦合度 太高了（tightly coupled），当需要为一个接口添加方法时，所有的实现类都必须随之修改。默认方法解决了这个问题，它可以为接口添加新的方法，而不会破坏已有的接口的实现。这在 lambda 表达式作为 java 8 语言的重要特性而出现之际，为升级旧接口且保持向后兼容（backward compatibility）提供了途径。</p></blockquote><hr><blockquote><p>在Java Api中 很多的接口都会有其伴随类 这个伴随类实现了这个接口的部分或者全部方法 比如 Collection/AbstractCollection<br>在Java SE8中 可以直接在接口中实现方法 这个方式已经过时</p></blockquote><p>和其他方法一样 默认方法也可以被继承的</p><p>如果在一个接口中将一个方法定义为默认方法 然后又在超类或另一个接口中定义同样Java 就会发生冲突<br>JAVA的相应规则就简单多了</p><ul><li>超类优先 如果超类提供一个具体方法 同名而且有相同参数类型的默认方法被忽略</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public interface Person &#123;</span><br><span class="line">       default String getName()&#123;</span><br><span class="line">   return &quot;person&quot;;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Person &#123;</span><br><span class="line">      default String getName()&#123;</span><br><span class="line">   return &quot;person&quot;;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public class PersonImpl implements Person &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Student  extends PersonImpl implements Named&#123;</span><br><span class="line">    @Override</span><br><span class="line">public String getName() &#123;</span><br><span class="line">   return super.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接口冲突 如果一个超接口提供了一个默认方法 另一个接口提供了一个同名而且参数类型（不论是否默认参数的相同方法） 必须覆盖这个方法来解决冲突</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public interface Named &#123;</span><br><span class="line"></span><br><span class="line">   default String getName()&#123;</span><br><span class="line">  return &quot;named&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Person &#123;</span><br><span class="line"></span><br><span class="line">   default String getName()&#123;</span><br><span class="line">   return &quot;person&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Student  implements  Person,Named&#123;</span><br><span class="line">@Override</span><br><span class="line">public String getName() &#123;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类会继承Person和Named接口提供的俩个不一致的getName方法 并不是从中选择一个<br>Java编译器会报告一个错误 让程序员解决这个二义性<br>只需要在Student类中提供一个getName方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Student  implements  Person,Named&#123;</span><br><span class="line">@Override</span><br><span class="line">public String getName() &#123;</span><br><span class="line">    return Person.super.getName();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 在默认方法冲突中 是<strong>类优先</strong>原则<br><strong>类优先</strong>原则可以确保与JAVA SE7的兼容性 如果为一个接口增加默认方法 这对于这个默认方法之前能正常工作的代码不会有任何影响</p><h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h1><p>终于到关键部分了 lambda是一个希腊字母<br>（大写Λ，小写λ，中文音译：兰布达）</p><blockquote><p>为什么起这个名字 在以前没有计算机的时候 逻辑学家Alonzo Church想要形式化的表示能有效计算的数学函数 他使用了希腊字母lambda来标记参数</p></blockquote><p>lambda：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(参数)-&gt;表达式</span><br><span class="line">    或            </span><br><span class="line">(参数)-&gt;&#123;表达式&#125;</span><br></pre></td></tr></table></figure><p>lambda表达式的形式：<br>参数 箭头(-&gt;)以及一个表达式 如果代码要完成的计算无法放在一个表达式中 就可以像写方法一样 把这些代码放在{}中 并包含显示的return语句<br>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(String o1,String o2)-&gt;&#123;</span><br><span class="line">       if (o1.length()&lt;o2.length()) return -1;</span><br><span class="line">       else return 0;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>即使lambda表达式没有空参数 也要提供空括号 就像无参数方法一样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">()-&gt;&#123;system.out.println(&quot;test&quot;);&#125;</span><br></pre></td></tr></table></figure><p>无需指定lamdab表达式的返回类型 lambda表达式的返回类型总是会有上下文推导得出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(String o1,String o2)-&gt;o1.length()-o2.length()</span><br></pre></td></tr></table></figure><p>可以在需要int类型结构的上下文中使用</p><p>可以省略参数类型声明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(o1,o2)-&gt;o1.length()-o2.length();</span><br></pre></td></tr></table></figure><p>下面是lambda的重要特征</p><ul><li>可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。</li><li>可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。</li><li>可选的大括号：如果主体包含了一个语句，就不需要使用大括号。</li><li>可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值</li></ul><blockquote><p>Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中），或者把代码看成数据</p></blockquote><p>在没有lambda的时候 一般都是采用匿名类来代替lambda<br>比如Thread类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*Thread 匿名内部类*/</span><br><span class="line">    new Thread((new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;Thread 匿名内部类&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)).start();</span><br><span class="line"></span><br><span class="line">/*Thread的 lambda方式*/</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(&quot;Thread lambda&quot;);</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">//       单独赋予给Runnable</span><br><span class="line">    Runnable run =()-&gt;&#123;</span><br><span class="line">        System.out.println(&quot;就是有这种操作&quot;);</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><hr><p>下面是对Thread类的模拟实践</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">interface TestLambda  &#123;</span><br><span class="line"></span><br><span class="line">void test( String s) throws  Exception;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class  TestLambdaImpl implements TestLambda&#123;</span><br><span class="line">private   TestLambda testLambda;</span><br><span class="line"></span><br><span class="line">public TestLambdaImpl(TestLambda testLambda) &#123;</span><br><span class="line">    this.testLambda=testLambda;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void test(String s) throws Exception &#123;</span><br><span class="line">    testLambda.test(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    //个人模仿Thread示例</span><br><span class="line">    TestLambdaImpl testLambda = new TestLambdaImpl((s) -&gt; System.out.println(s));</span><br><span class="line">    testLambda.test(&quot;测试&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于只有一个抽象方法的接口 需要这种接口的对象时 就可以提供一个lambda表达式 这种接口称为函数式接口 在本例中 我们将TestLambda接口声明@FunctionalInterface（这个在没有的情况也是可以的）</p><hr><p>下面是lambda表达式的其他示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    //lambda示例</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;c&quot;, &quot;b&quot;);</span><br><span class="line"></span><br><span class="line">    Collections.sort(list,(s1,s2)-&gt;&#123;</span><br><span class="line">        if (s1==null)</span><br><span class="line">            return -1;</span><br><span class="line">        if (s2==null)</span><br><span class="line">            return -1;</span><br><span class="line">        return s1.length()-s2.length();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(list); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //swing中的Timer类lambda</span><br><span class="line">    javax.swing.Timer T =new Timer(1000,event-&gt;&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好将lambda看成一个函数 而不是一个对象 这样方便理解<br>在java中 对lambda表达式所能做的也只是能转换为函数结构 在其他支持函数字面量的语言中 可以声明函数类型(String,String)-&gt;int 声明这些类型的变量 还可以使用变量保存函数表达式</p><p>Java API中在java.util.funtion包中定义了很多通用的函数式接口</p><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>方法引用有如下几种形式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class::new  //初始化Class对象</span><br><span class="line">Class::static_method //调用Class中的静态方法 </span><br><span class="line">instance::method //调用实例的非静态方法</span><br><span class="line">Class:methond //调用Class中的非静态方法</span><br></pre></td></tr></table></figure><p>在前面三种情况 方法引用等价于提供方法参数的lambda表达式<br>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class::new  等价于()-&gt;new Class()</span><br></pre></td></tr></table></figure><p>在使用构造引用时 选择哪个构造器是取决于上下文的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class::static_method 等价于(参数)-&gt;Class.static_method </span><br><span class="line">instance::method 等价于(参数)-&gt;instance.methond;</span><br></pre></td></tr></table></figure><p>至于第4种情况 第一个参数会成为方法的目标<br>比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String::compareToIgnoreCase</span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x,y)-&gt;x.compareToIgnoreCase(y)</span><br></pre></td></tr></table></figure><p>也可以在方法引用中使用super,this参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">super::instanceMethod</span><br><span class="line">this::instanceMethod</span><br></pre></td></tr></table></figure><p>变量作用域</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   public static void repeatMessage(String text, int delay) &#123;</span><br><span class="line">    ActionListener listener = e -&gt; &#123;</span><br><span class="line">        System.out.println(text);</span><br><span class="line">        Toolkit.getDefaultToolkit().beep();</span><br><span class="line">    &#125;;</span><br><span class="line">    new Timer(delay, listener).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个lambda表达式中变量text 注意这个比那里并不是在这个lambda表达式中定义的 实际上 这是repeatMessage方法的一个参数变量</p><p>lambda表达式有3个部分</p><ol><li>一个代码块</li><li>参数</li><li>自由变量的值 这里值非参数而不在代码中定义的变量</li></ol><p>在这个例子中 这个lambda表达式有1个自由变量text 表示lambda表达式的数据结构必须存储自由变量的值 在这里就是字符串 我们说它被lambda表达式捕获了</p><blockquote><p>这其实就是闭包</p></blockquote><p>lambda表达式可以捕获外围作用域中变量的值 在Java中要确保所捕获的值是明确定义的 这里有一个重要的限制 在lambda表达式中 只能引用值而不会改变的变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   public static void repeatMessage(String text, int delay) &#123;</span><br><span class="line">    for (int i = 0; i &lt;10 ; i++) &#123;</span><br><span class="line">        ActionListener listener = e -&gt; &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            Toolkit.getDefaultToolkit().beep();</span><br><span class="line">        &#125;;</span><br><span class="line">        new Timer(delay, listener).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lambda表达式中捕获的对象实际上是最终变量 实际上的最终变量是指 这个变量初始化之后就不会再为它赋新值 在这里 text总是只是同一个String对象 所以捕获这个变量是合法的 不过i的值会改变 因此不会捕获</p><p>处理lambda表达式</p><p>在Java.util.function中提供一了一系列的函数式接口<br>如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BooleanSupplier</span><br><span class="line">PSupplier</span><br><span class="line">PConsumer</span><br><span class="line">ObjPConsumer&lt;T&gt;</span><br><span class="line"> ....</span><br></pre></td></tr></table></figure><p>这里就不说了 太多了</p><h1 id="Streams-API"><a href="#Streams-API" class="headerlink" title="Streams API"></a>Streams API</h1><p>发现了一篇好的Streams API介绍博客</p><p>珠玉在前 没有必要写了</p><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/" target="_blank" rel="noopener">Java 8 中的 Streams API 详解</a></p><p><a href="http://oopjava.cn/tags/Java8小结/" target="_blank" rel="noopener"># Java8小结</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;参考 Java核心技术第十版 Java编程思想&lt;br&gt;还有网上的各位大大的博客&lt;br&gt;在尾部会一一列出&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="JAVA" scheme="http://yoursite.com/tags/JAVA/"/>
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JAVA核心技术第14章--线程章</title>
    <link href="http://yoursite.com/2017/03/24/JAVA%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC14%E7%AB%A0--%E7%BA%BF%E7%A8%8B%E7%AB%A0/"/>
    <id>http://yoursite.com/2017/03/24/JAVA%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC14%E7%AB%A0--%E7%BA%BF%E7%A8%8B%E7%AB%A0/</id>
    <published>2017-03-23T16:00:00.000Z</published>
    <updated>2019-12-01T10:54:29.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第14章-多线程"><a href="#第14章-多线程" class="headerlink" title="第14章 多线程"></a>第14章 多线程</h1><blockquote><p>其他章节的笔记也都记下 在本人的Github中 因为不是markdown格式 所以打印为PDF</p></blockquote><a id="more"></a><p>多线程程序在较低的层次扩展了多任务的概念 一个程序可以运行多个任务 通常 每个任务被称为一个<strong>线程</strong> 它是线程控制的简称 关于进程与线程的本质的区别在于每个进程是否拥有自己的一套变量 而线程则是共享数据的 <strong>共享变量</strong>使得线程之间的通信比进程更有效 与进程相比 线程<strong>更轻量级</strong><br>创建 撤销 一个线程比启动新线程的开销要小的多</p><p>为了使用线程的话 主要是使用一个类和一个接口 这个接口是Runnable接口 这个类是Thread类<br>这俩个都有run方法 我们需要实现或者覆盖就可以 run方法就是我们线程的具体实现的方法</p><p>如果使用的是一个比较耗时的任务 应该使用独立的线程</p><blockquote><p>警告：不要调用Thread类或Runnable对象的run方法 直接调用run方法 只会执行同一个线程中的任务 而不会启动新线程 应该调用<br>Thread.start方法 这个方法将创建个执行run方法的新线程</p></blockquote><h2 id="关于中断线程"><a href="#关于中断线程" class="headerlink" title="关于中断线程"></a>关于中断线程</h2><p>早期有一个stop方法 现在已经放弃了<br>现在还有一种中断的方法 就是interrupt方法 intrrupt方法可以用来请求中止线程<br>当对一个线程调用interrupt方法时 线程的中断位置将被重置<br>正确的停止线程方式是设置共享变量，并调用interrupt()（注 意变量应该先设置）。<br>想弄清楚线程是否被重置 我们可以调用currentThread方法获得当前进程 然后调用isInterrupted 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">do some work</span><br><span class="line">while(! Thread.currentThread().isInterrupted() &amp;&amp; more work to do) &#123;</span><br><span class="line">do more work</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch(InterruptedException e) &#123;</span><br><span class="line">// thread was interrupted during sleep or wait (in blocked)</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">        cleanup if required</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果当前线程被阻塞 就无法检测中断状态</strong> 这是产生InterruptedException异常的地方 当在一个被阻塞的线程（调用sleep或wait）上调用interrupt方法时 阻塞调用将会被Interrupted Exception异常中断 被中断的线程可以决定如何响应中断<br>需要说明的是：<strong>中断一个线程不过是引用它的注意</strong> 被中断的线程可以决定如何响应中断 某些线程是如此的重要以至于应该处理完异常后 继续执行 而不理会中断<br>中断状态被置位时调用sleep方法等阻塞方法时 它不会休眠 相反 <strong>它会清除这一状态 并抛出InterruptedException</strong></p><blockquote><p>不是所有的阻塞方法收到中断后都可以取消阻塞状态, 输入和输出流类会阻塞等待 I/O 完成，但是它们不抛出 InterruptedException，而且在被中断的情况下也不会退出阻塞状态.<br>尝试获取一个内部锁的操作（进入一个 synchronized 块）是不能被中断的，但是 ReentrantLock 支持可中断的获取模式即 tryLock(long time, TimeUnit unit)。</p></blockquote><p>Thread.interrupt()方法不会中断一个正在运行的线程。这一方法实际上完成的是，在线程受到阻塞时抛出一个中断信号，这样线程就得以退出阻塞的状态。更确切的说，如果线程被Object.wait, Thread.join和Thread.sleep三种方法之一阻塞，那么， 它将接收到一个中断异常（InterruptedException），从而提早地终结被阻塞状态。<br>在这里拥有俩种方法进行结束 一种是使用catch到异常之后 本来是处于阻塞状态下 由于中断提前出来 在catch块中使用特定的方法步骤将其停止 另外一种就是不能使用阻塞方法（因为使用阻塞方法 isInterrupted方法会失效） 使用isInterrupted方法来判断是否是中断 然后进行特定的方法步骤将其停止</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class Ceshi &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Runnable2 runnable2 = new Runnable2();</span><br><span class="line">Thread thread = new Thread(runnable2);</span><br><span class="line">thread.start();</span><br><span class="line"></span><br><span class="line">thread.interrupt();</span><br><span class="line">System.out.println(&quot;已经中断。。。。&quot;);</span><br><span class="line">System.out.println(&quot;中断完毕。。。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Runnable2 implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">int i = 0;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line"></span><br><span class="line">while (i &lt; 4) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">i++;</span><br><span class="line">System.out.println(&quot;1&quot;);</span><br><span class="line">if (!Thread.currentThread().isInterrupted()) System.out.println(&quot;没有被中断  非常好&quot;);</span><br><span class="line">if (Thread.currentThread().isInterrupted()) i = 4;</span><br><span class="line">System.out.println(&quot;i:&quot; + i);</span><br><span class="line"></span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">System.out.println(&quot;Thread catch Exception&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是网上摘抄部分 上面都有说过了：<br>当产生异常时，有两种处理方式选择。</p><ol><li><p>在catch子句中设置中断状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">catch(InterruptedException e) &#123;</span><br><span class="line">Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不采用try语句块捕获异常，交给调用者处理。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void mySubTask() throws InterruptedException &#123;&#125;</span><br></pre></td></tr></table></figure><p>测试当前线程是否被中断有interrupted()和isInterrupted()两个方法。<br>interrupted()是一个静态方法，有副作用，会把中断状态位置为false；<br>isInterrupted()是一个实例方法，无副作用。</p><p><a href="http://blog.csdn.net/canot/article/details/51087772这是关于中断的一部分详解" target="_blank" rel="noopener">http://blog.csdn.net/canot/article/details/51087772这是关于中断的一部分详解</a></p><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>线程有6种状态</p><ul><li>NEW（创建）</li><li>Runnable（可运行）</li><li>Waiting（等待）</li><li>Timed waiting（计时等待）</li><li>Terminated（终止）</li></ul><p>新创建的线程 如：NEW Thread() 这个状态是new 程序还没有运行线程中的代码</p><p>然后是<strong>可运行状态</strong></p><p>一旦调用了start方法 就到了可运行状态 处于Runable 一个可运行的线程可能正在运行肯也没有运行 这取决于操作系统给线程的提供运行的时间</p><p>一旦一个线程开始运行 它不必始终保持运行 事实上 运行中的线程被中断 目的是为了让其他的线程获得运行机会 线程调度的细节依赖于操作系统的实现 <strong>抢占式调度系统</strong>给每一个可运行线程一个时间片来执行任务 当时间片用完 操作系统剥夺该线程的运行权 并给另一个线程运行机会 当选择一个线程时 操作系统考虑线程的优化级</p><p>现在所有的桌面和服务器操作都采用的是抢占式调度 <strong>但是在手机端 可能采用的是协作式调度</strong> 在这样的设备中 一个线程只有在调用yield方法 或者阻塞或等待，线程才失去控制权</p><p>在具有多个处理器的机器上 每一个处理器运行一个线程 可以有多个线程并行运行 当然 如果线程的数目多与处理器的数目 调度器依然采用时间片机制</p><p><strong>在任何给定时刻 一个可运行的线程可能正在运行也可能没有运行</strong></p><h3 id="被阻塞线程与等待线程"><a href="#被阻塞线程与等待线程" class="headerlink" title="被阻塞线程与等待线程"></a>被阻塞线程与等待线程</h3><p>当线程处于阻塞或等待状态时 它不运行任何代码并且消耗最小 直到线程调度器激活它 细节取决它是怎样到达非活动状态的</p><ol><li><p>当一个线程视图获取一个内部的对象锁 而该锁被其他线程持有 则该线程进入阻塞状态 当所有其他线程释放该锁 并且线程调度器允许本线程持有它的时候 该线程变成非阻塞状态</p></li><li><p>当线程等待另一个线程通知调度器一个条件时 它自己进行等待状态<br>在调用Object.wait或者Thread.join方法 或者等待java.util.concurrent库中Lock或Condition时 就会出现这种情况 实际上 阻塞状态与等待状态时是很大不同的</p></li><li>有几个方法有一个超时参数 调用它们导致线程进入<strong>计时等待</strong><br>带有延时参数的方法有Thread.sleep，Object.wait,Thread.join,Lock,tryLock以及Condition.await<br>当一个线程被阻塞或等待时 另外一个线程处于运行状态 然后这个线程重新被激活时 然后对比与当前的线程的优先级是否更高 如果是的 就剥夺当前运行的一个线程 将这个填上去</li></ol><p><strong>线程终止</strong><br>因为俩个原因被终止<br>1 run方法正常退出而死亡<br>2 有一个异常强制终止了run方法而意外死亡</p><p>还有另外一种 就是stop强制死亡该方法抛出ThreadDeath错误对象 由此杀死线程 不推荐使用stop方法了</p><p><strong>线程属性：</strong></p><p>线程优先级 守护线程 线程组 处理未捕获异常的处理器</p><p><strong>线程的优先级</strong><br>在java设计语言中 每一个线程都有一个优先级 默认情况下 一个线程继承它的父类的优先级 可以用setPriortiy方法来提高或降低任何一个线程的优先级</p><p>每当线程调度器有机会选择新线程时 它首先选择具有较高优先级线程 但是 线程优先级是高度依赖于系统的 所以在不同的平台是不同的优先级</p><blockquote><p>注意 不要将线程的构建为功能的正确性依赖于优先级</p></blockquote><p>每将调度器调度一个新的线程时 首先会在具有高优先级的线程中进行选择 <strong>尽管这样会使优先级低的线程完全饿死</strong></p><p><strong>守护线程</strong><br>在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程)<br>，任何一个守护线程都是整个JVM中所有非守护线程的保姆：<br>只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作<br>可以通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread.setDaemon(true);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure><p>这个方法进行将一个线程变为守护线程 注意：这个守护线程必须要在start之前使用</p><p>守护线程应该永远不去访问固有资源 比如很典型的一个守护线程：垃圾回收器</p><p><strong>未捕获异常处理器</strong></p><p>线程的run方法不能抛出任何被检测的异常 但是 不被检测的异常会导致线程的终止 在这种情况下 线程就死亡了<br>但是 不需要任何catch子句来处理的传播的异常 相反 就<strong>在线程死亡之前 异常被传递到一个用于未捕获异常的处理器</strong><br>该处理器必须实现一个Thread.UncaughtExceptionHandler接口的类</p><p>也可以使用<strong>Thread类的静态方法setDefaultUncaughtExceptionHandler</strong> 为所有的线程来安装一个默认的处理器 替换处理器可以使用日志API发送未捕获的异常的报告到日志文件</p><p>如果不安装默认的处理器 默认的处理器为空 但是 如果<strong>不为独立的线程安装处理器 此时的处理器就是该线程的ThreadGroup对象</strong><br>关于线程组 是一个管理线程的集合 但是这个线程组 现在已经有了更好的解决办法 不建议使用</p><p>ThreadGroup类实现Thread.UncaughtExceptionHandler接口 它的uncaughtException方法操作如下：</p><ol><li>如果该线程组有父线程组 那么父线程组的uncaughtException方法被调用</li><li>否则 如果Thread.getDefaultExceptionHandler方法返回一个非空的处理器 则调用该处理器</li><li>否则 如果Throwable是ThreadDeath的一个实例 什么都不做（ThreadDeath是stop的一个实例 但是现在已经弃用）</li><li>否则 线程的名字以及Throwable的栈踪迹被输出到System.err上<br>这是你在程序中看到许多次的栈踪迹</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System.out.println(&quot;创建一个新的线程&quot;);</span><br><span class="line">ExceptionThread2 thread2 = new ExceptionThread2();</span><br><span class="line">Thread t = new Thread(thread2);</span><br><span class="line">Thread.setDefaultUncaughtExceptionHandler(new MycaughtUnCheckExceptionHandler());//这是给所有的设置默认的异常处理器</span><br><span class="line">//t.setUncaughtExceptionHandler(new MycaughtUnCheckExceptionHandler());//这是设置单独的一个线程的异常处理器</span><br><span class="line">t.start();</span><br><span class="line">System.out.println(&quot;eh121=&quot; + t.getUncaughtExceptionHandler());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ExceptionThread2 implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">System.out.println(&quot;run() by &quot; + t);</span><br><span class="line">System.out.println(&quot;eh=&quot; + t.getUncaughtExceptionHandler());</span><br><span class="line">        throw  new RuntimeException(&quot;抛出运行时异常 &quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class  MycaughtUnCheckExceptionHandler implements Thread.UncaughtExceptionHandler&#123;</span><br><span class="line">@Override</span><br><span class="line">public void uncaughtException(Thread t, Throwable e) &#123;</span><br><span class="line">System.out.println(&quot;捕捉了到线程 \t&quot; + t + &quot;\n 捕捉到了异常&quot; + e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>竞争条件的一个列子</p><p>为了避免多线程引起对共享数据的讹传 必须要学习同步存取<br><strong>是否原子操作是十分重要的</strong></p><p>我们这里实现了一个关于银行的案例 代码太多就不全部贴上来了<br>结果出错了 至于原因<br>如果进行相关的虚拟机下的字节码查看的话 就可以发现重要的增殖命令是由几条指令组成的 执行他们的线程可能在任何一条指令上被中断</p><p>如果删除打印语句或者其他消耗资源的方法 讹传的风险就低一点 因为每个线程在再次睡眠之前的工作量少 调度器在计算中剥夺线程的运行权可能性很小<br>主要就是在于cpu的使用情况 如果负载好就还好 如果负载很大 出错依然会存在</p><p>真正的问题是<strong>具体变量的执行方法的执行过程中可能被中断</strong> 如果能保证线程在失去控制之前方法运行完成 那么状态就永远不会出现讹传</p><p>java语言提供了一个<strong>synchroized</strong>关键字达到这一目的 并且在 JAVA SE5引入了ReentranLock类</p><p>synchronize关键字提供了一个锁以及相关的条件</p><p>ReentrantLock保护代码块的结构如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">myLock.lock();</span><br><span class="line">try&#123;</span><br><span class="line"></span><br><span class="line">&#125;finally&#123;</span><br><span class="line">myLock.lock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这确保了任何时刻只有一个线程进入临界区 一旦一个线程封锁了锁对象 其他任何子句都无法通过lock语句<br>把解锁操作括在finally子句之内是很重要的 不然无法释放这个线程 其他线程也永远被堵塞<br><strong>如果使用了锁 就不能用带资源的try语句</strong></p><p>下面未改之前的transfer方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void transfer(int from, int to, double amount)</span><br><span class="line">&#123;</span><br><span class="line">if (accounts[from] &lt; amount) return;</span><br><span class="line">System.out.print(Thread.currentThread());</span><br><span class="line">accounts[from] -= amount;</span><br><span class="line">System.out.printf(&quot; %10.2f from %d to %d&quot;, amount, from, to);</span><br><span class="line">accounts[to] += amount;</span><br><span class="line">System.out.printf(&quot; Total Balance: %10.2f%n&quot;, getTotalBalance());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是改过之后的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void transfer(int from, int to, double amount) &#123;</span><br><span class="line">bankLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">if (accouts[from] &lt; amount) return;</span><br><span class="line">System.out.println(Thread.currentThread());</span><br><span class="line">accouts[from] -= amount;</span><br><span class="line">System.out.printf(&quot;%10.2f from %d to %d &quot;, amount, from, to);</span><br><span class="line">accouts[to] += amount;</span><br><span class="line">System.out.printf(&quot;Total Balance: %10.2f%n&quot;, getTotalBalance());</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">bankLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改过就不会出现上面未改过的状况了</p><p>注意 每一个的Bank对象都有自己的ReentranLock对象 如果俩个线程视图访问一个Lock对象 那么锁以串行的方式提供服务 但是 如果俩个线程访问不同的的Bank对象 每一个线程得到不同的线程对象 俩个线程不会阻塞</p><p><strong>锁是可重入的</strong> 因为线程可以重复获得已持有的锁 锁保持一个<br><strong>持有计数</strong> 来跟踪对lock方法的嵌套使用 线程在每一次调用lock都要调用unlock来释放锁 由于这一特性 被一个锁保护的代码可以调用另一个使用相同的锁的方法</p><p>比如 transfer调用了getTotalBalance放 这也会封锁bankLock对象 当BankLock对象的持有计数为2 当getTotalBalance方法退出的时候 持有计数变了1 当transfer退出的时候 持有计数变成了0 线程释放锁</p><p>如果要保护一个经常被更新或检测共享对象的代码块 要确保这些操作是否完整 是否完成 然后另一个线程才能使用相同的对象</p><blockquote><p>注意<br>要留意临界区的代码 不要因为异常就跳出了临界区 如果在临界区代码结束之前抛出了异常 finally子句将释放锁 但会使对象可能处于一种受损状态</p></blockquote><h3 id="条件对象"><a href="#条件对象" class="headerlink" title="条件对象"></a>条件对象</h3><p>条件变量需要与锁绑定<br>通常 线程进入临界区 却发现在某一条件上满足之后才能执行 要使用一个条件对象来管理那些已经获得一个锁但是不能做有用工作的线程</p><p>注意下面这段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (bank.getBalance(from)&gt;=amount) bank.transfer(from,to,amout);</span><br></pre></td></tr></table></figure><p>有可能是在判断之前就执行了后面的代码 这就出问题了</p><p>所以说 当这个账号没有足够的余额时 应该等待另外一个线程注入资金 但是 这一个线程刚刚获得了BankLock的排他性访问 因此 其他线程没有访问的机会 这也是我们需要条件对象的时候<br>一个锁对象可以有一个或多个相关的调节对象 可以用newCondition方法获得一个条件对象 习惯上给每一个对象命名为可以反映它所代表的条件的名字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private Condition sufficientFunds;</span><br></pre></td></tr></table></figure><p>如果transfer这个转移方法发现余额不足 直接调用sufficientFunds.await();<br>当前线程被阻塞了 并放弃了锁 使得另外一个线程可以进行增加账户余额的操作</p><p>等待获得锁的线程和调用await方法的线程存在<strong>本质的不同</strong> 一旦一个线程调用await方法 它进入该条件的等待集 当锁可用时 该线程不能马上解除阻塞 相反 它处于阻塞状态 直到另一个线程调用同一条件上的singAll方法为止<br>当另一个线程转账时 应该调用<br>sufficientFunds.singAll();方法</p><p>这一调用<strong>重新激活因为这一条件而等待的所有线程</strong> 它们中的某个将从await调用返回 获得该锁并从阻塞的地方<strong>继续执行</strong><br>线程应该再次测试该条件 由于无法确保该条件被满足 —sigalAll方法<strong>仅仅是通知正在等待的线程 ：此时可能已满足条件 值得再去检测该条件</strong></p><p>至关重要的最终需要某个其他线程调用singlAll方法 当一个线程调用await方法时 它没有办法重新激活自身 它寄希望于其他线程 如果没有其他线程来重新激活等待的线程 它就永远不再运行了 它将导致令人不快的死锁现象<br>应该何时调用signalAll呢 <strong>经验上讲 在对象的状态有利于等待线程的方向改变时调用siganAll</strong></p><p>注意调用<strong>signalAll不会立即激活一个线程 它仅仅接触等待线程的阻塞</strong> 以便这些线程可以在当前线程退出同步方法之后 通过竞争条件实现对象的访问</p><h3 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h3><p>锁用来保护代码片段 任何时刻只能有一个线程执行被保护的代码<br>锁可以管理试图进入被保护代码的片段<br>锁可以有一个或多个相关的条件对象<br>每个条件对象管理那些已经进入被保护代码但还不能运行的线程</p><p>Lock和Condition接口为程序设计人员提供了<strong>高度的锁定机制</strong> 在大多数情况下 是不需要这么的控制的 并且可以使用一种嵌入到java语言内部的机制<br>从JavaSe1.0版开始 <strong>java的每一个对象都有一个内部锁</strong> 如果一个方法用<strong>synchronized关键字声明</strong> 那么<strong>对象的锁将保护整个方法 也就是说 要调用该方法 线程必须获得内部的对象锁</strong></p><p>下面贴代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/*1*/</span><br><span class="line">public void transfer(int from, int to, double amount) &#123;</span><br><span class="line">bankLock.lock();</span><br><span class="line"></span><br><span class="line">     try &#123;</span><br><span class="line">/*这里的while循环不能换成if条件语句，因为被别的线程用signalAll方法唤醒的线程</span><br><span class="line">         ，仅仅是条件可能满足了，而不是条件一定满足了，</span><br><span class="line">         如果不用while循环继续检测的话，就会造成条件不满足的线程继续向下执行，从而产生错误。*/</span><br><span class="line">while (accouts[from]&lt;amount)</span><br><span class="line">sufficientFunds.await();</span><br><span class="line">System.out.println(Thread.currentThread());</span><br><span class="line">accouts[from] -= amount;</span><br><span class="line">System.out.printf(&quot;%10.2f from %d to %d &quot;, amount, from, to);</span><br><span class="line">accouts[to] += amount;</span><br><span class="line">System.out.printf(&quot;Total Balance: %10.2f%n&quot;, getTotalBalance());</span><br><span class="line">sufficientFunds.signalAll();</span><br><span class="line"></span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">bankLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">/*2*/</span><br><span class="line">public  synchronized void transfer2(int from, int to, double amount) throws InterruptedException &#123;</span><br><span class="line">while (accouts[from]&lt;amount)    wait();</span><br><span class="line">System.out.println(Thread.currentThread());</span><br><span class="line">accouts[from] -= amount;</span><br><span class="line">System.out.printf(&quot;%10.2f from %d to %d &quot;, amount, from, to);</span><br><span class="line">accouts[to] += amount;</span><br><span class="line">System.out.printf(&quot;Total Balance: %10.2f%n&quot;, getTotalBalance());</span><br><span class="line">notifyAll();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1 与2 的方法代码其效果是一样 只不过synchronized关键字是不需要显示的声明一个锁</p><p>内部对象锁只有一个相关条件 wait方法添加一个线程到等待集中 notifyAll/notify方法解除等待线程的阻塞操作 换句话说 <strong>调用wait或notifyAll是等价于</strong><br><strong>await与signalAll方法的</strong>（wait方法与notifyAll/notify方法是Object的final方法）</p><p>使用synchronized关键字比编写代码要简洁的多 当然 需要理解这一代码 <strong>就必须明白每一个java对象都有一个内部锁</strong> 并且该锁有一个内部条件 由锁来管理那些试图进入synchronized方法的进程 由条件来管理那些调用wait的线程</p><p>将<strong>静态方法声明为synchronized也是合法的</strong> 如果调用这种方法 <strong>该方法获得相关的类对象的内部锁</strong><br>列如：<strong>如果Bank有一个静态同步的方法 如果调用这方法 这个Bank.class就被锁住 因此 没有其他线程可以调用同一个类的这个或任何其他的同步静态方法</strong></p><p><strong>内部锁与条件在一起有一些限制</strong></p><p>不能中断一个正在试图获得锁的线程<br>试图获得锁不能设定超时<br>每个锁仅有单一的条件 可能是不够的</p><p><strong>有几个建议：</strong><br>在代码中 最好不要使用synchronized也不要使用Lock/Condition 在许多情况下可以使用java.util.concurrent包中的一种机制 它会处理所有的加锁</p><p>如果synchronized关键字适合程序的话 尽量选择synchronized 因为简洁 减少出错</p><p>只有在对Lock/Condition有特殊要求时 才去使用Lock/Condition</p><h4 id="同步阻塞"><a href="#同步阻塞" class="headerlink" title="同步阻塞"></a>同步阻塞</h4><p>每一个java对象都有一个锁 线程可以通过调用同步方法获得锁 还有另一种机制可以获得锁（其他不是当前的锁 而是其他的） 通过进入一个同步阻塞</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized (obj)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是获得了obj的锁<br>有时会发现 特别的锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    private  final  double[] accouts;</span><br><span class="line"></span><br><span class="line">        private Object lock = new Object();</span><br><span class="line"></span><br><span class="line">    public Bank(double[] accouts) &#123;</span><br><span class="line">         this.accouts = accouts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public void transfer(int from, int to, double amount) &#123;</span><br><span class="line"></span><br><span class="line">synchronized (lock) &#123;</span><br><span class="line">accouts[from] -= amount;</span><br><span class="line">accouts[to] += amount;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此 lock对象被创建仅仅是用来使用每个Java对象持有的锁</p><p>有时程序员使用一个对象的锁来实现额外的原子操作 实际上成为客户端锁定 比如Vector类 一个列表 它的方法是同步的 下面是代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public   void transfer3(Vector&lt;Double&gt; accounts2,int from, int to, double amount)  &#123;</span><br><span class="line">  accounts2.set(from,accounts2.get(from)-amount);</span><br><span class="line">accounts2.set(to, accounts2.get(to) + amount);</span><br><span class="line">System.out.println(&quot;....&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vector类的get方法和set方法是同步的 但是 在第一层调用完成之后 一个线程完全有可能在transfer方法中剥夺运行权 于是 另一可能在相同位置的存储位置存入不同的值 （虽然Vector类的get和set方法时同步的，但是，并没有什么用。在get之后set之前，线程完全有可能被剥夺运行权。于是，另一个线程可能在相同的存储位置存入不同的值。但是可以如下修改：）<br>但是 我们可以截获这个锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public   void transfer3(Vector&lt;Double&gt; accounts2,int from, int to, double amount)  &#123;</span><br><span class="line">synchronized (accounts2) &#123;</span><br><span class="line">     accounts2.set(from, accounts2.get(from) - amount);</span><br><span class="line">accounts2.set(to, accounts2.get(to) + amount);</span><br><span class="line">System.out.println(&quot;....&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样可以工作 但是 Vector类必须要对自己的所有可修改方法都能使用内部锁 否则就可能出错 但是Vector文档并没有这么说<br>所以客户端锁定是非常脆弱的 通常不建议使用</p><h3 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h3><p>锁和条件不是一种面向对象的概念 研究人员一直在视图寻找一种办法 可以在不需要程序考虑加锁的情况下 就能保证多线程的安全性 监视器就是其中最成功的解决办法之一<br>监视器的概念：<br><a href="http://ifeve.com/monitors-java-synchronization-mechanism/" target="_blank" rel="noopener">http://ifeve.com/monitors-java-synchronization-mechanism/</a><br><strong>其中监视器有如下特性</strong></p><p>监视器只包含私有域的类<br>每个监视器类对象有一个相关的锁<br>使用该锁对所有的方法进行加锁<br>该锁可以有任意多个相关条件</p><p><strong>但是java对象有不同于监视器的几个地方</strong><br>域不要求是private的<br>方法不要求必须是synchronized<br>内部锁对客户是可用的</p><p>使得监视器在java中线程的安全性有所下降</p><p>关于synchronized关键字的说明<br><a href="http://www.cnblogs.com/gnagwang/archive/2011/02/27/1966606.html" target="_blank" rel="noopener">http://www.cnblogs.com/gnagwang/archive/2011/02/27/1966606.html</a></p><h2 id="Volatile域"><a href="#Volatile域" class="headerlink" title="Volatile域"></a>Volatile域</h2><p>为了读写一个或俩个实例域就使用同步 实在是有点浪费性能 如果我们不用的话 在什么情况容易出错呢 使用现代的处理器与编译器 出错的可能性较大</p><p>多处理器的计算机能够暂时在寄存器或本地内存缓冲区保存内存的值 结果是 运行在不同处理器上的线程可能在同一个内存位置取到不同的值</p><p>编译器可以改变指令执行顺序以使吞吐量最大化<br>但是编译器假定内存的值仅仅在代码有显示的修改指令时才改变 然而 内存的值可以被另一个线程改变</p><p>原子性与可见性 有序性 都有问题<br><a href="http://blog.csdn.net/itachi85/article/details/50274169" target="_blank" rel="noopener">http://blog.csdn.net/itachi85/article/details/50274169</a> 这里有相关的博客讲解</p><p>如果使用锁来保护可以保护多个线程访问的代码 可以不考虑这个问题</p><p>一旦一个共享变量被volitile修饰之后 那么就具备了俩层语义</p><p>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。<br>禁止进行指令重排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   //线程1</span><br><span class="line">   boolean stop =false;</span><br><span class="line">while(!stop)&#123;</span><br><span class="line">  doSomething();</span><br><span class="line">&#125;</span><br><span class="line"> //线程2</span><br><span class="line">stop=true；</span><br></pre></td></tr></table></figure><p>很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。<br>为何有可能导致无法中断线程？每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。<br>但是用volatile修饰之后就变得不一样了：</p><ul><li>使用volatile关键字会强制将修改的值立即写入主存；</li><li>使用volatile关键字的话，当线程2进行修改时，会导致线程1的工- 作内存中缓存变量stop的缓存行无效；</li><li>由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</li></ul><p>这里需要警告的是 <strong>Volitile变量是不能提供原子性的操作的</strong></p><p>synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性<br>。通常来说，使用volatile必须具备以下2个条件：</p><ul><li>对变量的写操作不依赖于当前值</li><li>该变量没有包含在具有其他变量的不变式中</li></ul><p>第一个条件就是不能是自增自减等操作，上文已经提到volatile不保证原子性。<br>第二个条件我们来举个例子它包含了一个不变式 ：下界总是小于或等于上界</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class NumberRange &#123;</span><br><span class="line">public  volatile int lower,upper;</span><br><span class="line"></span><br><span class="line">public int getLower() &#123;</span><br><span class="line">    return  lower;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getUpper() &#123;</span><br><span class="line">    return upper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setLower(int value)  &#123;</span><br><span class="line">    if (value &gt; upper)</span><br><span class="line">        throw new IllegalArgumentException(&quot;...&quot;);</span><br><span class="line">    lower=value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void setUpper(int value) &#123;</span><br><span class="line">    if (value &lt; lower)</span><br><span class="line">        throw new IllegalArgumentException(&quot;...&quot;);</span><br><span class="line">    upper = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/discuss/4324?type=0&amp;order=0&amp;pos=199&amp;page=1" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/4324?type=0&amp;order=0&amp;pos=199&amp;page=1</a><br>这种方式限制了范围的状态变量，因此将 lower 和 upper 字段定义为 volatile 类型不能够充分实现类的线程安全，从而仍然需要使用同步。否则，如果凑巧两个线程在同一时间使用不一致的值执行 setLower 和 setUpper 的话，则会使范围处于不一致的状态。例如，如果初始状态是 (0, 5)，同一时间内，线程 A 调用 setLower(4) 并且线程 B 调用 setUpper(3)，显然这两个操作交叉存入的值是不符合条件的，那么两个线程都会通过用于保护不变式的检查，使得最后的范围值是 (4, 3)，这显然是不对的。</p><p>Volatile 变量是一种非常简单但同时又非常脆弱的同步机制，它在某些情况下将提供优于锁的性能和伸缩性</p><p>这下面俩个链接是关于JVM内存模型的具体讲解<br><a href="http://www.infoq.com/cn/articles/java-memory-model-1" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/java-memory-model-1</a><br><a href="http://wiki.jikexueyuan.com/project/java-memory-model/reorder.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/java-memory-model/reorder.html</a></p><p>关于volatile的具体使用模式讲解<br><a href="http://www.ibm.com/developerworks/cn/java/j-jtp06197.html" target="_blank" rel="noopener">http://www.ibm.com/developerworks/cn/java/j-jtp06197.html</a></p><p><strong>final变量</strong></p><p>在上面已经知道 除非使用锁或者volatile修饰符 否则无法多个线程安全的读取一个域</p><p>与前面介绍的锁和volatile相比较，<strong>对final域的读和写更像是普通的变量访问</strong>（定义为final的字段只初始化一次，在正常情况下将不能再被改变）。对于final域，<strong>编译器和处理器要遵守两个重排序规则</strong>：</p><ul><li><p>在<strong>构造函数</strong>内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</p></li><li><p>初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。</p><p>final Map&lt;String,Double&gt;accounts=new HashMap();<br>其他线程会在构造函数完成构造之后才看到这个accounts</p></li></ul><p>如果不是使用final的话 就不能保证其他线程看到的是accounts更新后的值 它们可能都只是看到null 而不是新构建的HashMap&lt;&gt;<br>当然 <strong>对这个映射表的操作并不是线程安全的 如果多个线程在读写这个映射表 仍然需要同步</strong></p><p><strong>原子性</strong></p><p>假设对共享变量除了赋值之外并不完成其他操作 那么可以将这些共享变量声明为volatile<br>在java.util.concurrent.atomic包中有很多类使用了很高效的机器级指令（而不是使用锁）来保证其他操作的原子性</p><p><strong>死锁</strong><br>在多线程中 锁和条件不能解决多线程中的所有问题<br>账户 1 $200<br>账户 2 $300<br>线程1 从账户一转移300元到账户2<br>线程2 从账号2转移400元到账户一<br>这样就出错了 这就是死锁的一种形式 因为账户一和账户二的余额都不能完成工作 俩个线程无法执行下去 这样就有可能因为每一个线程要等待更多的钱款存入而导致所有的线程都阻塞 这样的状态被称为死锁</p><p>我们回到开始的列子 银行转账</p><ol><li>如果我们将最大金额改变不为1000元 就会进行出错 也是上面写的原因</li><li>如果我们将toaccount与formaccount的参数变换位置的话 也会导致出错 这是因为线程一直在试图想转账超过这个账号目前拥有的金额</li><li>还有一种 就是将signalAll方法改为signal方法 也会导致出错 根本原因是 它仅仅是一个线程解锁 而且 它很有可能选择一个不能继续运行的线程</li></ol><p>但是 <strong>java编程语言是没有任何东西可以避免或打破这种死锁现象 必须仔细设计程序 以确保不会出现死锁</strong></p><h2 id="线程局部变量"><a href="#线程局部变量" class="headerlink" title="线程局部变量"></a>线程局部变量</h2><p>有时可能要避免共享变量 使用ThreadLocal辅助类为各个线程提供各自的实例</p><p>比如：<br>有下面这么一个静态变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static final SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br></pre></td></tr></table></figure><p>如果俩个线程都执行如下操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String dateStamp = dateFormat.format(new Date());</span><br></pre></td></tr></table></figure><p>因为dateFormat使用的内部数据结构可能会被并发的访问所破坏 当然可以使用同步 但开销很大 或者也可以在需要时构造时构造一个局部SimpleDateFormat 但是这也很浪费</p><p>如果要为每个线程构造一个实例 可以像下面一样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static final ThreadLocal&lt;SimpleDateFormat&gt; dateFormat = new ThreadLocal&lt;SimpleDateFormat&gt;()&#123;</span><br><span class="line">protected SimpleDateFormatinitialValue() &#123;</span><br><span class="line">return new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>要访问具体的格式化方法 可以像下面这样调用就可以达到 调用get方法会返回当前线程的那个实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String dateStamp = dateFormat.get().format(new Date());</span><br></pre></td></tr></table></figure><p>在多线程中生成随机数也会出现这样的问题</p><p><strong>Random类是线程安全的 但是如果多个线程需要等待一个共享的随机数生成器 这会很低效</strong><br>可以使用ThreadLocal辅助类为各个线程提供一个单独的生成器 不过Java SE7还另外提供了一个类 只需要做以下调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int random= ThreadLocalRandom.current().nextInt(upperBound);</span><br></pre></td></tr></table></figure><p><strong>ThreadLocalRandom.current()调用会返回特定于当前线程的Random实例</strong></p><p><a href="http://blog.csdn.net/ruyun126/article/details/5955260" target="_blank" rel="noopener">http://blog.csdn.net/ruyun126/article/details/5955260</a> ThreadLocal原理<br><strong>锁测试与超时</strong><br>下面的链接是关于锁测试与超时的博客<br><a href="http://blog.csdn.net/xxxknight/article/details/47057417" target="_blank" rel="noopener">http://blog.csdn.net/xxxknight/article/details/47057417</a><br>线程在调用lock方法来获得另一个线程所持有的锁的时候 很可能发生阻塞 应该更加谨慎的申请锁 tryLock方法试图申请一个锁 在成功获得锁之后返回true 否则 立即返回false 而且线程可以立即离开去做其他事情<br>可以调用tryLock时，使用超时参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(myLock.tryLock())&#123;</span><br><span class="line">try&#123;&#125;finally &#123;</span><br><span class="line">myLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"> &#125;else&#123;</span><br><span class="line">//dosomething</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以调用tryLock时 使用超时函数 像这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(myLock.tryLock(100, TimeUnit.MICROSECONDS))&#123;</span><br></pre></td></tr></table></figure><p>lock方法不能被中断。如果一个线程在等待获得一个锁时被中断，中断线程在获得锁之前一直处于阻塞状态。如果出现死锁，那么，lock方法就无法终止。<br>如果调用带有超时参数的trylock 那么如果线程在等待期间被打断 将抛出InterruptedException异常 这是一个非常有用的特性 可以打断异常</p><p>也可以调用lockInterruptibly方法 它就相当于一个超时设为无限的trylock方法<br>在等待一个条件时 也可以设置超时的 这在前面有说过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myCondition.await(100, TimeUnit.DAYS);</span><br></pre></td></tr></table></figure><p>如果一个线程被另一个线程通过调用signalAll或signal激活 或时限已到 或线程被中断 那么await方法将返回</p><p>如果等待的线程被中断 await方法将抛出一个InterruptedException异常 如果你希望出现这种情况时线程继续等待 可以使用awaitUninterruptibly方法代替await</p><p><strong>读/写锁</strong><br>在java.util.concurrent.locks包类中定义了俩个类 我们已经讨论过的ReentrantLock类和ReentrantReadWriteLock类 如果很多线程从一个数据结构读取数据而很少线程修改其中数据的话 后者是十分有用的 在这种情况下 <strong>允许对读者线程共享是合适的 当然 写者线程依然是必须是互斥访问</strong>的 （多个读锁之间是不需要互斥的(读操作不会改变数据，如果上了锁，反而会影响效率）)这里粘贴一个<br>使用的博客 <a href="http://blog.csdn.net/lzm1340458776/article/details/27964243" target="_blank" rel="noopener">http://blog.csdn.net/lzm1340458776/article/details/27964243</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//构造一个ReentrantReadWriteLock对象</span><br><span class="line">private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();</span><br><span class="line">//抽取读锁和写锁</span><br><span class="line">private Lock readLock = rwl.readLock();</span><br><span class="line">private Lock writeLock = rwl.writeLock();</span><br><span class="line">//对所有的获取方法加读锁</span><br><span class="line">public  double getTotalBalance() &#123;</span><br><span class="line">readLock.lock();</span><br><span class="line">    try&#123;</span><br><span class="line">//......</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">readLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">//对所有的修改方法加写锁</span><br><span class="line">public  void transfer(/*......*/) &#123;</span><br><span class="line">writeLock.lock();</span><br><span class="line">    try&#123;/*...*/&#125;</span><br><span class="line">finally &#123;</span><br><span class="line">writeLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关于为什么弃用Stop和suspend方法</strong></p><p>在初始版的java中 采用了俩个方法来进行对线程的控制 一个是stop方法来进行终止线程 一个是suspend方法来组织一个线程直至另一个线程调用resume <strong>stop方法和suspend方法都有一个共同点 都试图控制一个给定线程的行为</strong></p><p>其实stop方法天生就不安全，因为它在终止一个线程时会强制中断线程的执行，不管run方法是否执行完了，并且还会释放这个线程所持有的所有的锁对象。这一现象会被其它因为请求锁而阻塞的线程看到，使他们继续向下执行。这就会造成数据的不一致，我们还是拿银行转账作为例子，我们还是从A账户向B账户转账500元，我们之前讨论过，这一过程分为三步，第一步是从A账户中减去500元，假如到这时线程就被stop了，那么这个线程就会释放它所取得锁，然后其他的线程继续执行，这样A账户就莫名其妙的少了500元而B账户也没有收到钱。注意 这个过程是无法知晓的 这就是stop方法的不安全性。</p><p>suspend方法为什么被弃用</p><p>suspend被弃用的原因是因为它会造成死锁。suspend方法和stop方法不一样，它不会破换对象和强制释放锁，<strong>相反它会一直保持对锁的占有，一直到其他的线程调用resume方法，它才能继续向下执行。</strong><br>假如有A，B两个线程，A线程在获得某个锁之后被suspend阻塞，这时A不能继续执行，线程B在或者相同的锁之后才能调用resume方法将A唤醒，但是此时的锁被A占有，B不能继续执行，也就不能及时的唤醒A，此时A，B两个线程都不能继续向下执行而形成了死锁。这就是suspend被弃用的原因。<br>这种状况在图形界面中经常发生。<br><strong>这里需要注明 这本书里用的是图形化的例子来说明suspend为什么被弃用</strong></p><p>如果想安全的挂起线程，引入一个变量suspendRequested并在run方法安全的地方测试它，安全的地方是指该线程没有封锁其他线程需要的对象的地方。当线程发现如果变量已被设置，将会保持等待状态直到它再次被获得为止。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public volatile boolean suspendRequested = false;  </span><br><span class="line">private Lock suspendLock = new ReentrantLock();  </span><br><span class="line">private Condition suspendCondition = suspendLock.newCondition();  </span><br><span class="line"></span><br><span class="line">public void run() &#123;  </span><br><span class="line"></span><br><span class="line">    while (true) &#123;  </span><br><span class="line">        if (suspendRequested) &#123;  </span><br><span class="line">            suspendLock.lock();  </span><br><span class="line">            try &#123;  </span><br><span class="line">                while (suspendRequested)  </span><br><span class="line">                    suspendCondition.await();  </span><br><span class="line">            &#125; catch (Exception e) &#123;  </span><br><span class="line"></span><br><span class="line">            &#125; finally &#123;  </span><br><span class="line">                suspendLock.unlock();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">public void requestSuspend() &#123;  </span><br><span class="line">    suspendRequested = true;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">public void requestResume() &#123;  </span><br><span class="line">    suspendRequested = false;  </span><br><span class="line">    suspendLock.lock();  </span><br><span class="line">    try &#123;  </span><br><span class="line">        suspendCondition.signalAll();  </span><br><span class="line">    &#125; catch (Exception e) &#123;  </span><br><span class="line">        e.printStackTrace();  </span><br><span class="line">    &#125; finally &#123;  </span><br><span class="line">        suspendLock.unlock();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://blog.csdn.net/xingjiarong/article/details/47984659" target="_blank" rel="noopener">http://blog.csdn.net/xingjiarong/article/details/47984659</a> 这里是博客相关的讲解</p><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>对于实际的编程开发来说 应该尽可能的远离底层结构 使用由并发处理的专业人士实现的较高层次的结构要方便的安全的多</p><p>对于许多安全问题 都可以使用一个或多个队列以优雅的方式将其形式化 生产者线程向队列插入元素 消费者线程则取出他们 <strong>使用队列 可以安全的从一个线程向另外一个线程传递数据</strong></p><p>当试图向队列添加元素而队列已满 或是想从队列移出元素而队列为空的时候 阻塞队列导致线程阻塞 在协调多个线程之间的合作 阻塞队列是一个有用的工具 工作者线程可以周期性的将中间结果存储在阻塞队列中 其他的工作者线程移出中间结果并进一步加以修改 队列会自动地平衡负载</p><p>1.非阻塞队列中的几个主要方法：</p><ul><li>add(E e):将元素e插入到队列末尾，如果插入成功，则返回true；如果插入失败（即队列已满），则会抛出异常；</li><li>remove()：移除队首元素，若移除成功，则返回true；如果移除失败（队列为空），则会抛出异常；</li><li>offer(E e)：将元素e插入到队列末尾，如果插入成功，则返回true；如果插入失败（即队列已满），则返回false；</li><li>poll()：移除并获取队首元素，若成功，则返回队首元素；否则返回null；</li><li>peek()：获取队首元素，若成功，则返回队首元素；否则返回null</li></ul><p>对于非阻塞队列，一般情况下建议使用offer、poll和peek三个方法，不建议使用add和remove方法。因为使用offer、poll和peek三个方法可以通过返回值判断操作成功与否，而使用add和remove方法却不能达到这样的效果。注意，非阻塞队列中的方法都没有进行同步措施。<br>2.阻塞队列中的几个主要方法：<br><strong>阻塞队列包括了非阻塞队列中的大部分方法，上面列举的5个方法在阻塞队列中都存在</strong>，但是要注意这5个方法在阻塞队列中都进行了同步措施。除此之外，阻塞队列提供了另外4个非常有用的方法：</p><ul><li>put(E e)</li><li>take()</li><li>offer(E e,long timeout, TimeUnit unit)</li><li>poll(long timeout, TimeUnit unit)</li><li>put方法用来向队尾存入元素，如果队列满，则等待；</li><li>take方法用来从队首取元素，如果队列为空，则等待；</li><li>offer方法用来向队尾存入元素，如果队列满，则等待一定的时间，当时间期限达到时，如果还没有插入成功，则返回false；否则返回true；</li><li>poll方法用来从队首取元素，如果队列空，则等待一定的时间，当时间期限达到时，如果取到，则返回null；否则返回取得的元素</li></ul><table><thead><tr><th style="text-align:left">方法\处理方式</th><th style="text-align:left">抛出异常</th><th style="text-align:left">返回特殊值</th><th style="text-align:left">一直阻塞</th><th style="text-align:left">超时退出</th></tr></thead><tbody><tr><td style="text-align:left">插入方法</td><td style="text-align:left">add(e)</td><td style="text-align:left">offer(e)</td><td style="text-align:left">put(e)</td><td style="text-align:left">offer(e,time,unit)</td></tr><tr><td style="text-align:left">移除方法</td><td style="text-align:left">remove()</td><td style="text-align:left">poll()</td><td style="text-align:left">take()</td><td style="text-align:left">poll(time,unit)</td></tr><tr><td style="text-align:left">检查方法</td><td style="text-align:left">element()</td><td style="text-align:left">peek()</td><td style="text-align:left">不可用</td><td style="text-align:left">不可用</td></tr></tbody></table><ul><li>抛出异常：是指当阻塞队列满时候，再往队列里插入元素，会抛出IllegalStateException(“Queue full”)异常。当队列为空时，从队列里获取元素时会抛出NoSuchElementException异常 。</li><li>返回特殊值：插入方法会返回是否成功，成功则返回true。移除方法，则是从队列里拿出一个元素，如果没有则返回null</li><li>一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到拿到数据，或者响应中断退出。当队列空时，消费者线程试图从队列里take元素，队列也会阻塞消费者线程，直到队列可用。</li><li>超时退出：当阻塞队列满时，队列会阻塞生产者线程一段时间，如果超过一定的时间，生产者线程就会退出</li></ul><p>还有带有超时的offer方法和poll方法的变体 下面是尝试在100毫秒内在队列的尾部插入一个元素 如果成功返回true 否则 达到超时时 就返回null</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean success=q.offer(x,100,TimeUnit.MTLLSECONDS);</span><br></pre></td></tr></table></figure><p>下面的调用尝试在100毫秒的时间内移出队列的头元素 如果成功返回头元素 否则 达到超时时 返回null</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object head =q.poll(100mTimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><p>如果队列慢 则put方法阻塞 如果队列空 则take方法阻塞 在不带超时参数时 offer和poll方法等效<br>JDK7提供以下7种阻塞队列</p><ul><li>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。</li><li>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。</li><li>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。</li><li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</li><li>SynchronousQueue：一个不存储元素的阻塞队列。</li><li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li><li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列</li></ul><p>在concurrent包中提供了阻塞队列的几个变种 默认情况下 <strong>LinkedBlockingQueue</strong>的容量是没有上边界的 但是 也可以选择指定最大容量 <strong>LinkedBlockingDeque</strong>是一个双端的版本 <strong>ArrayBlockingQueue</strong> 在构造时需要指定容量 并且一个可选的采纳数来指定是否需要公平性<br>若设置公平参数 则那么等待了最长时间的线程会优先得到处理 通常 公平性会降低性能 只有确实非常需要时才使用它<br><strong>PriorityBlockingQueue</strong>是一个带优先级的队列 而不是先进先出的队列 元素按照它们的优先级顺序被移出<br>该队列是没有容量上限 但是 如果队列是空的 取元素的超时会阻塞<br>最后<strong>DelayQueue</strong>包含实现了Delayed接口的对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface  Delayed extends Comparator&lt;Delayed&gt;</span><br><span class="line">&#123;</span><br><span class="line">long getDelay(TimeUnit unit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>getDealy方法返回对象的残留延迟</strong> 负值表示延迟已经结束 元素只有在延迟用完的情况下才会从DelayQueue移出 还必须实现compareTo方法 DelayQueue使用该方法对元素进行排序<br>元素只有在延迟用完的情况下才能从DelayQueue移出<br>另外在java7增加了一个<strong>TranferQueue</strong>接口 允许生成线程等待 直到消费者准备就绪可以接受一个元素<br>如果调用 q.transfer(item);这个调用会阻塞 直到另一个线程将元素(item)删除 <strong>LinkedTransferQueue</strong>类实现了这个接口<br>下面是一个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">import java.util.*;</span><br><span class="line">import java.util.concurrent.*;</span><br><span class="line">/**</span><br><span class="line"> * Created by han on 2016/8/1.</span><br><span class="line"> */</span><br><span class="line">public class blockingQueue &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Scanner in = new Scanner(System.in);</span><br><span class="line">System.out.print(&quot;Enter base directory(e.g. C:\\Program Files\\Java\\jdk1.8.0_73\\);&quot;);</span><br><span class="line">String directory = in.nextLine();</span><br><span class="line">System.out.println(&quot;Enter keyword (e.g volatile);&quot;);</span><br><span class="line">String keyword = in.nextLine();</span><br><span class="line">        final  int FILE_QUEUE_SIZE=10;</span><br><span class="line">        final  int SARCH_THREADS=100;</span><br><span class="line"></span><br><span class="line">BlockingQueue&lt;File&gt; queue = new ArrayBlockingQueue&lt;File&gt;(FILE_QUEUE_SIZE);</span><br><span class="line">FileEnumerationTask enumerator = new FileEnumerationTask(queue, new File(directory));</span><br><span class="line">        new Thread(enumerator).start();</span><br><span class="line">        for (int i = 0; i &lt;SARCH_THREADS ; i++) &#123;</span><br><span class="line">new Thread(new SearchTask(queue,keyword)).start();</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class FileEnumerationTask implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">    public static File DUMMY = new File(&quot;&quot;);</span><br><span class="line">    private BlockingQueue&lt;File&gt; queue;</span><br><span class="line">    private File startingDirectory;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">     * Constructs a FileEnumerationTask.</span><br><span class="line">     * @param queue the blocking queue to which the enumerated files are added</span><br><span class="line">     * @param startingDirectory the directory in which to start the enumeration</span><br><span class="line">     */</span><br><span class="line">public FileEnumerationTask(BlockingQueue&lt;File&gt; queue, File startingDirectory)</span><br><span class="line">    &#123;</span><br><span class="line">        this.queue = queue;</span><br><span class="line">        this.startingDirectory = startingDirectory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void run()</span><br><span class="line">    &#123;</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">            enumerate(startingDirectory);</span><br><span class="line">            queue.put(DUMMY);</span><br><span class="line">&#125;</span><br><span class="line">catch (InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">     * Recursively enumerates all files in a given directory and its subdirectories.</span><br><span class="line">     * @param directory the directory in which to start</span><br><span class="line">     */</span><br><span class="line">public void enumerate(File directory) throws InterruptedException</span><br><span class="line">    &#123;</span><br><span class="line">        File[] files = directory.listFiles();</span><br><span class="line">        for (File file : files)</span><br><span class="line">        &#123;</span><br><span class="line">if (file.isDirectory()) enumerate(file);</span><br><span class="line">            else queue.put(file);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SearchTask implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">private BlockingQueue&lt;File&gt;queue;</span><br><span class="line">    private String keyword;</span><br><span class="line">    public  SearchTask(BlockingQueue&lt;File&gt; queue,String keyword) &#123;</span><br><span class="line">        this.queue=queue;</span><br><span class="line">        this.keyword = keyword;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">boolean done = false;</span><br><span class="line">        while (!done) &#123;</span><br><span class="line">            File file = queue.take();</span><br><span class="line">            if(file ==FileEnumerationTask.DUMMY) &#123;</span><br><span class="line">            queue.put(file);</span><br><span class="line">            done = true;</span><br><span class="line">&#125;</span><br><span class="line">        else search(file);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">catch (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">catch (InterruptedException e)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public void search(File file) throws IOException</span><br><span class="line">    &#123;</span><br><span class="line">try (Scanner in = new Scanner(file))</span><br><span class="line">        &#123;</span><br><span class="line">              int lineNumber = 0;</span><br><span class="line">            while (in.hasNextLine())</span><br><span class="line">            &#123;</span><br><span class="line">                lineNumber++;</span><br><span class="line">                String line = in.nextLine();</span><br><span class="line">                if (line.contains(keyword))</span><br><span class="line">                    System.out.printf(&quot;%s:%d:%s%n&quot;, file.getPath(), lineNumber, line);</span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个具体的作用在书中有所介绍</p><p>在这个列子我们将队列数据结构作为一种同步机制</p><h2 id="线程安全的集合"><a href="#线程安全的集合" class="headerlink" title="线程安全的集合"></a>线程安全的集合</h2><h3 id="高效的散列表-集合和队列"><a href="#高效的散列表-集合和队列" class="headerlink" title="高效的散列表 集合和队列"></a>高效的散列表 集合和队列</h3><p>在java.util.concurrent包中提供了散列表 有序集和队列的高效实现 ConcurrentHashMap ,ConcurrentSkipMap ConcurrentSkipListSet和ConcurrentLinkedQuerue<br>这些集合使用复杂的算法 通过允许并发的访问数据结构的不同部分来使竞争条件极小化<br>这里与大部分集合不同的是 size方法不必在常量时间内操作 <strong>要确定这样的集合当前的大小需要遍历</strong><br>集合返回<strong>弱一致性</strong>的迭代器 这<strong>意味着迭代器不一定能反映出它们被构造之后的所有的修改</strong> 但是 它们不会将同一个值返回俩次 也不会抛出ConcurrentModiicationException<br>如果<strong>集合在迭代器之后发生改变</strong> java.util包中的迭代器则会抛出一个ConcurrentModiicationException异常<br>并发的线程列表 可高效地支持大量的读者和一定数量的写者<br><strong>ConcurrentHashMap和ConcurrentSkipListMap类有相应的方法用于原子性的关联插入以及关联删除</strong> putifAbsent方法自动地添加新的关联 前提是原来没有这一关联 对于多线程访问的缓存来说这是非常有用的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> ConcurrentHashMap cache = new ConcurrentHashMap();</span><br><span class="line">//确保只有一个线程向缓存添加项</span><br><span class="line">cache.putIfAbsent(key, value);</span><br><span class="line">//相反的操作是删除</span><br><span class="line">cache.remove(key, value);</span><br><span class="line">//将原子性地删除键值对 如果它们在映像表出现的话 最后</span><br><span class="line">cache.replace(key, oldvalue, newvalue);</span><br><span class="line">//原子性地用新值替换旧值</span><br></pre></td></tr></table></figure><h3 id="写数组的拷贝"><a href="#写数组的拷贝" class="headerlink" title="写数组的拷贝"></a>写数组的拷贝</h3><p>CopyOnWriteArrayList和CopyWriteArraySet是线程安全的集合 其中所有的修改线程对底层数组进行复制<br>如果在<strong>集合上进行迭代的线程数超过修改线程数</strong> 这样的安排是很有用的</p><p><strong>较早的线程安全集合</strong></p><p>较早的线程安全集合比如vector和hashtable 目前这俩个已经被弃用了 代替的是Arraylist和HashMap 当然Arraylist和HashMap本身也不是线程安全的<br>但是集合框架提供了不同的机制 任何的集合都可以通过使用同步包装器变为线程安全的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List synchArrayList = Collections.synchronizedList(new ArrayList&lt;&gt;());</span><br><span class="line">Map synchHashMap = Collections.synchronizedMap(new HashMap&lt;&gt;());</span><br></pre></td></tr></table></figure><p>结果集合的方法使用锁加以保护 提供了线程的安全访问<br>应该<strong>确保没有任何线程通过原始的非同步方法访问数据结构</strong> 最便利的方法是确保不保存任何指向原始对象的引用 简单的构造一个集合并立即传递给包装器 像我们的列中中所做的那样</p><p>如果在另一个集合可能进行修改时要对集合进行迭代 仍然需要使用“客户端”编程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronized (synchHashMap) &#123;</span><br><span class="line">Iterator iter = synchHashMap.keySet().iterator();</span><br><span class="line">while (iter.hasNext()) ..........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用<strong>foreach的话就必须使用同样的代码</strong> 因为集合使用了迭代器 注意 如果在迭代过程中 别的线程修改集合 迭代器会失效 抛出ConcurrentModiicationException异常 同步仍然是需要的 因此并发的修改可以被可靠的检测出来</p><p>最好使用的是在java.util.concurrent中定义的集合 不使用同步包装器中的 特别是<br>假如他们访问的是不同的桶 由于ConcurrentHashMap已经精心实现了 多线程可以访问它而且不会彼此阻塞<br>但是<strong>有一个例外就是经常被修改的数组列表</strong> 在那种情况下 使用同步器包装的ArrayList比CopyWriteArrayList要好</p><h3 id="Callable和Future"><a href="#Callable和Future" class="headerlink" title="Callable和Future"></a>Callable和Future</h3><p><a href="http://blog.csdn.net/ghsau/article/details/7451464" target="_blank" rel="noopener">http://blog.csdn.net/ghsau/article/details/7451464</a> 具体讲解<br>Runable封装了一个异步运行的任务 可以把它想象为一个没有参数和返回值的异步方法<br>Callable和Future，它俩很有意思的，一个产生结果，一个拿到结果。<br>Callable接口类似于Runnable，从名字就可以看出来了，但是Runnable不会返回结果，并且无法抛出返回结果的异常，而Callable功能更强大一些，被线程执行后，可以返回值，这个返回值可以被Future拿到，也就是说，Future可以拿到异步执行任务的返回值，</p><p>Callable是一个没有参数和返回值的类型 只有一个方法 call<br>其中的类型参数是返回值的类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">/**</span><br><span class="line">     * Computes a result, or throws an exception if unable to do so.</span><br><span class="line">     *</span><br><span class="line">     * @return computed result</span><br><span class="line">     * @throws Exception if unable to compute a result</span><br><span class="line">     */</span><br><span class="line">V call() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Future是<strong>保存异步计算的结果</strong> 可以启动一个计算 将Future对象交给某个线程 然后忘掉它 Future对象的所有者在结果计算好之后就可以获得它</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public interface Future&lt;V&gt; &#123;</span><br><span class="line"></span><br><span class="line">boolean cancel(boolean mayInterruptIfRunning);</span><br><span class="line"></span><br><span class="line">boolean isCancelled();</span><br><span class="line"></span><br><span class="line">boolean isDone();</span><br><span class="line">    V get() throws InterruptedException, ExecutionException;</span><br><span class="line"></span><br><span class="line">V get(long timeout, TimeUnit unit)</span><br><span class="line">throws InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>get方法的调用被阻塞 直到计算完成</strong> 如果在计算完成之前 第二个get方法的调用超时 抛出一个TimeoutException异常 如果运行该计算的线程被中断 俩个方法都将抛出InterruptedException 如果计算已经完成 那么get方法立即返回</p><p>如果计算还在运行 isDone方法返回false 如果完成了 返回true<br>可以用cancel方法取消该运算 如果计算还没开始 它被取消且不再开始 如果计算处于运行之中 那么如果mayinteruptifRunning参数为true 它就被中断</p><p><strong>FutureTask包装器</strong>是一种很有用的包装器 <strong>可以将Callable转换为Future和Runable 它同时实现了俩者的接口</strong></p><p><strong>FutureTask实现了两个接口，Runnable和Future</strong>，所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值，那么这个组合的使用有什么好处呢？假设有一个很耗时的返回值需要计算，并且这个返回值不是立刻需要的话，那么就可以使用这个组合，用另一个线程去计算返回值，而当前线程在使用这个返回值之前可以做其它的操作，等到需要这个返回值时，再通过Future得到，岂不美哉！这里有一个Future模式的介绍：<a href="http://openhome.cc/Gossip/DesignPattern/FuturePattern.htm。" target="_blank" rel="noopener">http://openhome.cc/Gossip/DesignPattern/FuturePattern.htm。</a></p><p>下面就是一个关于这Callable和Future 的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">import java.util.concurrent.Callable;</span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line">import java.util.concurrent.Future;</span><br><span class="line">import java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line">/*** Created by han on 2016/11/3.*/</span><br><span class="line">public class FutureTest &#123;</span><br><span class="line">public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">    Scanner in = new Scanner(System.in);</span><br><span class="line">    System.out.println(&quot;Enter base directory (e.g /user/local/jdk5.0/src)&quot;);</span><br><span class="line">    String directory = in.nextLine();</span><br><span class="line">    System.out.println(&quot;Enter keyword(e.ge volatile)&quot;);</span><br><span class="line">    String keyword = in.nextLine();</span><br><span class="line"></span><br><span class="line">    MatchCounter counter = new MatchCounter(new File(directory), keyword);</span><br><span class="line">    FutureTask&lt;Integer&gt; task = new FutureTask&lt;Integer&gt;(counter);</span><br><span class="line">    Thread t = new Thread(task);</span><br><span class="line">    t.start();</span><br><span class="line">    System.out.println(task.get()+&quot;matching files&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;class  MatchCounter implements Callable&lt;Integer&gt;&#123;</span><br><span class="line"></span><br><span class="line">private File directory;</span><br><span class="line">private int count;</span><br><span class="line">private  String keyword;</span><br><span class="line"></span><br><span class="line">public MatchCounter( File directory,String keyword) &#123;</span><br><span class="line">    this.keyword = keyword;</span><br><span class="line">    this.directory = directory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Integer call() throws Exception &#123;</span><br><span class="line">    count=0;</span><br><span class="line">    File[] files = directory.listFiles();</span><br><span class="line">    List&lt;Future&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;();</span><br><span class="line">    for (File file:files)</span><br><span class="line">    if(file.isDirectory()) &#123;</span><br><span class="line">        MatchCounter counter = new MatchCounter(file,keyword);</span><br><span class="line">        FutureTask&lt;Integer&gt; task = new FutureTask&lt;Integer&gt;(counter);</span><br><span class="line">        results.add(task);//  这里是查找目录下查找的线程</span><br><span class="line">        Thread thread = new Thread(task);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">     if(search(file)) count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (Future&lt;Integer&gt; result:results) &#123;</span><br><span class="line">        count += result.get();//这里是将其他线程查找的结果与当前相加</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 查找文件中是否包含指定词</span><br><span class="line"> * @param file 要查找的文件</span><br><span class="line"> * @return 查找到为true  没有则为false</span><br><span class="line"> */</span><br><span class="line">public  boolean search(File file) &#123;</span><br><span class="line">    try (Scanner in = new Scanner(file)) &#123;</span><br><span class="line">    boolean found=false;</span><br><span class="line">        while (!found &amp;&amp; in.hasNextLine()) &#123;</span><br><span class="line">            String line = in.nextLine();</span><br><span class="line">            if(line.contains(keyword)) found = true;</span><br><span class="line">        &#125;</span><br><span class="line">        return found;</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">        System.out.println(e.getMessage());</span><br><span class="line">        return  false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p><strong>构造一个新的线程是有代价的</strong> 因为涉及与操作系统的交互 如果程序中创建了大量的生命周期很短的线程 应该使用线程池 一个线程池中包含许多准备运行的空闲线程 将Runable对象交给线程池 就会有一个线程调用run方法 当run方法退出时 线程不会死亡 而是在池中准备下一个请求提供服务<br>另一个使用<strong>线程池的理由时减少并发的数目</strong> 创建大量的线程会大大降低性能甚至使虚拟机崩溃 如果有一个会创建许多线程的算法 应该使用一个线程数 固定的线程池以限制并发线程的总数</p><p>执行器类有许多静态工厂方法用来构造线程池<br><a href="http://ifeve.com/java7-concurrency-cookbook-3/这是执行器的详细讲解" target="_blank" rel="noopener">http://ifeve.com/java7-concurrency-cookbook-3/这是执行器的详细讲解</a></p><ol><li>newCachedThreadPool<br>必要时创建新线程 空闲线程会被保持60秒</li><li>newFixedThreadPool<br>该池包含固定数量的线程 空闲线程会一直被保留</li><li>newSingleThreadExcutor<br>只有一个线程的池 该程序顺序执行每一个提交的任务</li><li>newScheduledThreadPool<br>用于预定执行而构建的固定线程池 替代java.util.Timer</li><li>newSingleThreadScheduledExecutor 用于执行而构建的单线程池</li></ol><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p><strong>newChchedThreadPool</strong>方法构建了一个线程池 对于每个任务 如果有空闲线程可用 立即让它执行任务 如果没有可用的空闲线程 则创建一个新线程<br><strong>newFixedThreadPool</strong>方法构建了具有固定大小的线程池 如果提交的任务数多于空闲的线程数 那么把得不到服务的任务放置到队列中 当其他任务完成以后再运行它们 <strong>newSingleThreadExcutor</strong>是一个退化了的大小为1的线程池 由一个线程执行提交的任务 一个接着一个 这3个方法返回实现了<strong>ExecitorService</strong>接口的<strong>ThreadPoolExecutor</strong>类的对象</p><p>可用下面的方法之一 将一个Runnable对象或Callable对象提交给ExecutorService</p><ul><li>Future&lt;?&gt; submit(Runnable task)</li><li>Future submit(Runnable task,T result)</li><li>Future submit(Callable task)</li></ul><p>该池会在方便的时候尽早执行提交的任务 调用submit 会得到一个Future对象 可用来查询该任务的状态</p><p>第一个submit方法返回一个奇怪样子的Future&lt;?&gt; 可用使用这样一个对象来调用isDone cancel或isCancelld 但是 get方法在完成的时候只是简单的返回null<br>第二个submit方法也提交一个Runnable 并且Future的get方法在完成的时候返回指定的result对象<br>第三个submit方法提交一个Callable 并且返回Future对象将在计算结果准备好的时候得到它</p><p>当用完一个线程池的时候 调用shutdown 该方法启动该池的关闭序列 被关闭的执行器不再接受新的任务 当所有任务都完成后 线程池的线程死亡 另一种方法是调用shudownNow 该池取消尚未开始的所有任务并试图中断正在运行的线程</p><p><strong>下面总结了在连接池应该做的事</strong><br>1 调用Exectors类中静态的方法newCachedThreadPool或newFixedThreadPool<br>2 调用submit提交Runnable或Callable 对象<br>3 如果想要取消一个任务 或如果提交Callable对象 那就要保存好返回的Future对象<br>4 当不再提交任何任务时 调用shutdown<br>下面是一个代码示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">import java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by han on 2016/11/3.</span><br><span class="line"> */</span><br><span class="line">public class FututreTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">    Scanner in = new Scanner(System.in);</span><br><span class="line">    System.out.println(&quot;Enter directory()&quot;);</span><br><span class="line">    String directory = in.nextLine();</span><br><span class="line">    System.out.println(&quot;Enter keyWord()&quot;);</span><br><span class="line">    String keyWord = in.nextLine();</span><br><span class="line"></span><br><span class="line">    ExecutorService pool = Executors.newCachedThreadPool();</span><br><span class="line">    MatchCounter counter = new MatchCounter(new File(directory), keyWord, pool);</span><br><span class="line">    Future&lt;Integer&gt;result=pool.submit(counter);</span><br><span class="line"></span><br><span class="line">    System.out.println(result.get() + &quot; matching files. &quot;);</span><br><span class="line">    pool.shutdown();</span><br><span class="line">    int largestPoolSize=((ThreadPoolExecutor) pool).getLargestPoolSize();</span><br><span class="line">    System.out.println(&quot;largest pool size=&quot;+largestPoolSize);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class  MatchCounter implements Callable&lt;Integer&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">private File directory;</span><br><span class="line">private  String keyword;</span><br><span class="line">private int count;</span><br><span class="line">private ExecutorService pool;</span><br><span class="line"></span><br><span class="line">public MatchCounter(File directory, String keyword, ExecutorService pool) &#123;</span><br><span class="line">    this.directory=directory;</span><br><span class="line">    this.keyword=keyword;</span><br><span class="line">    this.pool=pool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Integer call() throws Exception &#123;</span><br><span class="line">    count=0;</span><br><span class="line">    File[] files = directory.listFiles();</span><br><span class="line">    List&lt;Future&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;();</span><br><span class="line">    for (File file:files)</span><br><span class="line">        if (file.isDirectory()) &#123;</span><br><span class="line">            MatchCounter counter = new MatchCounter(file, keyword, pool);</span><br><span class="line">            Future&lt;Integer&gt; result = pool.submit(counter);</span><br><span class="line">            results.add(result);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (search(file)) count++;</span><br><span class="line">        &#125;</span><br><span class="line">    for (Future&lt;Integer&gt; result : results) &#123;</span><br><span class="line">            count += result.get();//在这里将其他线程查找的结果相加</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public  boolean search(File file)&#123;</span><br><span class="line">    try(Scanner in=new Scanner(file)) &#123;</span><br><span class="line">       boolean found=false;</span><br><span class="line">        while (!found &amp;&amp; in.hasNext()) &#123;</span><br><span class="line">            String line = in.nextLine();</span><br><span class="line">            if(line.contains(keyword))found=true;</span><br><span class="line">        &#125;</span><br><span class="line">        return found;</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">        System.out.println(e.getMessage());</span><br><span class="line">        return  false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="预定执行"><a href="#预定执行" class="headerlink" title="预定执行"></a>预定执行</h3><p>ScheduledExecutorService接口具有预定执行或重复执行任务而设计的方法 它是一种允许使用线程池机制的java.util.Timer的泛化<br>Executors类的newScheduledThreadPool和newSingleThreadScheduledExecutor方法将返回实现了ScheduledExecutorService<br>接口的对象</p><p>可以预定Runable或Callable在初始的延迟之后只运行一次<br>也可以指定一个Runable对象周期性的运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">importjava.util.concurrent.Executors;</span><br><span class="line">importjava.util.concurrent.ScheduledExecutorService;</span><br><span class="line">importjava.util.concurrent.ScheduledFuture;</span><br><span class="line"></span><br><span class="line">importstaticjava.util.concurrent.TimeUnit.*;</span><br><span class="line">publicclassBeeperControl &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">privatefinalScheduledExecutorService scheduler =</span><br><span class="line">Executors.newScheduledThreadPool(1);</span><br><span class="line"></span><br><span class="line">publicvoidbeepForAnHour() &#123;</span><br><span class="line">//执行内容</span><br><span class="line">finalRunnable beeper = newRunnable() &#123;</span><br><span class="line">publicvoidrun() &#123; System.out.println(&quot;beep&quot;); &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">//具体执行设置 为10秒延迟和连续成功间隔时间10秒</span><br><span class="line">finalScheduledFuture&lt;?&gt; beeperHandle =</span><br><span class="line">scheduler.scheduleAtFixedRate(beeper, 10, 10, SECONDS);</span><br><span class="line">//1小时关闭这个线程</span><br><span class="line">scheduler.schedule(newRunnable() &#123;</span><br><span class="line">publicvoidrun() &#123;</span><br><span class="line">beeperHandle.cancel(true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, 60 * 60, SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">publicstaticvoidmain(String[] args) &#123;</span><br><span class="line">try&#123;</span><br><span class="line">//反射</span><br><span class="line">BeeperControl beeperControl = BeeperControl.class.newInstance();</span><br><span class="line">beeperControl.beepForAnHour();</span><br><span class="line">         &#125; catch(InstantiationException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">         &#125; catch(IllegalAccessException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>控制任务组</strong><br>我们已经知道如何将一个执行器服务作为线程池使用，以提高执行任务的效率。有时候，我们要使用执行器来做更有实际意义的事，控制一组相关的任务。例如，<strong>可以在执行器中使用shutdownNow方法取消所有的任务。</strong></p><p><strong>invokeAll方法</strong>提交所有对象到一个Callable对象的集合中，并返回某个已经完成了任务的结果 无法知道返回的究竟是哪个任务的结果 也许是最先完成的那个任务的结果 如果你愿意接受任何一种解决方案的话 就可以使用它<br><strong>invokeAll方法提交所有对象到一个Callable对象的集合中</strong>，并返回一个Future对象的列表，<strong>代表所有任务的解决方案</strong> 当计算结果可获得时 可以像下面这样对结果进行处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Callable&lt;T&gt;&gt; tasks = .......;</span><br><span class="line">List&lt;Future&lt;?&gt;&gt; results = pool.invokeAll(tasks);</span><br><span class="line">for (Future&lt;T&gt; result:results) &#123;</span><br><span class="line">    processFuture(result.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的缺点是如果第一个任务花去了很多时间，那么就可能不得不进行等待。将结果按可获得的顺序保存起来更有意义。可以用ExecutorComeletionService来进行排序。<br>具体可以查询API。用常规的方法获得一个执行器。然后，构建一个ExecutorComeletionService，提交任务给完成服务。该服务管理Future对象的阻塞队列，其中包含已经提交的任务的执行结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">ExecutorCompletionService service = new ExecutorCompletionService&lt;&gt;(executor);</span><br><span class="line">for (Callable&lt;T&gt; task : tasks) &#123;</span><br><span class="line">  service.submit(task);</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 0; i &lt; task.size(); i++) &#123;</span><br><span class="line">  processFurther(service.take().get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork-Join框架"></a>Fork-Join框架</h3><p>　fork/join框架是ExecutorService接口的一个实现，可以帮助开发人员充分利用多核处理器的优势，编写出并行执行的程序，提高应用程序的性能；设计的目的是为了处理那些可以被递归拆分的任务。<br>　　fork/join框架与其它ExecutorService的实现类相似，会给线程池中的线程分发任务，不同之处在于它使用了工作窃取算法，所谓工作窃取，指的是对那些处理完自身任务的线程，会从其它线程窃取任务执行。<br>　　fork/join框架的核心是ForkJoinPool类，该类继承了AbstractExecutorService类。ForkJoinPool实现了工作窃取算法并且能够执 行 ForkJoinTask任务。</p><p><a href="http://www.infoq.com/cn/articles/fork-join-introductionFork" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/fork-join-introductionFork</a> Join框架详解<br>有的应用程序使用了大量的线程，但其中大多数都是空闲的。举例来说，一个Web服务器可能会为每个连接分别使用一个线程。另外一些应用可能对每个处理器内核分别使用一个线程，来完成计算密集的任务，如图像或视频处理。Java SE 7 中新引入了fork-join框架，专门用来支持后一类的应用。</p><p>我们来讨论一个简单的例子。假设我们想统计一个数组中有多少个元素满足某个特定的属性。可以将这个数组一分为二，分别对着两部分进行统计，再将结果相加。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * This program demonstrates the fork-join framework.</span><br><span class="line"> * @version 1.00 2012-05-20</span><br><span class="line"> * @author Cay Horstmann</span><br><span class="line"> */</span><br><span class="line">public class ForkJoinTest</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">   &#123;</span><br><span class="line">final int SIZE = 10000000;</span><br><span class="line">      double[] numbers = new double[SIZE];</span><br><span class="line">      for (int i = 0; i &lt; SIZE; i++) numbers[i] = Math.random();</span><br><span class="line">Counter counter = new Counter(numbers, 0, numbers.length, </span><br><span class="line">         new Filter()</span><br><span class="line">         &#123;</span><br><span class="line">public boolean accept(double x) &#123; return x &gt; 0.5; &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">ForkJoinPool pool = new ForkJoinPool();</span><br><span class="line">pool.invoke(counter);</span><br><span class="line">System.out.println(counter.join());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Filter</span><br><span class="line">&#123;</span><br><span class="line">boolean accept(double t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Counter extends RecursiveTask&lt;Integer&gt;</span><br><span class="line">&#123;</span><br><span class="line">public static final int THRESHOLD = 1000;</span><br><span class="line">   private double[] values;</span><br><span class="line">   private int from;</span><br><span class="line">   private int to;</span><br><span class="line">   private Filter filter;</span><br><span class="line"></span><br><span class="line">   public Counter(double[] values, int from, int to, Filter filter)</span><br><span class="line">   &#123;</span><br><span class="line">this.values = values;</span><br><span class="line">      this.from = from;</span><br><span class="line">      this.to = to;</span><br><span class="line">      this.filter = filter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected Integer compute()</span><br><span class="line">   &#123;</span><br><span class="line">if (to - from &lt; THRESHOLD)</span><br><span class="line">      &#123;</span><br><span class="line">int count = 0;</span><br><span class="line">         for (int i = from; i &lt; to; i++)</span><br><span class="line">         &#123;</span><br><span class="line">if (filter.accept(values[i])) count++;</span><br><span class="line">&#125;</span><br><span class="line">return count;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">int mid = (from + to) / 2;</span><br><span class="line">Counter first = new Counter(values, from, mid, filter);</span><br><span class="line">Counter second = new Counter(values, mid, to, filter);</span><br><span class="line">invokeAll(first, second);</span><br><span class="line">         return first.join() + second.join();</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里invokeAll方法接受到很多任务并阻塞 直到所有这些任务都已经完成 join方法将生成结果 我们对每个子任务应用了join 并返回总和</p><p>在后台 fork-join框架使用了一种有效的智能方法来平衡可用线程的工作负载 这种方法被称为<strong>工作密取</strong> 每个线程有一个双端队列来完成任务 一个工作线程将子任务压入其双端队列的队头 一个工作线程空闲时 它会从另一个双端队列的队尾密取</p><h2 id="同步器"><a href="#同步器" class="headerlink" title="同步器"></a>同步器</h2><p>java.util.concurrent 包包含了几个能帮助人们管理相互合作的线程集的类见表 这些机制具有为线程之间的共用集合点模式 提供的预置功能<br>如果一个相互合作的线程集能满足这些行为模式之一 那么应该直接重用合适的库类而不要试图提供手工的锁与条件的集合</p><table><thead><tr><th style="text-align:left">类</th><th style="text-align:left">它能做什么</th><th style="text-align:left">何时使用</th></tr></thead><tbody><tr><td style="text-align:left">CyclicBarrier</td><td style="text-align:left">允许线程集等待直至其中预定数目的线程到达一个公共障栅 然后可以选择执行一个处理障栅的动作</td><td style="text-align:left">当大量的线程需要在它们的结果可用之前完成时</td></tr><tr><td style="text-align:left">CountDownLatch</td><td style="text-align:left">允许线程集等待直到计算器减为0</td><td style="text-align:left">当一个或多个线程需要等待直到指定数目的事件发生</td></tr><tr><td style="text-align:left">Exchanger</td><td style="text-align:left">允许俩个线程在要交换的对象准备好时交换对象</td><td style="text-align:left">当俩个线程工作在同一数据结构的俩个实例上的时候 ，一个向实例添加数据 ，而另一个从实例清除数据。</td></tr><tr><td style="text-align:left">Semaphre</td><td style="text-align:left">允许线程集等待直到被允许继续运行为止</td><td style="text-align:left">限制访问资源的线程总数。如果许可数是1 常常阻塞线程直到另一个线程给许可为止</td></tr><tr><td style="text-align:left">SynchronousQueue</td><td style="text-align:left">允许一个线程把对象交给另外一个线程</td><td style="text-align:left">在没有显示同步的情况下 ，当俩个线程准备好将一个对象从一个线程传递到另一时</td></tr></tbody></table><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>关于信号量 概念上讲 一个信号量是管理许多的许可证 为了通过信号量 线程通过调用acquire请求许可 其实没有实际的许可对象 信号量仅维护一个计数 许可的数目是固定的 由此限制了通过的线程数量<br>线程是作为同步原语的 在许多操作系统的书中基本都有出现 由信号量实现了有界队列 通常 信号量不比直接映射到通用应用场景</p><h3 id="倒计时门栓"><a href="#倒计时门栓" class="headerlink" title="倒计时门栓"></a>倒计时门栓</h3><p>一个倒计时门栓上一个线程集等待直到计数变为0 倒计时门栓是一次性 一旦计数为0 就不能再重用了<br>一个有用的特例是计数值为1 的门栓 实现一个只能通过一次的门</p><h3 id="障栅"><a href="#障栅" class="headerlink" title="障栅"></a>障栅</h3><p>CyclicBarrier类实现了一个集结点(rendezvous)称为<strong>屏障/障栅</strong>(barrier)。考虑大量线程运行在一次计算的不同部分的情况，当所有部分都准备好时，需要把结果组合在一起。当一个线程完成了它那部分任务之后，我们让它运行到屏障/障栅处。一旦所有的线程都到达了这个屏障/障栅，屏障/障栅就撤销，线程就可以继续运行。</p><ol><li><p>构造一个屏障/障栅，并给出参与的线程数</p><p>CyclicBarrier barrier = new CyclicBarrier(nThreads);</p></li><li><p>每一个线程做一些工作，完成后在屏障/障栅上调用await</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  public void run()&#123;</span><br><span class="line"> doWork();</span><br><span class="line"> barrier.await();</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>如果任何一个在屏障/障栅上等待的线程离开了屏障/障栅，那么屏障/障栅就破坏了</strong>（线程离开的原因：线程调用的await超时或因为它被中断了），在这种情况下所有其他线程的await方法抛出BrokenBarrierException异常。那些已经在等待的线程立即终止await的调用。</p></li><li><p>可以<strong>提供一个可选的屏障/障栅动作(barrier action)</strong>，当所有线程到达屏障/障栅的时候就会执行这一动作，该动作可以<strong>收集那些单个线程的运行结果。</strong></p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Runnable barrierAction = ...;</span><br><span class="line">CyclicBarrier barrier = new CyclicBarrier(nThreads, barrierAction);</span><br></pre></td></tr></table></figure><blockquote><p>注意 : 屏障/障栅被称为是循环的(cyclic)，因为可以在所有等待线程被释放后重用，而CountDownLatch只能被使用一次。</p></blockquote><p>下面是网上找的Demo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line">import java.util.concurrent.CyclicBarrier;</span><br><span class="line">import static java.lang.System.*;</span><br><span class="line"></span><br><span class="line">public class CyclicBarrierTest</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">final int[] arr = new int[3];</span><br><span class="line">//可以提供一个可选的 障栅 动作（Barrier Action）， 当所有线程到达障栅的时候就会执行这个工作</span><br><span class="line">//CyclicBarrier cyclicBarrier = new CyclicBarrier(nthreds, barrienAction)</span><br><span class="line">CyclicBarrier cyclicBarrier = new CyclicBarrier(2, new Runnable()</span><br><span class="line">        &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run()</span><br><span class="line">            &#123;</span><br><span class="line">arr[2] = arr[0] + arr[1];</span><br><span class="line">for (int i = 0; i &lt; arr.length; i++)</span><br><span class="line">out.println(&quot;arr[&quot; + i +&quot;] = &quot; + arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">new Thread(new MyCyclicBarrier(1, arr, cyclicBarrier)).start();</span><br><span class="line">new Thread(new MyCyclicBarrier(0, arr, cyclicBarrier)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyCyclicBarrier implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">int id;</span><br><span class="line">int[] arr;</span><br><span class="line">CyclicBarrier cyclicBarrier;</span><br><span class="line"></span><br><span class="line">public MyCyclicBarrier(int id, int[] arr, CyclicBarrier barrier)</span><br><span class="line">    &#123;</span><br><span class="line">this.id = id;</span><br><span class="line">this.arr = arr;</span><br><span class="line">this.cyclicBarrier = barrier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run()</span><br><span class="line">    &#123;</span><br><span class="line">arr[id] = new Random().nextInt(100);</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">out.println(id + &quot; starts to have a rest!&quot;);</span><br><span class="line">cyclicBarrier.await();</span><br><span class="line">out.println(id + &quot; wake up!&quot;);</span><br><span class="line">        &#125; catch (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="交换器"><a href="#交换器" class="headerlink" title="交换器"></a>交换器</h3><p>当俩个线程在同一个数据缓冲区的俩个实例上工作的时候 就可以使用交换器(Exchanger)了<br>典型的情况是，一个线程向一个缓冲区填入数据，另一个线程消耗这些数据，当它们都完成后，相互交换缓冲区。</p><h3 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h3><p>同步队列是一种将生产者与消费者线程配对的机制 当一个线程调用SynchronousQueue的put方法时 它会阻塞直到另一个线程调用take方法为止 反之亦然 与Exchanger的情况不同 数据仅仅沿着一个方向传递 从生产者到消费者</p><blockquote><p>注意 即使SynchronousQueue类实现了BockingQueue接口 概念上讲 它依然不是一个队列 它没有包含任何元素</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第14章-多线程&quot;&gt;&lt;a href=&quot;#第14章-多线程&quot; class=&quot;headerlink&quot; title=&quot;第14章 多线程&quot;&gt;&lt;/a&gt;第14章 多线程&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;其他章节的笔记也都记下 在本人的Github中 因为不是markdown格式 所以打印为PDF&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="JAVA" scheme="http://yoursite.com/tags/JAVA/"/>
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>浅谈数据库XS锁实现事务 从而方便理解脏读 不可重复读 幻读</title>
    <link href="http://yoursite.com/2017/03/16/%E6%B5%85%E8%B0%88%E6%95%B0%E6%8D%AE%E5%BA%93XS%E9%94%81%E5%AE%9E%E7%8E%B0%E4%BA%8B%E5%8A%A1%20%E4%BB%8E%E8%80%8C%E6%96%B9%E4%BE%BF%E7%90%86%E8%A7%A3%E8%84%8F%E8%AF%BB%20%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%20%E5%B9%BB%E8%AF%BB/"/>
    <id>http://yoursite.com/2017/03/16/%E6%B5%85%E8%B0%88%E6%95%B0%E6%8D%AE%E5%BA%93XS%E9%94%81%E5%AE%9E%E7%8E%B0%E4%BA%8B%E5%8A%A1%20%E4%BB%8E%E8%80%8C%E6%96%B9%E4%BE%BF%E7%90%86%E8%A7%A3%E8%84%8F%E8%AF%BB%20%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%20%E5%B9%BB%E8%AF%BB/</id>
    <published>2017-03-15T16:00:00.000Z</published>
    <updated>2019-12-01T10:55:12.006Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浅谈数据库XS锁实现事务-从而方便理解脏读-不可重复读-幻读"><a href="#浅谈数据库XS锁实现事务-从而方便理解脏读-不可重复读-幻读" class="headerlink" title="浅谈数据库XS锁实现事务 从而方便理解脏读 不可重复读 幻读"></a>浅谈数据库XS锁实现事务 从而方便理解脏读 不可重复读 幻读</h1><p>事务的最基本性质是ACID性质 关于这几个性质 我这里就不展开了<br>这是事务要实现的基础 这里具体解释的话内容太多 我也可能水平不够 不能够完整明确的讲解出来 但是需要记住事务实现的几个性质是ACID<br>分别是<br><a id="more"></a></p><ul><li>Atomicity 原子性</li><li>Consistency 一致性</li><li>Isolation 隔离性</li><li>Durability 持久性</li></ul><p>接下来直入主题 关于事务呢 就是实现并发下的不同客户的操作 也就是数据库的并发控制<br>并发会带来一些问题 在我个人的本科教科书上 是比常规的来说要多一个问题 这个问题在具体开发的时候并没有什么意义 这个属于最基本的保障 哪怕是最基本的数据库事务隔离级别也会实现它 这就是丢失更新问题 下面再详述 其他的三个就是属于本文上的 脏读 不可重复读 幻读<br>我们来一一说明下面为什么发生 具体在什么时候 什么原因下</p><blockquote><p>下面的Find 就是为读数据 UPD就是更新数据 XFIND暂时理解为Find Rollback回滚 Commit提交</p></blockquote><h3 id="丢失更新问题"><a href="#丢失更新问题" class="headerlink" title="丢失更新问题"></a>丢失更新问题</h3><p>在7时间 丢失了事务T1的更新</p><p><a href="https://github.com/SanShanYouJiu/ImageRepository/blob/master/数据库事务/丢失更新模拟.jpg?raw=true" target="_blank" rel="noopener"><img src="https://github.com/SanShanYouJiu/ImageRepository/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/%E4%B8%A2%E5%A4%B1%E6%9B%B4%E6%96%B0%E6%A8%A1%E6%8B%9F.jpg?raw=true" alt="img"></a></p><h3 id="读脏数据"><a href="#读脏数据" class="headerlink" title="读脏数据"></a>读脏数据</h3><p>读到了尚未提交的数据<br>一个是读了脏数据 但是没有破坏数据库完整性<br><a href="https://github.com/SanShanYouJiu/ImageRepository/blob/master/数据库事务/脏读模拟.png?raw=true" target="_blank" rel="noopener"><img src="https://github.com/SanShanYouJiu/ImageRepository/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/%E8%84%8F%E8%AF%BB%E6%A8%A1%E6%8B%9F.png?raw=true" alt="img"></a><br>另外一个就是读了脏数据 引起了数据丢失 破坏了数据库完整性<br><a href="https://github.com/SanShanYouJiu/ImageRepository/blob/master/数据库事务/脏读丢失更新.png?raw=true" target="_blank" rel="noopener"><img src="https://github.com/SanShanYouJiu/ImageRepository/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/%E8%84%8F%E8%AF%BB%E4%B8%A2%E5%A4%B1%E6%9B%B4%E6%96%B0.png?raw=true" alt="img"></a></p><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>表示为T1需要俩次读取同一数据项 但是在俩次操作的间隔中 另一个事务T2改变了A的值<br><a href="https://github.com/SanShanYouJiu/ImageRepository/blob/master/数据库事务/不可重复读.png?raw=true" target="_blank" rel="noopener"><img src="https://github.com/SanShanYouJiu/ImageRepository/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB.png?raw=true" alt="img"></a></p><h3 id="关于幻读"><a href="#关于幻读" class="headerlink" title="关于幻读"></a>关于幻读</h3><p>幻读的情况我暂且口述</p><blockquote><p>以后有机会再重新画个图</p></blockquote><p>这是在一个整体上的错误读写 事务T2读取到了这个表中有20行数据 并且针对这整个20行进行了修改数据<br>事务T1在这个过程中插入或删除行等方式来修改了这个表的20行数据<br>假设为插入 使其变为了21行<br>那么以后操作T2这个用户发现这个表中还有没有被影响到的行 就像产生了幻觉一样</p><hr><p>这些问题都需要并发控制子系统来实现<br>那么就要说到本文的主题XS锁了<br><strong>排他性封锁（X锁）写锁</strong></p><blockquote><p>定义为 如果事务T对某个数据R（可以是数据项 记录 数据集 乃至于整个数据库）实现了X锁 那么在T对数据R解除封锁之前 不允许其他事务T再对该数据加任何类型的锁 这个数据加了X锁之后只能被该事务进行读写</p></blockquote><ul><li>申请X锁的操作为XFIND R 表示事物对数据R申请加X锁 若成功 则可以读写数据R 若不成功，那么这个事务就会进入等待队列 一直到获准X锁 事务才能继续做下去</li><li>解除操作为 XRELEASE R 表示事务要解除对数据R的X锁<br>如果过早的解锁 有可能其他事务读了未提交数据（且随后被撤回） 引起丢失其他事务的更新 x锁的接触操作应该合并到事务的结束（ROLLBACK和COMMIT语句中包含了解除X锁的操作）</li></ul><p><strong>共享型封锁(S锁) 读锁</strong><br>因为加X锁的只能被一个事务进行读写 所以为了并发的读 加入了S锁</p><blockquote><p>定义为 如果事务T对数据加上S锁后 仍需要其他事务再对该数据加S锁<br>但在该数据的所有S锁都解除之前决不允许任何事务对该数据加X锁</p></blockquote><p>使用S锁的操作有三个</p><ul><li>申请S锁 SFIND R 表示事务对数据R申请加S锁<br>若成功则可以读数据R 但不可以写数据R</li><li>升级和写操作 UPDX R 表示事务要吧数据R的S锁升级为X锁 若成功则更新数据R 否则这个事务进入等待队列</li><li>解除S锁操作 SRELEASE R</li></ul><p>那我们就到了关键的部分了</p><blockquote><p>这里提及一下关于封锁的粒度注意问题 封锁对象越大 并发度就越小 开销也就越小 相反的粒度越小 开销就大</p></blockquote><p>在并发系统中是利用一个封锁协议来操作XS锁进行并发子系统控制的<br>这个封锁协议如下</p><table><thead><tr><th style="text-align:left">级别</th><th style="text-align:left">内 容</th><th style="text-align:left">内容</th><th style="text-align:left">内容</th><th style="text-align:left">优点</th><th style="text-align:left">缺点</th></tr></thead><tbody><tr><td style="text-align:left">一级封锁协议</td><td style="text-align:left">事务在修改数据之前，必须先对该数据加X锁直到事务结束时才释放</td><td style="text-align:left">但只读数据可以不加锁</td><td style="text-align:left">但只读数据可以不加锁</td><td style="text-align:left">防止丢失修改</td><td style="text-align:left">不加锁的数据 可能“读脏数据” 也可能“不可重复读”</td></tr><tr><td style="text-align:left">二级封锁协议</td><td style="text-align:left">同上</td><td style="text-align:left">但其他事务在读数据之前必须先加S锁</td><td style="text-align:left">读完数据后即可释放S锁</td><td style="text-align:left">防止“丢失修改” 防止“脏数据”</td><td style="text-align:left">对加S锁的事务 可能“不可重复读”</td></tr><tr><td style="text-align:left">三级封锁协议</td><td style="text-align:left">同上</td><td style="text-align:left">同上</td><td style="text-align:left">直到事务结束时才释放S锁</td><td style="text-align:left">防止“丢失修改”防止“读脏数据” 防止“不可重复读”</td><td style="text-align:left">无</td></tr></tbody></table><h3 id="那我们还是可能出现幻读-那幻读怎么实现避免的呢"><a href="#那我们还是可能出现幻读-那幻读怎么实现避免的呢" class="headerlink" title="那我们还是可能出现幻读 那幻读怎么实现避免的呢"></a>那我们还是可能出现幻读 那幻读怎么实现避免的呢</h3><p>这就是SERIALIZABLE 中文翻译过来叫串行化 这是多个事务依次执行的效果 如果利用分时的方法 同时处理多个事务 则称为事务的并行</p><h3 id="可串行化概念"><a href="#可串行化概念" class="headerlink" title="可串行化概念"></a>可串行化概念</h3><blockquote><p>每个事务中 语句的先后顺序在各种调度中始终保持一致 在这个前提下 如果一个并发调度的执行结果和某一串行调度的结果等价 那么 这个调度就被称为“可串行化的调度” 否则就是不可串行化的调度</p></blockquote><p>在这种情况下 我们可以保证每个事务的结果都是正确的 也自然防止了幻读</p><p>最后</p><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p>SQL提供事务的四种隔离级别让用户选择 这四个级别从高到低如下所述</p><ul><li>SERIALIZABLE(可串行化）: 允许事务与其他事务并发执行 但系统必须保证并发调度是可串行化的 不致发生错误</li><li>REPEATABLE READ（可重复读）: 只允许事务读已提交的数据 并且在俩次读同一数据时不允许其他事务修改此数据</li><li>READ COMMITTED（读提交数据）:允许事务读已提交的数据 但不要求“可重复读” 例如 事务对同一记录的俩次读取之间 记录可能已被提交的事务更新</li><li>READ UNCOMMITTED（可以读未提交数据）：允许事务读已提交或未提交的数据 这是数据库允许的最低级别</li></ul><blockquote><h2 id="参考于本科教材"><a href="#参考于本科教材" class="headerlink" title="参考于本科教材"></a>参考于本科教材</h2></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;浅谈数据库XS锁实现事务-从而方便理解脏读-不可重复读-幻读&quot;&gt;&lt;a href=&quot;#浅谈数据库XS锁实现事务-从而方便理解脏读-不可重复读-幻读&quot; class=&quot;headerlink&quot; title=&quot;浅谈数据库XS锁实现事务 从而方便理解脏读 不可重复读 幻读&quot;&gt;&lt;/a&gt;浅谈数据库XS锁实现事务 从而方便理解脏读 不可重复读 幻读&lt;/h1&gt;&lt;p&gt;事务的最基本性质是ACID性质 关于这几个性质 我这里就不展开了&lt;br&gt;这是事务要实现的基础 这里具体解释的话内容太多 我也可能水平不够 不能够完整明确的讲解出来 但是需要记住事务实现的几个性质是ACID&lt;br&gt;分别是&lt;br&gt;
    
    </summary>
    
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
</feed>
